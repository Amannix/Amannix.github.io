<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiong&#39;blog</title>
  
  <subtitle>渡得八千风沙起，揽下九天明月心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://amannix.github.io/"/>
  <updated>2018-11-07T12:30:54.645Z</updated>
  <id>https://amannix.github.io/</id>
  
  <author>
    <name>熊梦彪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysterious Crime(子区间匹配)</title>
    <link href="https://amannix.github.io/2018/11/07/Mysterious%20Crime/"/>
    <id>https://amannix.github.io/2018/11/07/Mysterious Crime/</id>
    <published>2018-11-07T11:52:37.000Z</published>
    <updated>2018-11-07T12:30:54.645Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1043/problem/D" target="_blank" rel="noopener">Codeforces Round #519</a><br><strong>Description</strong><br><div class="note default"><p>Acingel is a small town. There was only one doctor here — Miss Ada. She was very friendly and nobody has ever said something bad about her, so who could’ve expected that Ada will be found dead in her house? Mr Gawry, world-famous detective, is appointed to find the criminal. He asked m neighbours of Ada about clients who have visited her in that unlucky day. Let’s number the clients from 1 to n. Each neighbour’s testimony is a permutation of these numbers, which describes the order in which clients have been seen by the asked neighbour.</p><p>However, some facts are very suspicious – how it is that, according to some of given permutations, some client has been seen in the morning, while in others he has been seen in the evening? “In the morning some of neighbours must have been sleeping!” — thinks Gawry — “and in the evening there’s been too dark to see somebody’s face…”. Now he wants to delete some prefix and some suffix (both prefix and suffix can be empty) in each permutation, so that they’ll be non-empty and equal to each other after that — some of the potential criminals may disappear, but the testimony won’t stand in contradiction to each other.</p><p>In how many ways he can do it? Two ways are called different if the remaining common part is different.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains two integers n and m (1≤n≤100000, 1≤m≤10) — the number of suspects and the number of asked neighbors.</p><p>Each of the next m lines contains nn integers a1,a2,…,an (1≤ai≤n). It is guaranteed that these integers form a correct permutation (that is, each number from 1 to n appears exactly once).</p></div><br><strong>Output</strong><br><div class="note default"><p>Output a single integer denoting the number of ways to delete some prefix and some suffix of each permutation (possibly empty), such that the remaining parts will be equal and non-empty.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5 6<br>1 2 3 4 5<br>2 3 1 4 5<br>3 4 5 1 2<br>3 5 4 2 1<br>2 3 5 4 1<br>1 2 3 4 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>5</p></blockquote><p><strong>Thinking</strong><br>灰常有意思的一道区间匹配问题，给出一行1到N的全排列，总共有M行。求这M行中的公共子区间是多少，例如：12543和43512.首先每个单独的数字就是他们最小的一个子区间，然后12也是他们的公共子区间，这道题就是要求出所有的公共子区间有多少。首先暴力肯定是不能暴力的了，由于每个数字在一行上只会出现一次。所以可以桶哈希记录每个数字出现的位置，方便查找。接下来就是匹配子区间了，以第一行为基准枚举，从第一个数字开始纵向匹配，去匹配最长的公共子区间如果找到一个子区间，那么枚举变量跳转到区间左边（最小的区间一定是单个数字）那么对于横向枚举来说一定是线性时间，由于要纵向对比，所以总的时间复杂度是O(N*M)。现在如果匹配到了一个子区间长度为K，那么对于这段子区间来说它的所有的子区间都一定是公共子区间，所以它包含的公共子区间一定是1+2+3…+K。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">15</span>][<span class="number">200010</span>],hash[<span class="number">15</span>][<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//直接求出第一组第s个数据开始向后最多可以匹配到多长的公共子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="comment">/*由于这个匹配是默认从第二组开始的所以无法判断只有一组数据的情况</span></span><br><span class="line"><span class="comment">             *理论上改成i = 1可解决。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> k = hash[i][buf[<span class="number">1</span>][s]] + cnt;</span><br><span class="line">            <span class="keyword">if</span> (buf[<span class="number">1</span>][s+cnt] != buf[i][k] || s+cnt &gt; n || k &gt; n)&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">fact</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//注意这个前k项和的数据范围</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k; ++i)&#123;</span><br><span class="line">        ans += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;buf[i][j]);</span><br><span class="line">            hash[i][buf[i][j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)&#123;<span class="comment">//需要特判一下只有一组数据的情况</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,fact(n));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = judge(i);</span><br><span class="line">        ans += fact(temp);<span class="comment">//这段公共子串的组合数等于其长度的1+2+3……+temp。</span></span><br><span class="line">        i += temp;<span class="comment">//跳过这段公共子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1043/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round #519&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Acingel is a small town. There was only one doctor here — Miss Ada. She was very friendly and nobody has ever said something bad about her, so who could’ve expected that Ada will be found dead in her house? Mr Gawry, world-famous detective, is appointed to find the criminal. He asked m neighbours of Ada about clients who have visited her in that unlucky day. Let’s number the clients from 1 to n. Each neighbour’s testimony is a permutation of these numbers, which describes the order in which clients have been seen by the asked neighbour.&lt;/p&gt;
&lt;p&gt;However, some facts are very suspicious – how it is that, according to some of given permutations, some client has been seen in the morning, while in others he has been seen in the evening? “In the morning some of neighbours must have been sleeping!” — thinks Gawry — “and in the evening there’s been too dark to see somebody’s face…”. Now he wants to delete some prefix and some suffix (both prefix and suffix can be empty) in each permutation, so that they’ll be non-empty and equal to each other after that — some of the potential criminals may disappear, but the testimony won’t stand in contradiction to each other.&lt;/p&gt;
&lt;p&gt;In how many ways he can do it? Two ways are called different if the remaining common part is different.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://amannix.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Smallest Word(思维、字符串)</title>
    <link href="https://amannix.github.io/2018/11/07/Smallest%20Word/"/>
    <id>https://amannix.github.io/2018/11/07/Smallest Word/</id>
    <published>2018-11-07T10:21:11.000Z</published>
    <updated>2018-11-07T12:23:14.479Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1043/problem/C" target="_blank" rel="noopener">Codeforces Round 519</a><br><strong>Description</strong><br><div class="note default"><p>IA has so many colorful magnets on her fridge! Exactly one letter is written on each magnet, ‘a’ or ‘b’. She loves to play with them, placing all magnets in a row. However, the girl is quickly bored and usually thinks how to make her entertainment more interesting.</p><p>Today, when IA looked at the fridge, she noticed that the word formed by magnets is really messy. “It would look much better when I’ll swap some of them!” — thought the girl — “but how to do it?”. After a while, she got an idea. IA will look at all prefixes with lengths from 1 to the length of the word and for each prefix she will either reverse this prefix or leave it as it is. She will consider the prefixes in the fixed order: from the shortest to the largest. She wants to get the lexicographically smallest possible word after she considers all prefixes. Can you help her, telling which prefixes should be chosen for reversing?</p><blockquote><p>A string a is lexicographically smaller than a string b if and only if one of the following holds:</p></blockquote><blockquote><p>a is a prefix of b, but a≠b;</p></blockquote><p>in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first and the only line contains a string s (1≤|s|≤1000), describing the initial string formed by magnets. The string s consists only of characters ‘a’ and ‘b’.</p></div><br><strong>Output</strong><br><div class="note default"><p>Output exactly |s| integers. If IA should reverse the i-th prefix (that is, the substring from 1 to i), the ii-th integer should be equal to 1, and it should be equal to 0 otherwise.</p><p>If there are multiple possible sequences leading to the optimal answer, print any of them.</p></div><br><strong>Sample Input</strong></p><blockquote><p>bbab</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0 1 1 0</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>aaaaa</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 0 0 0 1</p></blockquote><p><strong>Thinking</strong><br>给出一个只有a、b组成的字符串，可以在每一个位置选择是否反转前缀，求一个操作序列使得整个字符串的字典序最小。那最好可以把所有的a都反转到开头的位置就最好了，因此可以在遇到一个’a’的时候，将前面的前缀反转，使得首部的’a’反转到遇到的这个’a’然后在把整各反转回去，例如：abbabb，当遇到第二个’a’的时候，需要先反转成bbaabb，然后再反转成aabbbb。但是需要注意当出现abbaabba的时候，按照之前的规则会导致答案为1 0 1 1 1 0 1 1，但是按照这样的答案是错误的。因为当遇到连续的’a’时，必须直接把这串连续的’a’全部一次反转回去，详情见代码。</p><p><strong>Thinking</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'a'</span>)&#123;</span><br><span class="line">            val[i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt;= len; ++j)&#123;<span class="comment">//搜索连续的'a'区间。</span></span><br><span class="line">                <span class="keyword">if</span> (str[j+<span class="number">1</span>] == <span class="string">'b'</span> || j == len)&#123;</span><br><span class="line">                    val[j] = <span class="number">1</span>;</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,val[i],i==len ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1043/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round 519&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;IA has so many colorful magnets on her fridge! Exactly one letter is written on each magnet, ‘a’ or ‘b’. She loves to play with them, placing all magnets in a row. However, the girl is quickly bored and usually thinks how to make her entertainment more interesting.&lt;/p&gt;
&lt;p&gt;Today, when IA looked at the fridge, she noticed that the word formed by magnets is really messy. “It would look much better when I’ll swap some of them!” — thought the girl — “but how to do it?”. After a while, she got an idea. IA will look at all prefixes with lengths from 1 to the length of the word and for each prefix she will either reverse this prefix or leave it as it is. She will consider the prefixes in the fixed order: from the shortest to the largest. She wants to get the lexicographically smallest possible word after she considers all prefixes. Can you help her, telling which prefixes should be chosen for reversing?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A string a is lexicographically smaller than a string b if and only if one of the following holds:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a is a prefix of b, but a≠b;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://amannix.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Lost Array(推导)</title>
    <link href="https://amannix.github.io/2018/11/07/Lost%20Array/"/>
    <id>https://amannix.github.io/2018/11/07/Lost Array/</id>
    <published>2018-11-07T09:33:21.000Z</published>
    <updated>2018-11-07T10:22:52.627Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1043/problem/B" target="_blank" rel="noopener">Codeforces Round 519 B.Lost Array</a><br><strong>Description</strong><br><div class="note default"><p>Bajtek, known for his unusual gifts, recently got an integer array x0,x1,…,xk−1.</p><p>Unfortunately, after a huge array-party with his extraordinary friends, he realized that he’d lost it. After hours spent on searching for a new toy, Bajtek found on the arrays producer’s website another array a of length n+1. As a formal description of a says, a0=0 and for all other i (1≤i≤n) ai=x(i−1)modk+ai−1, where p mod q denotes the remainder of division p by q.</p><p>For example, if the x=[1,2,3] and n=5, then:<br>a0=0,<br>a1=x0mod3+a0=x0+0=1,<br>a2=x1mod3+a1=x1+1=3,<br>a3=x2mod3+a2=x2+3=6,<br>a4=x3mod3+a3=x0+6=7,<br>a5=x4mod3+a4=x1+7=9.<br>So, if the x=[1,2,3] and n=5, then a=[0,1,3,6,7,9].</p><p>Now the boy hopes that he will be able to restore x from aa! Knowing that 1≤k≤n, help him and find all possible values of k — possible lengths of the lost array.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>输入数据有多组。<br>The first line contains exactly one integer nn (1≤n≤1000) — the length of the array aa, excluding the element a0.</p><p>The second line contains nn integers a1,a2,…,an (1≤ai≤10^6).</p><p>Note that a0 is always 0 and is not given in the input.</p></div><br><strong>Output</strong><br><div class="note default"><p>The first line of the output should contain one integer ll denoting the number of correct lengths of the lost array.</p><p>The second line of the output should contain ll integers — possible lengths of the lost array in increasing order.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>1 2 3 4 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>5<br>1 2 3 4 5</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>5<br>1 3 5 6 8</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2<br>3 5</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>3<br>1 5 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1<br>3  </p></blockquote><p><strong>Thinking</strong><br>说的是有一个数列，这个数列a，同时有一个配套的数列x，x的代表了a数列在之间两两之差，求多长的数组x可以满足a[i]=a[i-1]+x[(i-1)%k].求k可能的值，按从小到大输出。先预处理a数列的两项之差，然后枚举k的值，对每一个k。我们去模拟是否是符合条件的。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,buf[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125;,val[<span class="number">10000</span>],ans[<span class="number">1005</span>],t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;buf[i]);</span><br><span class="line">        val[i<span class="number">-1</span>] = buf[i] - buf[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (buf[j]-buf[j<span class="number">-1</span>] != val[index])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            index %= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            ans[t++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,ans[i],i==t ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1043/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round 519 B.Lost Array&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Bajtek, known for his unusual gifts, recently got an integer array x0,x1,…,xk−1.&lt;/p&gt;
&lt;p&gt;Unfortunately, after a huge array-party with his extraordinary friends, he realized that he’d lost it. After hours spent on searching for a new toy, Bajtek found on the arrays producer’s website another array a of length n+1. As a formal description of a says, a0=0 and for all other i (1≤i≤n) ai=x(i−1)modk+ai−1, where p mod q denotes the remainder of division p by q.&lt;/p&gt;
&lt;p&gt;For example, if the x=[1,2,3] and n=5, then:&lt;br&gt;a0=0,&lt;br&gt;a1=x0mod3+a0=x0+0=1,&lt;br&gt;a2=x1mod3+a1=x1+1=3,&lt;br&gt;a3=x2mod3+a2=x2+3=6,&lt;br&gt;a4=x3mod3+a3=x0+6=7,&lt;br&gt;a5=x4mod3+a4=x1+7=9.&lt;br&gt;So, if the x=[1,2,3] and n=5, then a=[0,1,3,6,7,9].&lt;/p&gt;
&lt;p&gt;Now the boy hopes that he will be able to restore x from aa! Knowing that 1≤k≤n, help him and find all possible values of k — possible lengths of the lost array.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="模拟" scheme="https://amannix.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>UVA-11988 Broken Keyboard(数组模拟链表)</title>
    <link href="https://amannix.github.io/2018/10/27/UVA-11988/"/>
    <id>https://amannix.github.io/2018/10/27/UVA-11988/</id>
    <published>2018-10-27T05:35:02.000Z</published>
    <updated>2018-10-27T06:05:49.174Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-11988" target="_blank" rel="noopener">UVA-11988 Broken Keyboard</a><br><strong>Description</strong><br><div class="note default"><p>WJL同学的键盘出现了奇妙的故障，所有键都会正常的工作，但是键盘上的Home以及End键有时候会莫名其妙的自己按下。但是盲打很熟练的他一般习惯关闭显示器打字，因为这样很酷。<br>现在他正在打一段文本，假设你已经知道这段文本以及Home和End键会什么时候出现故障自行按下。请你编写一个程序，求出他最后打出的文本。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>输入数据有多组。<br>每组数据在一行内包含了至多100000个字母、下划线和两个特别的标点’[‘以及’]’，其中’[‘代表输入到此时”Home”键会被按下。而’]’则代表输入到此时”End”键会被按下。<br>输入数据以EOF作为结束，并且我们保证输入数据的大小不超过5MB。</p></div><br><strong>Output</strong><br><div class="note default"><p>对于每组数据，请在一行之内输出最后他打出的文本是怎样的。</p></div><br><strong>Sample Input</strong></p><blockquote><p>This_is_a_[Sample]_text<br>[[]][][]Nihao_I_am_a_Sample_Input<br>This_pr[oblem_has_a_100]0[m]s_time_limit<br>Maybe_theres_no_bracket  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>SampleThis_is_a__text<br>Nihao_I_am_a_Sample_Input<br>moblem_has_a_100This_pr0s_time_limit<br>Maybe_theres_no_bracket  </p></blockquote><p><strong>Thinking</strong><br>紫书例四，一个链表的做法，看的答案用了数组模拟链表。再次惊叹刘大爷的代码妙不可言（很难看的懂）<br>我就只能勉强解释一下cur变量的作用。这个变量老是变来变去的贼奇怪，也特别难理解。这里主要是用cur指向链表接下来该插入的位置（不一定是最后）这个链表由于借助数组所以寻址的过程也比较抽象（巨抽象）。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;nodetable[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> next[<span class="number">100010</span>] = &#123;<span class="number">0</span>&#125;,cur = <span class="number">0</span>,end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*将屏幕上要出现的最终的字符串理解为一个链表生成的过程</span></span><br><span class="line"><span class="comment">          cur链表指针，也可以理解为光标</span></span><br><span class="line"><span class="comment">          end记录链表尾部。</span></span><br><span class="line"><span class="comment">          next[0]必须等于0，初始化首部指针指向NULL*/</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">                cur = <span class="number">0</span>;<span class="comment">//回到首部</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">']'</span>)&#123;</span><br><span class="line">                cur = end;<span class="comment">//回到链表尾部</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                next[i] = next[cur];</span><br><span class="line">                next[cur] = i;<span class="comment">//无论如何光标指向的一定是当前枚举到的i.</span></span><br><span class="line">                <span class="keyword">if</span> (cur == end)<span class="comment">//当光标指向尾部的时候才更新链表尾部地址</span></span><br><span class="line">                    end = i;</span><br><span class="line">                cur = next[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>,cur,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = next[<span class="number">0</span>];i != <span class="number">0</span>; i=next[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%c"</span>,str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-11988&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UVA-11988 Broken Keyboard&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;WJL同学的键盘出现了奇妙的故障，所有键都会正常的工作，但是键盘上的Home以及End键有时候会莫名其妙的自己按下。但是盲打很熟练的他一般习惯关闭显示器打字，因为这样很酷。&lt;br&gt;现在他正在打一段文本，假设你已经知道这段文本以及Home和End键会什么时候出现故障自行按下。请你编写一个程序，求出他最后打出的文本。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-442 Matrix Chain Multiplication(表达式值)</title>
    <link href="https://amannix.github.io/2018/10/26/UVA-442/"/>
    <id>https://amannix.github.io/2018/10/26/UVA-442/</id>
    <published>2018-10-26T07:44:52.000Z</published>
    <updated>2018-10-26T07:57:19.089Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-442" target="_blank" rel="noopener">Matrix Chain Multiplication</a><br><strong>Description</strong><br><div class="note default"><p>Suppose you have to evaluate an expression like ABCDE where A,B,C,D and E are matrices.<br>Since matrix multiplication is associative, the order in which multiplications are performed is arbitrary.<br>However, the number of elementary multiplications needed strongly depends on the evaluation order<br>you choose.<br>For example, let A be a 5010 matrix, B a 1020 matrix and C a 205 matrix. There are two different strategies to compute ABC, namely (AB)C and A(B*C).<br>The first one takes 15000 elementary multiplications, but the second one only 3500.<br>Your job is to write a program that determines the number of elementary multiplications needed<br>for a given evaluation strategy.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>Input consists of two parts: a list of matrices and a list of expressions.<br>The first line of the input file contains one integer n (1 ≤ n ≤ 26), representing the number of<br>matrices in the first part. The next n lines each contain one capital letter, specifying the name of the<br>matrix, and two integers, specifying the number of rows and columns of the matrix.<br>The second part of the input file strictly adheres to the following syntax (given in EBNF):<br>SecondPart = Line { Line }<br>Line = Expression<br>Expression = Matrix | “(“ Expression Expression “)”<br>Matrix = “A” | “B” | “C” | … | “X” | “Y” | “Z”</p></div><br><strong>Output</strong><br><div class="note default"><p>For each expression found in the second part of the input file, print one line containing the word ‘error’<br>if evaluation of the expression leads to an error due to non-matching matrices. Otherwise print one<br>line containing the number of elementary multiplications needed to evaluate the expression in the way<br>specified by the parentheses.</p></div><br><strong>Sample Input</strong></p><blockquote><p>9<br>A 50 10<br>B 10 20<br>C 20 5<br>D 30 35<br>E 35 15<br>F 15 5<br>G 5 10<br>H 10 20<br>I 20 25<br>A<br>B<br>C<br>(AA)<br>(AB)<br>(AC)<br>(A(BC))<br>((AB)C)<br>(((((DE)F)G)H)I)<br>(D(E(F(G(HI)))))<br>((D(EF))((GH)I))</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0<br>0<br>0<br>error<br>10000<br>error<br>3500<br>15000<br>40500<br>47500<br>15125</p></blockquote><p><strong>Thinking</strong><br>紫书第六章例三，经典的堆栈模拟求表达式。很早就知道解法，但是一直没真正做过。输入n个矩阵的维度和一些矩阵链乘表达式，输出乘法次数。如果乘法无法进行则输出error。假定A是m<em>n的矩阵，B是n</em>p的矩阵，那么A<em>B等于m</em>p，且乘法次数等于n<em>m</em>p，如果A的列不等于B的行，则乘法无法进行。先将字符串遍历，遇到’(‘跳过遇到’)’就将栈中取出两个元素做乘法，并且计算乘法次数。然后将新的矩阵再次入栈，知道最后栈为空。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">&#125;buf[<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;node&gt; sta;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    getchar ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; ++i)&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%c "</span>,&amp;ch);</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;buf[ch-<span class="string">'A'</span>].a,&amp;buf[ch-<span class="string">'A'</span>].b);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="comment">//printf ("%d %d\n",buf[ch-'A'].a,buf[ch-'A'].b);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100100</span>];</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str+<span class="number">1</span>),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> error = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!sta.empty())    sta.pop();<span class="comment">//清空栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'('</span>)    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                node a,b;</span><br><span class="line">                a = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                <span class="keyword">if</span> (sta.empty())&#123;<span class="comment">//取第二个元素应该确保栈不为空并且栈中取出的元素应该交换位置</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                <span class="comment">//printf ("%d %d %d %d\n",a.a,a.b,b.a,b.b);</span></span><br><span class="line">                <span class="keyword">if</span> (a.a != b.b)&#123;<span class="comment">//不满足矩阵相乘条件</span></span><br><span class="line">                    error = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += (a.a*a.b*b.a);</span><br><span class="line">                    b.b = a.b;</span><br><span class="line">                    sta.push(b);<span class="comment">//将新矩阵入栈</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sta.push(buf[str[i]-<span class="string">'A'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (error)    <span class="built_in">printf</span> (<span class="string">"error\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-442&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Matrix Chain Multiplication&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Suppose you have to evaluate an expression like ABCDE where A,B,C,D and E are matrices.&lt;br&gt;Since matrix multiplication is associative, the order in which multiplications are performed is arbitrary.&lt;br&gt;However, the number of elementary multiplications needed strongly depends on the evaluation order&lt;br&gt;you choose.&lt;br&gt;For example, let A be a 5010 matrix, B a 1020 matrix and C a 205 matrix. There are two different strategies to compute ABC, namely (AB)C and A(B*C).&lt;br&gt;The first one takes 15000 elementary multiplications, but the second one only 3500.&lt;br&gt;Your job is to write a program that determines the number of elementary multiplications needed&lt;br&gt;for a given evaluation strategy.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 53 D-Berland Fair(模拟)</title>
    <link href="https://amannix.github.io/2018/10/26/Berland%20Fair/"/>
    <id>https://amannix.github.io/2018/10/26/Berland Fair/</id>
    <published>2018-10-26T07:14:28.000Z</published>
    <updated>2018-10-26T07:58:46.964Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1073/problem/D" target="_blank" rel="noopener">D.Berland Fair</a><br><strong>Description</strong><br><div class="note default"><p>XXI Berland Annual Fair is coming really soon! Traditionally fair consists of n booths, arranged in a circle. The booths are numbered 1 through n clockwise with n being adjacent to 1. The i-th booths sells some candies for the price of ai burles per item. Each booth has an unlimited supply of candies.<br>Polycarp has decided to spend at most T burles at the fair. However, he has some plan in mind for his path across the booths:</p><ol><li>at first, he visits booth number 1;</li><li>f he has enough burles to buy exactly one candy from the current booth, then he buys it immediately;</li><li>then he proceeds to the next booth in the clockwise order (regardless of if he bought a candy or not).<br>Polycarp’s money is finite, thus the process will end once he can no longer buy candy at any booth.<br>Calculate the number of candies Polycarp will buy.</li></ol></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains two integers n and T(1&lt;=n&lt;=2*10^5,1&lt;=T&lt;=10^18) — the number of booths at the fair and the initial amount of burles Polycarp has.<br>The second line contains n integers a1,a2…an (1&lt;ai&lt;10^9) — the price of the single candy at booth number i.</p></div><br><strong>Output</strong><br><div class="note default"><p>Print a single integer — the total number of candies Polycarp will buy.</p></div><br><strong>Sample Input</strong></p><blockquote><p>3 38<br>5 2 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>10</p></blockquote><p><strong>Thinking</strong><br>就是说一个循环链表，在链表中有N个摊位，每个摊位出售价格为ai的糖果。现在XXI手上有T元钱，从起点开始循环遍历，每遇到一个摊位如果钱足够的话就买下一颗糖，不够就去下一个摊位，重复循环知道他再也买不到糖为止。求这时买了多少颗糖。简单的循环模拟肯定T，因此可以先求出手上的钱单次循环足够买多少颗糖果。记录糖果数量X和花费Y，然后直接取余取整计算在一次遍历需要花费Y的情况下最多能遍历几次，即：T/Y*X就是还能买这么多次糖果，而剩余的钱就是T%Y。但是注意假设剩余M块钱，这里M块钱肯定不够一次遍历要花费Y元，必须重新计算在余钱M的情况下，单次遍历所花费的钱以及买的糖果数。因此要外加一个大循环，控制条件为剩余的钱一颗糖都买不起为止。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll buf[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,sum = <span class="number">0</span>,cand_sum = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        sum = cand_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + buf[i] &lt;= m)&#123;</span><br><span class="line">                sum += buf[i];<span class="comment">//记录一次遍历的花费</span></span><br><span class="line">                ++cand_sum;<span class="comment">//记录一次遍历买的糖果数量</span></span><br><span class="line">                flag = <span class="literal">false</span>;<span class="comment">//记录是否再也买不了了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        ans += m/sum*cand_sum;<span class="comment">//直接计算出N次遍历最多可以买多少糖果</span></span><br><span class="line">        m = m%sum;<span class="comment">//计算出N次遍历还剩多少钱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1073/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;D.Berland Fair&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;XXI Berland Annual Fair is coming really soon! Traditionally fair consists of n booths, arranged in a circle. The booths are numbered 1 through n clockwise with n being adjacent to 1. The i-th booths sells some candies for the price of ai burles per item. Each booth has an unlimited supply of candies.&lt;br&gt;Polycarp has decided to spend at most T burles at the fair. However, he has some plan in mind for his path across the booths:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;at first, he visits booth number 1;&lt;/li&gt;
&lt;li&gt;f he has enough burles to buy exactly one candy from the current booth, then he buys it immediately;&lt;/li&gt;
&lt;li&gt;then he proceeds to the next booth in the clockwise order (regardless of if he bought a candy or not).&lt;br&gt;Polycarp’s money is finite, thus the process will end once he can no longer buy candy at any booth.&lt;br&gt;Calculate the number of candies Polycarp will buy.&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="模拟" scheme="https://amannix.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 53 B-Vasya and Books(栈)</title>
    <link href="https://amannix.github.io/2018/10/26/Vasya%20and%20Books/"/>
    <id>https://amannix.github.io/2018/10/26/Vasya and Books/</id>
    <published>2018-10-26T06:52:14.000Z</published>
    <updated>2018-10-26T07:58:45.904Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1073/problem/B" target="_blank" rel="noopener">B. Vasya and Books</a><br><strong>Description</strong><br><div class="note default"><p>Vasya has got nn books, numbered from 11 to nn, arranged in a stack. The topmost book has number a1a1, the next one — a2a2, and so on. The book at the bottom of the stack has number anan. All numbers are distinct.</p><p>Vasya wants to move all the books to his backpack in nn steps. During ii-th step he wants to move the book number bibi into his backpack. If the book with number bibi is in the stack, he takes this book and all the books above the book bibi, and puts them into the backpack; otherwise he does nothing and begins the next step. For example, if books are arranged in the order [1,2,3][1,2,3] (book 11 is the topmost), and Vasya moves the books in the order [2,1,3][2,1,3], then during the first step he will move two books (11 and 22), during the second step he will do nothing (since book 11 is already in the backpack), and during the third step — one book (the book number 33). Note that b1,b2,…,bnb1,b2,…,bn are distinct.</p><p>Help Vasya! Tell him the number of books he will put into his backpack during each step.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains one integer n (1≤n≤2⋅105)n (1≤n≤2⋅105) — the number of books in the stack.<br>The second line contains nn integers a1,a2,…,an (1≤ai≤n)a1,a2,…,an (1≤ai≤n) denoting the stack of books.<br>The third line contains nn integers b1,b2,…,bn (1≤bi≤n)b1,b2,…,bn (1≤bi≤n) denoting the steps Vasya is going to perform.<br>All numbers a1…ana1…an are distinct, the same goes for b1…bnb1…bn.</p></div><br><strong>Output</strong><br><div class="note default"><p>Print nn integers. The ii-th of them should be equal to the number of books Vasya moves to his backpack during the ii-th step.</p></div><br><strong>Sample Input</strong></p><blockquote><p>3<br>1 2 3<br>2 1 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2 0 1</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>5<br>3 1 4 2 5<br>4 5 1 3 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>3 2 0 0 0</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>6<br>6 5 4 3 2 1<br>6 5 3 4 2 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 1 2 0 1 1</p></blockquote><p><strong>Thinking</strong><br>题意是说有一堆书，给出这堆书的编号。然后按照某种顺序取书，假定取n号书，那么此时是将这个堆中n号及n号以前的所有书全部拿走。如果当前要取的书以及被拿走了，那么就什么都不做，现在问，每次拿书的操作一次会被拿走多少本书。所以我们可以按照给定的顺序用一个队列存放书的编号，为了快速查找对应编号所在队列位置可以建立哈希表以实现快速查找。接下来便是依次读取取书顺序，并且找到这本书在队列中的第几位，假设为K，然后直接K减去队首位置+1便是当前一次取到的书的本数。然后依次出队直到队首指针指向K为止。然后就继续读取操作。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,top = <span class="number">1</span>,t;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        hash[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="comment">//printf ("%d %d\n",top,hash[k]);</span></span><br><span class="line">        <span class="keyword">if</span> (hash[k]-top &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,hash[k]-top+<span class="number">1</span>,i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">            top = hash[k]+<span class="number">1</span>;<span class="comment">//改变队首指针的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,<span class="number">0</span>,i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);<span class="comment">//一本书也不取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1073/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B. Vasya and Books&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Vasya has got nn books, numbered from 11 to nn, arranged in a stack. The topmost book has number a1a1, the next one — a2a2, and so on. The book at the bottom of the stack has number anan. All numbers are distinct.&lt;/p&gt;
&lt;p&gt;Vasya wants to move all the books to his backpack in nn steps. During ii-th step he wants to move the book number bibi into his backpack. If the book with number bibi is in the stack, he takes this book and all the books above the book bibi, and puts them into the backpack; otherwise he does nothing and begins the next step. For example, if books are arranged in the order [1,2,3][1,2,3] (book 11 is the topmost), and Vasya moves the books in the order [2,1,3][2,1,3], then during the first step he will move two books (11 and 22), during the second step he will do nothing (since book 11 is already in the backpack), and during the third step — one book (the book number 33). Note that b1,b2,…,bnb1,b2,…,bn are distinct.&lt;/p&gt;
&lt;p&gt;Help Vasya! Tell him the number of books he will put into his backpack during each step.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-514 Rails (栈)</title>
    <link href="https://amannix.github.io/2018/10/26/UVA-514/"/>
    <id>https://amannix.github.io/2018/10/26/UVA-514/</id>
    <published>2018-10-26T06:02:38.000Z</published>
    <updated>2018-10-26T07:57:52.147Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-514" target="_blank" rel="noopener">UVA-514 Rails</a></p><p><strong>Description</strong><br><div class="note default"><p>PopPush城市有一座著名的火车站。这个国家到处都是丘陵。而这个火车站是建于上一个世纪。不幸的是，那时的资金有限。所以只能建立起一条路面铁轨。而且，这导致这个火车站在同一个时刻只能一个轨道投入使用，因为它缺少空间，两列火车将无路可走。具体看下图。<br><img src="http://images.cppblog.com/cppblog_com/sixleaves/uva514.png" alt=""><br>当地的惯例是每一列火车从A方向驶向B方向时候，会用某种方式将车厢重组。假设火车将要到达A方向，拥有N个车厢(N&lt;=1000),这些车厢按照递增顺序标记为1到N。负责从组车厢的领导,必须知道是否能从组车厢让它驶出B，而这个重组的序列就是a1\a2\a3…aN.帮组他并且写一个程序来判断是否可能按照所要求的车厢顺序。你可以假设，单个的车厢可以从列车上分离出来，在他们进入站台之前。并且他们可以自由移动，知道它们上了B轨道。你也可以假设在任意时候站台可以放下无数的车厢。但是只要一个车厢进入站台，它就不能返回A轨道，同时如果它离开了站台驶向B轨道，它就不能返回站台。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>这个输入文件由多个行块组成。每一个块描述的是多个要求的重组车厢的序列。在这每个块中的第一行是一个整数N，被用来说明上面每行的车厢个数。这个快的最后一行仅仅是一个数字0要来标记该快的结束<br>最后一个块仅仅是一个0独占一行。</p></div><br><strong>Output</strong><br><div class="note default"><p>这个输出文件包含多行，这些行和排列车厢的行数一一对应。日过该排列可行，则输出Yes，否则输出No。另外存在一个空行在每个相对应的块后面。输出文件中不存在于最后一个什么数据都没有的响应输出。</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>1 2 3 4 5<br>5 4 1 2 3<br>0<br>6<br>6 5 4 3 2 1<br>0<br>0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Yes<br>No<br>Yes  </p></blockquote><p><strong>Thinking</strong><br>紫书上第六章的例二。一个关于栈的模拟，光看的话感觉挺简单，但是一做起来还是不少麻烦。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sta_clear</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span>* top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!sta.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (num[*top] != sta.top())&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sta.pop();</span><br><span class="line">            ++*top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t) &amp;&amp; t != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> num[<span class="number">10000</span>] = &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">while</span> (!sta.empty())    sta.pop();<span class="comment">//清空栈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;num[<span class="number">1</span>]!=<span class="number">0</span> &amp;&amp; i &lt;= t; ++i)&#123;</span><br><span class="line">                <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num[i]);<span class="comment">//读取出站队列</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[<span class="number">1</span>] == <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num[top] == i)&#123;<span class="comment">//当进入站点的火车与出站队列首部相等时，出队</span></span><br><span class="line">                    ++top;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sta.size() &amp;&amp; num[top] == sta.top())&#123;</span><br><span class="line">                    sta_clear(num,&amp;top);<span class="comment">//当队首和栈顶元素相等时，必须得从栈顶开始向下遍历弹出</span></span><br><span class="line">                    sta.push(i);<span class="comment">//必须等遍历弹出结束之后再入栈。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    sta.push(i);<span class="comment">//队首元素无法匹配</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sta_clear(num,&amp;top);<span class="comment">//再次从栈顶出发向下匹配</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%s\n"</span>,sta.empty() ? <span class="string">"Yes"</span>:<span class="string">"No"</span>);<span class="comment">//栈为空则完全匹配成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-514&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UVA-514 Rails&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;PopPush城市有一座著名的火车站。这个国家到处都是丘陵。而这个火车站是建于上一个世纪。不幸的是，那时的资金有限。所以只能建立起一条路面铁轨。而且，这导致这个火车站在同一个时刻只能一个轨道投入使用，因为它缺少空间，两列火车将无路可走。具体看下图。&lt;br&gt;&lt;img src=&quot;http://images.cppblog.com/cppblog_com/sixleaves/uva514.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;当地的惯例是每一列火车从A方向驶向B方向时候，会用某种方式将车厢重组。假设火车将要到达A方向，拥有N个车厢(N&amp;lt;=1000),这些车厢按照递增顺序标记为1到N。负责从组车厢的领导,必须知道是否能从组车厢让它驶出B，而这个重组的序列就是a1\a2\a3…aN.帮组他并且写一个程序来判断是否可能按照所要求的车厢顺序。你可以假设，单个的车厢可以从列车上分离出来，在他们进入站台之前。并且他们可以自由移动，知道它们上了B轨道。你也可以假设在任意时候站台可以放下无数的车厢。但是只要一个车厢进入站台，它就不能返回A轨道，同时如果它离开了站台驶向B轨道，它就不能返回站台。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>牛客国庆集训派对Day1-L New Game! (几何建图+最短路径)</title>
    <link href="https://amannix.github.io/2018/10/24/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day1-L/"/>
    <id>https://amannix.github.io/2018/10/24/牛客国庆集训派对Day1-L/</id>
    <published>2018-10-23T16:02:05.000Z</published>
    <updated>2018-10-23T16:12:16.383Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.nowcoder.com/acm/contest/201/L" target="_blank" rel="noopener">牛客国庆集训派对Day1-L New Game!</a><br><strong>Description</strong><br><div class="note default"><p>Eagle Jump公司正在开发一款新的游戏。Hifumi Takimoto作为其中的员工，获得了提前试玩的机会。现在她正在试图通过一个迷宫。<br>这个迷宫有一些特点。为了方便描述，我们对这个迷宫建立平面直角坐标系。迷宫中有两条平行直线 L1:Ax+By+C1=0, L2:Ax+By+C2=0，还有 n 个圆 。角色在直线上、圆上、园内行走不消耗体力。在其他位置上由S点走到T点消耗的体力为S和T的欧几里得距离。<br>Hifumi Takimoto想从 L1 出发，走到 L2 。请计算最少需要多少体力。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>第一行五个正整数 n,A,B,C1,C2 (1≤ n ≤ 1000, -10000 ≤ A,B,C1,C2 ≤ 10000)，其中 A,B 不同时为 0。<br>接下来 n 行每行三个整数 x,y,r(-10000 ≤ x,y ≤ 10000, 1≤ r ≤ 10000) 表示一个圆心为 (x,y)，半径为 r 的圆。</p></div><br><strong>Output</strong><br><div class="note default"><p>仅一行一个实数表示答案。与正确结果的绝对误差或者相对误差不超过 10^-4 即算正确。</p></div><br><strong>Sample Input</strong></p><blockquote><p>2 0 1 0 -4<br>0 1 1<br>1 3 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0.236068</p></blockquote><p><strong>Thinking</strong><br>相当有趣的图论题，乍一看以为是集合题，瞎想了好久。发现是图论，但是最后建图还是有错。正解建图应该是把所有的圆和直线都看做点，这样就是n+2个点直接两两枚举求出欧式距离即可。只是需要特判到底是求圆与圆之间的距离还是线到圆的距离而已，反正这样建图之后就是裸的最短路算法。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> maxn = <span class="number">0xffffffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> A,B,C;</span><br><span class="line">&#125;a,b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y,r,dis;</span><br><span class="line">&#125;coor[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Line_dis,ans = maxn;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node a,Node b)</span><span class="comment">//计算两圆之间的最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp_dis = <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)) - a.r - b.r;</span><br><span class="line"><span class="keyword">return</span> temp_dis &gt; <span class="number">0</span> ? temp_dis : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ans_dis</span><span class="params">(Node a,Line b)</span><span class="comment">//计算圆到直线的最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp_dis = <span class="built_in">fabs</span>(a.x*b.A+a.y*b.B+b.C)/<span class="built_in">sqrt</span>(b.A*b.A+b.B*b.B) - a.r;</span><br><span class="line"><span class="keyword">return</span> temp_dis &gt; <span class="number">0</span> ? temp_dis : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> book[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> _dis[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">2</span>; ++i)&#123;</span><br><span class="line">_dis[i] = coor[n+<span class="number">1</span>][i].dis;</span><br><span class="line">&#125;</span><br><span class="line">_dis[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">book[n+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n+<span class="number">2</span>; i++)&#123;</span><br><span class="line"><span class="keyword">double</span> min = maxn;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; _dis[j] &amp;&amp; !book[j])&#123;</span><br><span class="line">min = _dis[j];</span><br><span class="line">total = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[total] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span> ;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!book[j] &amp;&amp; _dis[j] &gt; coor[total][j].dis + _dis[total])&#123;</span><br><span class="line">_dis[j] = coor[total][j].dis + _dis[total];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _dis[n+<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">2</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span>; ++j)&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lf "</span>,coor[i][j].dis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//读取数据并且建立无向图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%lf%lf%lf%lf"</span>,&amp;n,&amp;a.A,&amp;a.B,&amp;a.C,&amp;b.C);</span><br><span class="line">b.A = a.A;</span><br><span class="line">b.B = a.B;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">2</span>; ++i)&#123;<span class="comment">//Init</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span>; ++j)&#123;</span><br><span class="line">coor[i][j].dis = coor[j][i].dis = maxn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line_dis = <span class="built_in">fabs</span>(a.C-b.C)/<span class="built_in">sqrt</span>(a.A*a.A+a.B*a.B);</span><br><span class="line">coor[n+<span class="number">2</span>][n+<span class="number">1</span>].dis = coor[n+<span class="number">1</span>][n+<span class="number">2</span>].dis = Line_dis;<span class="comment">//把两条直线放在最后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf%lf%lf"</span>,&amp;coor[i][i].x,&amp;coor[i][i].y,&amp;coor[i][i].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;<span class="comment">//先循环枚举求圆之间的距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= n; ++j)&#123;<span class="comment">//我他妈枚举变量写错了</span></span><br><span class="line">coor[j][i].dis = coor[i][j].dis = dis(coor[i][i],coor[j][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;<span class="comment">//枚举求两直线到所有圆之间的距离。</span></span><br><span class="line">coor[i][n+<span class="number">1</span>].dis = coor[n+<span class="number">1</span>][i].dis = ans_dis(coor[i][i],a);</span><br><span class="line">coor[i][n+<span class="number">2</span>].dis = coor[n+<span class="number">2</span>][i].dis = ans_dis(coor[i][i],b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init();</span><br><span class="line">ans = Dijkstra();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lf\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">work();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/201/L&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客国庆集训派对Day1-L New Game!&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Eagle Jump公司正在开发一款新的游戏。Hifumi Takimoto作为其中的员工，获得了提前试玩的机会。现在她正在试图通过一个迷宫。&lt;br&gt;这个迷宫有一些特点。为了方便描述，我们对这个迷宫建立平面直角坐标系。迷宫中有两条平行直线 L1:Ax+By+C1=0, L2:Ax+By+C2=0，还有 n 个圆 。角色在直线上、圆上、园内行走不消耗体力。在其他位置上由S点走到T点消耗的体力为S和T的欧几里得距离。&lt;br&gt;Hifumi Takimoto想从 L1 出发，走到 L2 。请计算最少需要多少体力。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="https://amannix.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>牛客国庆集训派对Day1-J(栈的操作)</title>
    <link href="https://amannix.github.io/2018/10/23/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day1-J/"/>
    <id>https://amannix.github.io/2018/10/23/牛客国庆集训派对Day1-J/</id>
    <published>2018-10-23T15:42:53.000Z</published>
    <updated>2018-10-23T16:01:40.230Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.nowcoder.com/acm/contest/201/J" target="_blank" rel="noopener">牛客国庆集训派对Day1-J Princess Principal</a><br><strong>Description</strong><br><div class="note default"><p>阿尔比恩王国（the Albion Kingdom）潜伏着一群代号“白鸽队（Team White Pigeon）”的间谍。在没有任务的时候，她们会进行各种各样的训练，比如快速判断一个文档有没有语法错误，这有助于她们鉴别写文档的人受教育程度。<br>这次用于训练的是一个含有n个括号的文档。括号一共有m种，每种括号都有左括号和右括号两种形式。我们定义用如下的方式定义一个合法的文档:<br>1.一个空的字符串是一个合法的文档。<br>2.如果A,B都是合法的文档，那么AB也是合法的文档。<br>3.如果S是合法的文档，那么aSb也是合法的文档，其中a,b是同一种括号，并且a是左括号，b是右括号。<br>现在给出q个询问，每次询问只考虑文档第l至r个字符的情况下，文档是不是合法的。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>第一行两个整数n,m,q(1 ≤ n,m,q ≤ 10^6)。<br>第二行有n个空格隔开的整数x，第i个整数xi(0 ≤ xi &lt; m*2)代表文档中的第i个字符是第x/2种括号。另外，如果xi是偶数，它代表一个左括号，否则它代表一个右括号。<br>接下来q行，每行两个空格隔开的整数l,r(1 ≤ l ≤ r ≤ n)，代表询问第l至r个字符构成的字符串是否是一个合法的文档。</p></div><br><strong>Output</strong><br><div class="note default"><p>输出共q行，如果询问的字符串是一个合法的文档，输出”Yes”,否则输出”No”。</p></div><br><strong>Sample Input</strong></p><blockquote><p>6 4 3<br>0 2 3 1 4 7<br>1 4<br>1 5<br>5 6</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Yes<br>No<br>No</p></blockquote><p><strong>Thinking</strong><br>十分经典的合法字符串判定的题目了，就是遍历字符串，然后对于每一个字符，如果栈空就入栈，否则判断当前字符和栈顶元素是否匹配，匹配则出栈，否则入栈。在次期间，每判断一次就要vis[]记录第i个位置的栈顶数据。栈中的数据同样也是字符串下标。最后判断的时候查表，vis[l] == vis[r]. 但是有个问题就是由于当a[j]和栈顶两个元素相等的时候，直接是出栈操作，所以vis[j]是直接等于与a[j]匹配的栈顶元素的后一个元素。因此这里比较的应该是vis[l-1] == vis[r]才对。不清楚的也可以在预处理结束的时候打印vis数组看看每次记录的栈顶元素是什么。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000010</span>],vis[<span class="number">1000010</span>],sta[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q,end = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (end == <span class="number">0</span>)&#123;</span><br><span class="line">sta[++end] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[sta[end]]/<span class="number">2</span> == a[i]/<span class="number">2</span> &amp;&amp; a[sta[end]]+<span class="number">1</span> == a[i])&#123;</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">sta[++end] = i;</span><br><span class="line">&#125;</span><br><span class="line">vis[i] = sta[end];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*for (int i = 1;i &lt;= n; ++i)&#123;//debug</span></span><br><span class="line"><span class="comment">printf ("%d ",vis[i]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf ("\n");*/</span></span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span> (vis[l<span class="number">-1</span>] == vis[r])&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Yes\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/201/J&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客国庆集训派对Day1-J Princess Principal&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;阿尔比恩王国（the Albion Kingdom）潜伏着一群代号“白鸽队（Team White Pigeon）”的间谍。在没有任务的时候，她们会进行各种各样的训练，比如快速判断一个文档有没有语法错误，这有助于她们鉴别写文档的人受教育程度。&lt;br&gt;这次用于训练的是一个含有n个括号的文档。括号一共有m种，每种括号都有左括号和右括号两种形式。我们定义用如下的方式定义一个合法的文档:&lt;br&gt;1.一个空的字符串是一个合法的文档。&lt;br&gt;2.如果A,B都是合法的文档，那么AB也是合法的文档。&lt;br&gt;3.如果S是合法的文档，那么aSb也是合法的文档，其中a,b是同一种括号，并且a是左括号，b是右括号。&lt;br&gt;现在给出q个询问，每次询问只考虑文档第l至r个字符的情况下，文档是不是合法的。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>牛客国庆集训派对Day1-C Utawarerumono（思维、枚举）</title>
    <link href="https://amannix.github.io/2018/10/23/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day1-C/"/>
    <id>https://amannix.github.io/2018/10/23/牛客国庆集训派对Day1-C/</id>
    <published>2018-10-23T08:07:31.000Z</published>
    <updated>2018-10-23T15:37:00.877Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.nowcoder.com/acm/contest/201/C" target="_blank" rel="noopener">牛客国庆集训派对Day1-C Utawarerumono</a><br><strong>Description</strong><br><div class="note default"><p>算术是为数不多的会让Kuon感到棘手的事情。通常她会找Haku帮忙，但是Haku已经被她派去买东西了。于是她向你寻求帮助。<br>给出一个关于变量x,y的不定方程ax+by=c，显然这个方程可能有多个整数解。Kuon想知道如果有解，使得p2<em>x^2+p1</em>x+q2<em>y^2+q1</em>y最小的一组整数解是什么。为了方便，你只需要输出p2<em>x^2+p1</em>x+q2<em>y^2+q1</em>y的最小值。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>第一行三个空格隔开的整数a,b,c(0 ≤ a,b,c≤ 10^5)。<br>第二行两个空格隔开的整数p1,p2(1 ≤ p1,p2 ≤ 10^5)。<br>第三行两个空格隔开的整数q1,q2(1 ≤ q1,q2 ≤ 10^5)。</p></div><br><strong>Output</strong><br><div class="note default"><p>如果方程无整数解，输出“Kuon”。<br>如果有整数解，输出p2<em>x^2+p1</em>x+q2<em>y^2+q1</em>y的最小值。</p></div><br><strong>Sample Input</strong></p><blockquote><p>2 2 1<br>1 1<br>1 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Kuon</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>1 2 3<br>1 1<br>1 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>4</p></blockquote><p><strong>Thinking</strong><br>这道题咋一看是数学题，但是其实由于x和y之间存在约束关系，所以只需要枚举x的状态然后直接算出y的值就可以了。然后将枚举得到的值代入表达式，然后枚举求最大值即可</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL Max = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3fffffffffffff</span>;<span class="comment">//这个值必须足够大</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL a,b,c,p1,p2,q1,q2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%lld%lld%lld%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;p1,&amp;p2,&amp;q1,&amp;q2))&#123;</span><br><span class="line">LL ans = INF;</span><br><span class="line"><span class="keyword">for</span> (LL x = <span class="number">-2</span>*Max; x &lt;= <span class="number">2</span>*Max; ++x)&#123;</span><br><span class="line">LL y = (c-a*x)/b;</span><br><span class="line"><span class="keyword">if</span> (a*x+b*y == c)&#123;</span><br><span class="line">ans = min(p2*x*x+p1*x+q2*y*y+q1*y,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans == INF)&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Kuon\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/201/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客国庆集训派对Day1-C Utawarerumono&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;算术是为数不多的会让Kuon感到棘手的事情。通常她会找Haku帮忙，但是Haku已经被她派去买东西了。于是她向你寻求帮助。&lt;br&gt;给出一个关于变量x,y的不定方程ax+by=c，显然这个方程可能有多个整数解。Kuon想知道如果有解，使得p2&lt;em&gt;x^2+p1&lt;/em&gt;x+q2&lt;em&gt;y^2+q1&lt;/em&gt;y最小的一组整数解是什么。为了方便，你只需要输出p2&lt;em&gt;x^2+p1&lt;/em&gt;x+q2&lt;em&gt;y^2+q1&lt;/em&gt;y的最小值。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="枚举" scheme="https://amannix.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>POJ-3253 Fence Repair(哈夫曼树)</title>
    <link href="https://amannix.github.io/2018/10/18/POJ-3253/"/>
    <id>https://amannix.github.io/2018/10/18/POJ-3253/</id>
    <published>2018-10-18T11:19:31.000Z</published>
    <updated>2018-10-19T03:47:45.309Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=3253" target="_blank" rel="noopener">POJ-3253 Fence Repair</a><br><strong>Description</strong><br><div class="note default"><p>Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.</p><p>FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.</p><p>Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.</p><p>Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>Line 1: One integer N, the number of planks<br>Lines 2..N+1: Each line contains a single integer describing the length of a needed plank</p></div><br><strong>Output</strong><br><div class="note default"><p>Line 1: One integer: the minimum amount of money he must spend to make N-1 cuts</p></div><br><strong>Sample Input</strong></p><blockquote><p>3<br>8<br>5<br>8</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>34</p></blockquote><p><strong>Thinking</strong><br>题意是说要每把两个小木板合并成一个大木板，那么就需要消耗掉同等两个小木板长度的价值。现在要求最少花费多少价值可以把所有木板合并成一个大木板。比较简单的哈夫曼树的应用，但是哈夫曼树建树的过程需要不断排序，因此必须使用优先队列每次选出最短的两个木板，合成一个之后再放回队列，重复此过程直到队列只剩一为止。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;ll,<span class="built_in">vector</span>&lt;ll&gt;,greater&lt;ll&gt; &gt; que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;n))&#123;</span><br><span class="line">        ll i,j,len = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">            ll a;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;a);</span><br><span class="line">            len += a;</span><br><span class="line">            que.push(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.empty())&#123;</span><br><span class="line">            ll a = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (que.empty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ll b = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            ans += a+b;</span><br><span class="line">            que.push(a+b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=3253&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-3253 Fence Repair&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.&lt;/p&gt;
&lt;p&gt;FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.&lt;/p&gt;
&lt;p&gt;Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.&lt;/p&gt;
&lt;p&gt;Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>POJ-1840 Eqs(数学推导，简单哈希)</title>
    <link href="https://amannix.github.io/2018/10/17/POJ-1840/"/>
    <id>https://amannix.github.io/2018/10/17/POJ-1840/</id>
    <published>2018-10-17T10:46:03.000Z</published>
    <updated>2018-10-23T08:09:24.747Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=1840" target="_blank" rel="noopener">POJ-1840 Eqs</a><br><strong>Description</strong><br><div class="note default"><p>Consider equations having the following form:<br>a1<em>x1^3+ a2</em>x2^3+ a3<em>x3^3+ a4</em>x4^3+ a5*x5^3=0<br>The coefficients are given integers from the interval [-50,50].<br>It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}.</p><p>Determine how many solutions satisfy the given equation.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The only line of input contains the 5 coefficients a1, a2, a3, a4, a5, separated by blanks.</p></div><br><strong>Output</strong><br><div class="note default"><p>The output will contain on the first line the number of the solutions for the given equation.</p></div><br><strong>Sample Input</strong></p><blockquote><p>37 29 41 43 47</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>654</p></blockquote><p><strong>Thinking</strong><br>观察式子a1<em>x1^3+ a2</em>x2^3+ a3<em>x3^3+ a4</em>x4^3+ a5<em>x5^3=0。给出五个系数，然后求满足式子的五个变量解的组数。正常做法就是枚举五个变量，数据范围从-50到50.那么就是100^5.听说1ms最多执行1000条语句，1000ms就是100W按照题目给的时间必定T成狗。稍微把式子变换一下，变成 </em>-(a1<em>x1^3+ a2</em>x2^3)=a3<em>x3^3+ a4</em>x4^3+ a5<em>x5^3</em> 这样先对x1和x2暴力枚举打表。然后再枚举右边的式子，这样复杂度骤降为O(100^2+100^3)。打表的时候左边的式子有可能产生多个组合对应一个结果，所以每次离散化的时候应该是让++hash[key]，而不是生成简单的映射关系。左边式子枚举情况是50^3+50^3。这是对于正数的情况，长度12500000。那么对于负数来说使其加上25000000.映射到12500000-25000000的区间即可。对于左右两边式子的枚举到同一个键值，那么两边数量应该是乘积的关系。但是有一个坑点是：25000000的区间来说，必须对左边的式子打表，右边的式子产生的键值必须与左边相同，如果超过正负12500000的话，直接continue，因为超过左边的极限范围根本不可能产生相同的键值，处理不当反而产生冲突，本题数据非常之水，没有判断右边区间居然也能过，还有一种就是我个人认为五个变量的值只能有一次相同，在AC代码中必定会使重复的组合重复出现，比如x1=n，x2=n，那么这个组合会重复出现两次。因此我觉得还得加一次去重判断才对。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sum[<span class="number">25000001</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d,e;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span> sum);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-50</span>;i &lt;= <span class="number">50</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-50</span>;j &lt;= <span class="number">50</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> temp = (a*i*i*i + b*j*j*j)*<span class="number">-1</span>;<span class="comment">//对于25000000的hash范围来说必须是左边为负</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    temp += <span class="number">25000000</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++sum[temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-50</span>;i &lt;= <span class="number">50</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-50</span>;j &lt;= <span class="number">50</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">-50</span>;k &lt;= <span class="number">50</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (k==<span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> temp = c*i*i*i + d*j*j*j + e*k*k*k;</span><br><span class="line">                    <span class="keyword">if</span> (temp &lt; <span class="number">-12500000</span> || temp &gt; <span class="number">12500000</span>)<span class="comment">//左边的式子枚举出的范围不可能超过这个区间</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        temp += <span class="number">25000000</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (sum[temp])&#123;</span><br><span class="line">                        ans += sum[temp];<span class="comment">//组合数，每有一次右边式子对应的hash那么便是乘的关系</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%ld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=1840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-1840 Eqs&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Consider equations having the following form:&lt;br&gt;a1&lt;em&gt;x1^3+ a2&lt;/em&gt;x2^3+ a3&lt;em&gt;x3^3+ a4&lt;/em&gt;x4^3+ a5*x5^3=0&lt;br&gt;The coefficients are given integers from the interval [-50,50].&lt;br&gt;It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}.&lt;/p&gt;
&lt;p&gt;Determine how many solutions satisfy the given equation.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="哈希" scheme="https://amannix.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>POJ-3274 Gold Balanced Lineup</title>
    <link href="https://amannix.github.io/2018/10/16/POJ-3274/"/>
    <id>https://amannix.github.io/2018/10/16/POJ-3274/</id>
    <published>2018-10-16T10:49:00.000Z</published>
    <updated>2018-10-17T07:42:49.352Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=3274" target="_blank" rel="noopener">POJ-3274 Gold Balanced Lineup</a></p><p><strong>Description</strong><br><div class="note default"><p>Farmer John’s N cows (1 ≤ N ≤ 100,000) share many similarities. In fact, FJ has been able to narrow down the list of features shared by his cows to a list of only K different features (1 ≤ K ≤ 30). For example, cows exhibiting feature #1 might have spots, cows exhibiting feature #2 might prefer C to Pascal, and so on.</p><p>FJ has even devised a concise way to describe each cow in terms of its “feature ID”, a single K-bit integer whose binary representation tells us the set of features exhibited by the cow. As an example, suppose a cow has feature ID = 13. Since 13 written in binary is 1101, this means our cow exhibits features 1, 3, and 4 (reading right to left), but not feature 2. More generally, we find a 1 in the 2^(i-1) place if a cow exhibits feature i.</p><p>Always the sensitive fellow, FJ lined up cows 1..N in a long row and noticed that certain ranges of cows are somewhat “balanced” in terms of the features the exhibit. A contiguous range of cows i..j is balanced if each of the K possible features is exhibited by the same number of cows in the range. FJ is curious as to the size of the largest balanced range of cows. See if you can determine it.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>Line 1: Two space-separated integers, N and K.<br>Lines 2..N+1: Line i+1 contains a single K-bit integer specifying the features present in cow i. The least-significant bit of this integer is 1 if the cow exhibits feature #1, and the most-significant bit is 1 if the cow exhibits feature #K.</p></div><br><strong>Output</strong><br><div class="note default"><p>Line 1: A single integer giving the size of the largest contiguous balanced group of cows.</p></div><br><strong>Sample Input</strong></p><blockquote><p>7 3<br>7<br>6<br>7<br>2<br>1<br>4<br>2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>4</p></blockquote><p><strong>Think</strong><br>说农夫有N头牛和K种特点，每头牛的特点用一个数字m表示，用这个数字m的二进制表示它所具有的特点，例如二进制1011，此时说明这头牛具有第1、3、4种特性。现在给出N头牛的特性的十进制表示。要求出从第i头牛到第j头牛这个区间之内，每一种特性出现次数是相同的。求这个区间的最大值。做法是先简单的将十进制转化成二进制。此时就出现N个二进制数列，求一个区间内出现次数相等很自然想到前缀和。以每一列为单位，从上到下求前缀和，用sum[][]记录。此时只要求sum[j][0]-sum[i][0]=sum[j][1]-sum[i][1]…=sum[j][k]-sum[i][k].将上式变换得到<br>sum[i][1]-sum[i][0]=sum[j][1]-sum[j][0]<br>sum[i][2]-sum[i][0]=sum[j][2]-sum[j][0]<br>…<br>sum[i][k]-sum[i][k]=sum[j][k]-sum[j][0]<br>因此，前缀和数组sum求每一行的每一个元素减去第一个元素即可，用c[][]保存。<br>例如样例中，可以先分解成：</p><blockquote><p>111<br>110<br>111<br>010<br>001<br>100<br>010  </p></blockquote><p>综上答案是从3-6之间才是合理的最大区间，每次特性都出现了两次。求前缀和之后sum数组如下</p><blockquote><p>111<br>221<br>332<br>342<br>343<br>443<br>453  </p></blockquote><p>现在纵向求前缀和之后很明显的sum[6]-sum[2]得到数列222。即是合理条件，答案就是j-i即是4。至于为什么区间从3-6变成了2-6，这个是前缀和的特性很好理解。忘了再处理一下变成数组c[][]：</p><blockquote><p>000<br>00-1<br>00-1<br>01-1<br>010<br>00-1<br>01-1  </p></blockquote><p>根据上面的推导可知。现在只需要找到两行相距最远的i和j使得c[i] == c[j]，然后答案就是j-i。再接下来就是正常的整型数组离散化找最大区间。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 99997</span></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">100010</span>][<span class="number">40</span>];<span class="comment">//保存二进制属性</span></span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">100100</span>][<span class="number">40</span>];<span class="comment">//保存二进制前缀和</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">100010</span>][<span class="number">40</span>];<span class="comment">//保存sum中每一列减去第一列的数据</span></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> Max_ans;<span class="comment">//最大区间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span> <span class="title">HASH</span>&#123;</span><span class="comment">//使用连地址法时利用new对象来动态分配空间比手动申请链表好的多。</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="keyword">int</span> i;<span class="comment">//保存C数组中的下标i</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">HASH</span>* <span class="title">next</span>;</span></span><br><span class="line">        HASH()</span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="number">0</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;HashTable;</span><br><span class="line">HashTable* Hash[<span class="number">100010</span>];<span class="comment">//链地址的头部</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//不知道为啥我编译器自带的绝对值函数丢失</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span> ? n : -n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span><span class="comment">//判断重复数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;i &lt; n; ++i,++j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c[p1][i]!= c[p2][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//其实就是key键值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        sum += c[p][i];</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="built_in">abs</span> (sum)%mod;<span class="comment">//被哈希的数组中有可能产生负值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Hash[sum] == <span class="number">0</span>)&#123;</span><br><span class="line">        HashTable* in = <span class="keyword">new</span> HashTable;</span><br><span class="line">        Hash[sum] = in;</span><br><span class="line">        in-&gt;i = p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//处理散列冲突，相同键值的数组有可能是重复的。</span></span><br><span class="line">        HashTable* in = Hash[sum];<span class="comment">//先将头部地址取出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp(p,in-&gt;i))&#123;<span class="comment">//如果两数组重复，那么尝试更新答案最大值</span></span><br><span class="line">                <span class="keyword">int</span> dis = p - in-&gt;i;</span><br><span class="line">                <span class="keyword">if</span> (Max_ans &lt; dis)&#123;</span><br><span class="line">                    Max_ans = dis;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ;<span class="comment">/*假设这次进入的是p，它和以前某次i相等了。</span></span><br><span class="line"><span class="comment">                那么根本不需要把这次p加入哈希表，因为如果后面又有一个j和这次p相等</span></span><br><span class="line"><span class="comment">                那么j也一定和i相等，并且由于i是比p更早出现的所以j-i一定大于j-p，</span></span><br><span class="line"><span class="comment">                因此对于相同数列每次只需要保存最先出现的那个即可*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in-&gt;next == <span class="number">0</span>)&#123;<span class="comment">//到头了把c[p]加入哈希表</span></span><br><span class="line">                HashTable* temp = <span class="keyword">new</span> HashTable;</span><br><span class="line">                temp-&gt;i = p;</span><br><span class="line">                in-&gt;next = temp;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            in = in-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> index)</span><span class="comment">//二进制转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        buf[index][i] = k%<span class="number">2</span>;</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;m,&amp;n))&#123;</span><br><span class="line">        Max_ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(Hash,<span class="number">0</span>,<span class="keyword">sizeof</span> Hash);</span><br><span class="line">        hash(<span class="number">0</span>);<span class="comment">//不知道为啥一定要先把0放入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;<span class="comment">//转化成二进制</span></span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">            change(k,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++j)&#123;<span class="comment">//求纵向前缀和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">                buf[i][j] += buf[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;<span class="comment">//求每列减去第一列的值。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++j)&#123;</span><br><span class="line">                c[i][j] = buf[i][j] - buf[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">            hash(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,Max_ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=3274&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-3274 Gold Balanced Lineup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Farmer John’s N cows (1 ≤ N ≤ 100,000) share many similarities. In fact, FJ has been able to narrow down the list of features shared by his cows to a list of only K different features (1 ≤ K ≤ 30). For example, cows exhibiting feature #1 might have spots, cows exhibiting feature #2 might prefer C to Pascal, and so on.&lt;/p&gt;
&lt;p&gt;FJ has even devised a concise way to describe each cow in terms of its “feature ID”, a single K-bit integer whose binary representation tells us the set of features exhibited by the cow. As an example, suppose a cow has feature ID = 13. Since 13 written in binary is 1101, this means our cow exhibits features 1, 3, and 4 (reading right to left), but not feature 2. More generally, we find a 1 in the 2^(i-1) place if a cow exhibits feature i.&lt;/p&gt;
&lt;p&gt;Always the sensitive fellow, FJ lined up cows 1..N in a long row and noticed that certain ranges of cows are somewhat “balanced” in terms of the features the exhibit. A contiguous range of cows i..j is balanced if each of the K possible features is exhibited by the same number of cows in the range. FJ is curious as to the size of the largest balanced range of cows. See if you can determine it.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="哈希" scheme="https://amannix.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>POJ-3349 Snowflake Snow Snowflakes(除留取余法，链地址法)</title>
    <link href="https://amannix.github.io/2018/10/11/POJ-3349/"/>
    <id>https://amannix.github.io/2018/10/11/POJ-3349/</id>
    <published>2018-10-11T04:03:11.000Z</published>
    <updated>2018-10-11T04:48:22.273Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=3349" target="_blank" rel="noopener">POJ-3349 Snowflake Snow Snowflakes</a></p><p><strong>Description</strong><br><div class="note default"><p>You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line of input will contain a single integer n, 0 &lt; n ≤ 100000, the number of snowflakes to follow. This will be followed by n lines, each describing a snowflake. Each snowflake will be described by a line containing six integers (each integer is at least 0 and less than 10000000), the lengths of the arms of the snow ake. The lengths of the arms will be given in order around the snowflake (either clockwise or counterclockwise), but they may begin with any of the six arms. For example, the same snowflake could be described as 1 2 3 4 5 6 or 4 3 2 1 6 5.</p></div><br><strong>Output</strong><br><div class="note default"><p>If all of the snowflakes are distinct, your program should print the message:<br>No two snowflakes are alike.<br>If there is a pair of possibly identical snow akes, your program should print the message:<br>Twin snowflakes found.</p></div><br><strong>Sample Input</strong></p><blockquote><p>2<br>1 2 3 4 5 6<br>4 3 2 1 6 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Twin snowflakes found.</p></blockquote><p><strong>Think</strong><br>emmm，一题灰常棒的哈希题，给出N组数列，每组数列六个数字。对于两组相同数列的定义为：将数列拼接成环之后两个环可以完全契合，即两环顺序相同。</p><blockquote><p>《算法精解：C语言描述》上提到的一种简单的将键值k映射到m槽位的方法：hash(k)=k mod m。而该书上写了一段话：“通常情况下，要避免m取2的幂，因为假设m=2^p，则h(k)是k的二进制数的低p位……，通常选择m会是一个素数，而且不那么靠近2的幂……”。这段话理由是：从概率的角度，出现相同的概率比较高，而通常我们希望 h(k) 的值依赖于 k 的所有位而不是最低 p 位，因为这样才会使得散列表看起来更均匀。当m不是素数时在散列分布时也会增加分布不均匀的机会，总的来说哈希函数的设计尽量使键值均匀、随机地分布在表中，其他方法可以参考《算法导论》。</p></blockquote><p>我们可以利用除留取余法，将数列中所有的值都对m取余。得到结果再取余。或者直接全部相加再取余得到键值。但是这样会产生一个致命的问题就是可能产生相同键值的散列，这时便应该使用链地址法处理散列冲突。之后我们可以发现只有键值相同的数列才有可能相等，所以在线输入的时候便可以在处理冲突的时候顺便把所有键值相同的数列比较一遍。<br>之所以不采用线性探测法是因为数据范围过大，所需哈希空间也大，设计不好的话很可能爆范围。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 14997</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">6</span>];</span><br><span class="line">&#125;code[<span class="number">15000</span>][<span class="number">100</span>];<span class="comment">//一维数组代表key值映射，二维存储相应的key值的冲突数列</span></span><br><span class="line"><span class="keyword">int</span> code_index[<span class="number">15000</span>];<span class="comment">//记录对应key值的冲突数量</span></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">15000</span>][<span class="number">100</span>];<span class="comment">//vis标记哈希表是否被占用，</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> buf[])</span><span class="comment">//hash函数求整型数组的键值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">        num += buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> m[],<span class="keyword">int</span> n[])</span><span class="comment">//比较函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>;s &lt; <span class="number">6</span>; ++s)&#123;<span class="comment">//正序环形比较</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = s; i &lt; <span class="number">6</span>; ++i,j = (j+<span class="number">1</span>)%<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="comment">//printf ("%d %d\n",i,j);</span></span><br><span class="line">            <span class="keyword">if</span> (m[i] != n[j])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>;s &lt; <span class="number">6</span>; ++s)&#123;<span class="comment">//逆序环形比较</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = s;i &lt; <span class="number">6</span>; ++i,j = (j+<span class="number">5</span>)%<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="comment">//printf ("%d %d\n",i,j);</span></span><br><span class="line">            <span class="keyword">if</span> (m[i] != n[j])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line">    Node temp;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">while</span> (--n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;temp.a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> num = hash(temp.a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis[num][<span class="number">0</span>] == <span class="literal">true</span>)&#123;<span class="comment">//处理散列冲突</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; code_index[num]; ++i)&#123;<span class="comment">//只有key值相同的数列才有可能相同，</span></span><br><span class="line">                <span class="comment">//然后在对应的冲突集合中一一比较</span></span><br><span class="line">                <span class="keyword">if</span> (cmp(code[num][i].a,temp.a) == <span class="literal">true</span>)&#123;<span class="comment">//一旦有某次相同，则直接输出.</span></span><br><span class="line">                    <span class="built_in">printf</span> (<span class="string">"Twin snowflakes found.\n"</span>);</span><br><span class="line">                    <span class="comment">//return 0;</span></span><br><span class="line">                    ans = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[num][code_index[num]] = <span class="literal">true</span>;</span><br><span class="line">            code[num][code_index[num]++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//非冲突情况</span></span><br><span class="line">            vis[num][code_index[num]] = <span class="literal">true</span>;</span><br><span class="line">            code[num][code_index[num]++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"No two snowflakes are alike.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=3349&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-3349 Snowflake Snow Snowflakes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="哈希" scheme="https://amannix.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>POJ-1016 Numbers That Count(字符串压缩)</title>
    <link href="https://amannix.github.io/2018/10/09/POJ-1016/"/>
    <id>https://amannix.github.io/2018/10/09/POJ-1016/</id>
    <published>2018-10-09T06:11:13.000Z</published>
    <updated>2018-10-11T04:06:10.344Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=1016" target="_blank" rel="noopener">POJ-1016</a></p><p><strong>Description</strong></p><div class="note default"><p>“Kronecker’s Knumbers” is a little company that manufactures plastic digits for use in signs (theater marquees, gas station price displays, and so on). The owner and sole employee, Klyde Kronecker, keeps track of how many digits of each type he has used by maintaining an inventory book. For instance, if he has just made a sign containing the telephone number “5553141”, he’ll write down the number “5553141” in one column of his book, and in the next column he’ll list how many of each digit he used: two 1s, one 3, one 4, and three 5s. (Digits that don’t get used don’t appear in the inventory.) He writes the inventory in condensed form, like this: “21131435”.</p><p>The other day, Klyde filled an order for the number 31123314 and was amazed to discover that the inventory of this number is the same as the number—it has three 1s, one 2, three 3s, and one 4! He calls this an example of a “self-inventorying number”, and now he wants to find out which numbers are self-inventorying, or lead to a self-inventorying number through iterated application of the inventorying operation described below. You have been hired to help him in his investigations.</p><p>Given any non-negative integer n, its inventory is another integer consisting of a concatenation of integers c1 d1 c2 d2 … ck dk , where each ci and di is an unsigned integer, every ci is positive, the di satisfy 0&lt;=d1&lt;d2&lt;…&lt;dk&lt;=9, and, for each digit d that appears anywhere in n, d equals di for some i and d occurs exactly ci times in the decimal representation of n. For instance, to compute the inventory of 5553141 we set c1 = 2, d1 = 1, c2 = 1, d2 = 3, etc., giving 21131435. The number 1000000000000 has inventory 12011 (“twelve 0s, one 1”).</p><p>An integer n is called self-inventorying if n equals its inventory. It is called self-inventorying after j steps (j&gt;=1) if j is the smallest number such that the value of the j-th iterative application of the inventory function is self-inventorying. For instance, 21221314 is self-inventorying after 2 steps, since the inventory of 21221314 is 31321314, the inventory of 31321314 is 31123314, and 31123314 is self-inventorying.</p><p>Finally, n enters an inventory loop of length k (k&gt;=2) if k is the smallest number such that for some integer j (j&gt;=0), the value of the j-th iterative application of the inventory function is the same as the value of the (j + k)-th iterative application. For instance, 314213241519 enters an inventory loop of length 2, since the inventory of 314213241519 is 412223241519 and the inventory of 412223241519 is 314213241519, the original number (we have j = 0 in this case).</p><p>Write a program that will read a sequence of non-negative integers and, for each input value, state whether it is self-inventorying, self-inventorying after j steps, enters an inventory loop of length k, or has none of these properties after 15 iterative applications of the inventory function.</p></div><a id="more"></a><p><strong>Input</strong></p><div class="note default"><p>A sequence of non-negative integers, each having at most 80 digits, followed by the terminating value -1. There are no extra leading zeros.</p></div><p><strong>Output</strong></p><div class="note default"><p>For each non-negative input value n, output the appropriate choice from among the following messages (where n is the input value, j is a positive integer, and k is a positive integer greater than 1):<br>n is self-inventorying<br>n is self-inventorying after j steps<br>n enters an inventory loop of length k<br>n can not be classified after 15 iterations</p></div><p><strong>Sample Input</strong></p><blockquote><p>22<br>31123314<br>314213241519<br>21221314<br>111222234459<br>-1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>22 is self-inventorying<br>31123314 is self-inventorying<br>314213241519 enters an inventory loop of length 2<br>21221314 is self-inventorying after 2 steps<br>111222234459 enters an inventory loop of length 2</p></blockquote><p><strong>思路</strong><br>题目大致是说有一个纯数字组成的字符串，现在这个字符串可以被压缩。压缩后的字符串规则为：c1d1c2d2…ckdk，这里d指的是一个数字，那么c指的就是d出现的次数。例如，2233224可以提取为包含了4个2，2个3，1个4，则可以压缩成422314。现在要求的问题是，有一种情况是某一个串压缩之后和原来相同，例如31123314压缩 <strong>一次</strong> 之后和原来相同，这样的字符串称为 <em>self-inventorying</em>。现给你一个字符串可以 <em>循环压缩</em>，问这个字符串是不是self-inventorying。第二种情况就是这个字符串经过第N次压缩以后，它的压缩串与N-1次压缩串相同时，那么输出 <em>n is self-inventorying after j steps</em>。第三种情况就是这个串第N次压缩之后与第K次压缩状态重复了，那么这时会产生一种循环，此时称 <em>n enters an inventory loop of length k</em>，注意这里的 <strong>K != N-1</strong>（如果这里K == N-1那么就应该是第二种情况），k指循环次数。特别地，经过15次压缩以后依旧不满足上面任何一种情况时输出 <em>n can not be classified after 15 iterations</em>。题目很长而且self-inventory定义也表述的比较隐晦，当且仅当压缩之后和压缩之前的字符串相同时才成立，并不是说压缩N次之后和最初原始字符串相同。然而做法特别简单，就是单纯的字符串根据规则去模拟压缩。然后map容器去离散化字符串记录即可。</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; ma;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">char</span> n[],<span class="keyword">char</span> book[],<span class="keyword">int</span> k,<span class="keyword">char</span> ans[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(n,book) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%s is self-inventorying\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%s is self-inventorying after %d steps\n"</span>,ans,k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ma[book])&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%s enters an inventory loop of length %d\n"</span>,ans,k - ma[book]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ma[book] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">(<span class="keyword">char</span> n[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> m[<span class="number">20</span>][<span class="number">90</span>] = &#123;<span class="number">0</span>&#125;,temp[<span class="number">90</span>];</span><br><span class="line">    <span class="keyword">int</span> vis = <span class="number">0</span>;</span><br><span class="line">    ma.clear();</span><br><span class="line">    <span class="built_in">strcpy</span>(m[<span class="number">0</span>],n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心代码：循环15次压缩字符串,通过hash来记忆每个字符出现的次数从而重构新字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">15</span>; ++k)&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> book[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="keyword">sizeof</span> temp);</span><br><span class="line">        <span class="built_in">strcpy</span>(temp,m[k<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//printf ("s = %s\n",temp);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; ++i)&#123;<span class="comment">//各位数字离散化</span></span><br><span class="line">            ++hash[temp[i] - <span class="string">'0'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i])&#123;</span><br><span class="line">                <span class="keyword">if</span> (hash[i] &gt; <span class="number">9</span>)&#123;<span class="comment">//依照hash表，构造新字符串</span></span><br><span class="line">                    book[vis++] = hash[i]/<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                    book[vis++] = hash[i]%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                    book[vis++] = i + <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    book[vis++] = hash[i] + <span class="string">'0'</span>;</span><br><span class="line">                    book[vis++] = i + <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        book[vis] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">//printf ("e = %s\n\n",book);</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m[k],book);</span><br><span class="line">        <span class="comment">//到这里，每个m[k]记录了出现过的字符串，book记录了当前出现的字符串。</span></span><br><span class="line">        <span class="keyword">if</span> (get_ans(m[k<span class="number">-1</span>],book,k,n))&#123;</span><br><span class="line">            <span class="keyword">return</span>  ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%s can not be classified after 15 iterations\n"</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> n[<span class="number">90</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">"%s"</span>,n) &amp;&amp; n[<span class="number">0</span>] != <span class="string">'-'</span>)&#123;</span><br><span class="line">        work(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=1016&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-1016&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;“Kronecker’s Knumbers” is a little company that manufactures plastic digits for use in signs (theater marquees, gas station price displays, and so on). The owner and sole employee, Klyde Kronecker, keeps track of how many digits of each type he has used by maintaining an inventory book. For instance, if he has just made a sign containing the telephone number “5553141”, he’ll write down the number “5553141” in one column of his book, and in the next column he’ll list how many of each digit he used: two 1s, one 3, one 4, and three 5s. (Digits that don’t get used don’t appear in the inventory.) He writes the inventory in condensed form, like this: “21131435”.&lt;/p&gt;
&lt;p&gt;The other day, Klyde filled an order for the number 31123314 and was amazed to discover that the inventory of this number is the same as the number—it has three 1s, one 2, three 3s, and one 4! He calls this an example of a “self-inventorying number”, and now he wants to find out which numbers are self-inventorying, or lead to a self-inventorying number through iterated application of the inventorying operation described below. You have been hired to help him in his investigations.&lt;/p&gt;
&lt;p&gt;Given any non-negative integer n, its inventory is another integer consisting of a concatenation of integers c1 d1 c2 d2 … ck dk , where each ci and di is an unsigned integer, every ci is positive, the di satisfy 0&amp;lt;=d1&amp;lt;d2&amp;lt;…&amp;lt;dk&amp;lt;=9, and, for each digit d that appears anywhere in n, d equals di for some i and d occurs exactly ci times in the decimal representation of n. For instance, to compute the inventory of 5553141 we set c1 = 2, d1 = 1, c2 = 1, d2 = 3, etc., giving 21131435. The number 1000000000000 has inventory 12011 (“twelve 0s, one 1”).&lt;/p&gt;
&lt;p&gt;An integer n is called self-inventorying if n equals its inventory. It is called self-inventorying after j steps (j&amp;gt;=1) if j is the smallest number such that the value of the j-th iterative application of the inventory function is self-inventorying. For instance, 21221314 is self-inventorying after 2 steps, since the inventory of 21221314 is 31321314, the inventory of 31321314 is 31123314, and 31123314 is self-inventorying.&lt;/p&gt;
&lt;p&gt;Finally, n enters an inventory loop of length k (k&amp;gt;=2) if k is the smallest number such that for some integer j (j&amp;gt;=0), the value of the j-th iterative application of the inventory function is the same as the value of the (j + k)-th iterative application. For instance, 314213241519 enters an inventory loop of length 2, since the inventory of 314213241519 is 412223241519 and the inventory of 412223241519 is 314213241519, the original number (we have j = 0 in this case).&lt;/p&gt;
&lt;p&gt;Write a program that will read a sequence of non-negative integers and, for each input value, state whether it is self-inventorying, self-inventorying after j steps, enters an inventory loop of length k, or has none of these properties after 15 iterative applications of the inventory function.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="哈希" scheme="https://amannix.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>POJ-3020 Antenna Placement(二分图的最小路径覆盖)</title>
    <link href="https://amannix.github.io/2018/09/27/POJ-3020/"/>
    <id>https://amannix.github.io/2018/09/27/POJ-3020/</id>
    <published>2018-09-27T04:36:01.000Z</published>
    <updated>2018-09-27T05:18:08.377Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=3020" target="_blank" rel="noopener">POJ-3020 Antenna Placement</a></p><p><strong>Description</strong></p><div class="note default"><p>The Global Aerial Research Centre has been allotted the task of building the fifth generation of mobile phone nets in Sweden. The most striking reason why they got the job, is their discovery of a new, highly noise resistant, antenna. It is called 4DAir, and comes in four types. Each type can only transmit and receive signals in a direction aligned with a (slightly skewed) latitudinal and longitudinal grid, because of the interacting electromagnetic field of the earth. The four types correspond to antennas operating in the directions north, west, south, and east, respectively. Below is an example picture of places of interest, depicted by twelve small rings, and nine 4DAir antennas depicted by ellipses covering them.<br><img src="http://poj.org/images/3020_1.jpg" alt=""><br>Obviously, it is desirable to use as few antennas as possible, but still provide coverage for each place of interest. We model the problem as follows: Let A be a rectangular matrix describing the surface of Sweden, where an entry of A either is a point of interest, which must be covered by at least one antenna, or empty space. Antennas can only be positioned at an entry in A. When an antenna is placed at row r and column c, this entry is considered covered, but also one of the neighbouring entries (c+1,r),(c,r+1),(c-1,r), or (c,r-1), is covered depending on the type chosen for this particular antenna. What is the least number of antennas for which there exists a placement in A such that all points of interest are covered?</p></div><a id="more"></a><p><strong>Input</strong></p><div class="note default"><p>On the first row of input is a single positive integer n, specifying the number of scenarios that follow. Each scenario begins with a row containing two positive integers h and w, with 1 &lt;= h &lt;= 40 and 0 &lt; w &lt;= 10. Thereafter is a matrix presented, describing the points of interest in Sweden in the form of h lines, each containing w characters from the set [‘*‘,’o’]. A ‘*‘-character symbolises a point of interest, whereas a ‘o’-character represents open space.</p></div><p><strong>Output</strong></p><div class="note default"><p>For each scenario, output the minimum number of antennas necessary to cover all ‘*‘-entries in the scenario’s matrix, on a row of its own.</p></div><p><strong>Sample Input</strong></p><blockquote><p>2<br>7 9<br>ooo**oooo<br>**oo*ooo*<br>o*oo**o**<br>ooooooooo<br>*******oo<br>o*o*oo*oo<br>*******oo<br>10 1<br>*<br>*<br>*<br>o<br>*<br>*<br>*<br>*<br>*<br>*</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>17<br>5</p></blockquote><p><strong>思路</strong></p><p>题意比较明了，雷达的使用范围是当前城市或者其周围的一个城市（一个雷达最多包含两个城市）。那么给出城市地图，求最少多少个雷达可以覆盖所有的城市。此题可以将城市抽象为顶点，两个城市之间可以被雷达覆盖的话就是一条边，那么这里每条边就代表可以放置一个雷达。那么题目就转换成了怎么求最少的边可以覆盖所有的点。注意*代表了城市，o代表空地。</p><blockquote><p>二分图模型的最小路径覆盖问题指的是一个边集，此边集可以连接所有的顶点，求此边集的最小值。  </p></blockquote><p>有如下结论：<br>如果二分图为有向图，则 <strong>最小路径覆盖=顶点数-最大匹配数</strong><br>如果二分图为无向图，则 <strong>最小路径覆盖=定点数-最大匹配数/2</strong></p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> coor[<span class="number">41</span>][<span class="number">11</span>];<span class="comment">//存图</span></span><br><span class="line"><span class="keyword">int</span> ct[<span class="number">405</span>][<span class="number">405</span>],coor_flag[<span class="number">41</span>][<span class="number">11</span>],m,n,t;<span class="comment">//建二分图</span></span><br><span class="line"><span class="keyword">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,used[<span class="number">405</span>],vis[<span class="number">405</span>],cut;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">found</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//求增广路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cut; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ct[x][i] &amp;&amp; !used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span> || found(vis[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span><span class="comment">//建图函数，对每一个城市编号然后用邻接矩阵存图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n ;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (coor[i][j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                coor_flag[i][j] = ++cut;<span class="comment">/*这里一定要单独用另一个函数记录顶点</span></span><br><span class="line"><span class="comment">                ，不能用原来的coor记录，因为当路径的顶点超过127时爆范围产生</span></span><br><span class="line"><span class="comment">                负数。char只有8位并且有一个用作符号位因此最多存储2^7数据。*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                coor_flag[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n ;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (coor_flag[i][j])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = next[k][<span class="number">0</span>] + i,y = next[k][<span class="number">1</span>] + j;</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (coor_flag[x][y])&#123;</span><br><span class="line">                        ct[coor_flag[i][j]][coor_flag[x][y]] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span> (ct,<span class="number">0</span>,<span class="keyword">sizeof</span> ct);</span><br><span class="line">        <span class="built_in">memset</span> (vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%s"</span>,coor[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cut = <span class="number">0</span>;<span class="comment">//记录顶点数</span></span><br><span class="line">        Create();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cut; ++i)&#123;<span class="comment">//KM算法求最大匹配数</span></span><br><span class="line">            <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span> used);</span><br><span class="line">            <span class="keyword">if</span> (found(i))&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,cut - ans/<span class="number">2</span>);<span class="comment">//无向图的最小路径覆盖</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lyy289065406/article/details/6647040" target="_blank" rel="noopener">Hint</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=3020&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-3020 Antenna Placement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;The Global Aerial Research Centre has been allotted the task of building the fifth generation of mobile phone nets in Sweden. The most striking reason why they got the job, is their discovery of a new, highly noise resistant, antenna. It is called 4DAir, and comes in four types. Each type can only transmit and receive signals in a direction aligned with a (slightly skewed) latitudinal and longitudinal grid, because of the interacting electromagnetic field of the earth. The four types correspond to antennas operating in the directions north, west, south, and east, respectively. Below is an example picture of places of interest, depicted by twelve small rings, and nine 4DAir antennas depicted by ellipses covering them.&lt;br&gt;&lt;img src=&quot;http://poj.org/images/3020_1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Obviously, it is desirable to use as few antennas as possible, but still provide coverage for each place of interest. We model the problem as follows: Let A be a rectangular matrix describing the surface of Sweden, where an entry of A either is a point of interest, which must be covered by at least one antenna, or empty space. Antennas can only be positioned at an entry in A. When an antenna is placed at row r and column c, this entry is considered covered, but also one of the neighbouring entries (c+1,r),(c,r+1),(c-1,r), or (c,r-1), is covered depending on the type chosen for this particular antenna. What is the least number of antennas for which there exists a placement in A such that all points of interest are covered?&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="https://amannix.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图" scheme="https://amannix.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>HDU-2255 奔小康赚大钱(二分图最佳匹配)</title>
    <link href="https://amannix.github.io/2018/09/16/HDU-2255/"/>
    <id>https://amannix.github.io/2018/09/16/HDU-2255/</id>
    <published>2018-09-16T10:51:57.000Z</published>
    <updated>2018-09-16T11:21:07.771Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2255" target="_blank" rel="noopener">HDU-2255 奔小康赚大钱</a></p><p><strong>Problem Description</strong></p><div class="note default"><p>传说在遥远的地方有一个非常富裕的村落,有一天,村长决定进行制度改革：重新分配房子。<br>这可是一件大事,关系到人民的住房问题啊。村里共有n间房间,刚好有n家老百姓,考虑到每家都要有房住（如果有老百姓没房子住的话，容易引起不安定因素），每家必须分配到一间房子且只能得到一间房子。<br>另一方面,村长和另外的村领导希望得到最大的效益,这样村里的机构才会有钱.由于老百姓都比较富裕,他们都能对每一间房子在他们的经济范围内出一定的价格,比如有3间房子,一家老百姓可以对第一间出10万,对第2间出2万,对第3间出20万.(当然是在他们的经济范围内).现在这个问题就是村领导怎样分配房子才能使收入最大.(村民即使有钱购买一间房子但不一定能买到,要看村领导分配的).</p></div><a id="more"></a><p><strong>Input</strong></p><div class="note default"><p>输入数据包含多组测试用例，每组数据的第一行输入n,表示房子的数量(也是老百姓家的数量)，接下来有n行,每行n个数表示第i个村名对第j间房出的价格(n&lt;=300)。</p></div><p><strong>Output</strong></p><div class="note default"><p>请对每组数据输出最大的收入值，每组的输出占一行。</p></div><p><strong>Sample Input</strong></p><blockquote><p>2<br>100 10<br>15 23</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>123</p></blockquote><p><strong>思路</strong><br>很明显把村民和房子分成两个部分，不同人愿意接受的房子价格作为边。于是就形成了带权值的二分图模型，根据题意就是求解最佳匹配的模板题。</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> match[Max],ex_x[Max],ex_y[Max],slack[Max],space[Max][Max],N;</span><br><span class="line"><span class="keyword">bool</span> vis_x[Max],vis_y[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis_x[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis_y[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> gap = ex_x[x] + ex_y[i] - space[x][i];</span><br><span class="line">            <span class="keyword">if</span> (gap == <span class="number">0</span>)&#123;</span><br><span class="line">                vis_y[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (match[i] == <span class="number">-1</span> || dfs(match[i]))&#123;</span><br><span class="line">                    match[i] = x;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                slack[i] = min(slack[i],gap);</span><br><span class="line">                <span class="comment">//由于gap始终和X集合中的x有关，因此slack必定记录了i到已经标记过的X集合中最小差值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">memset</span>(ex_y,<span class="number">0</span>,<span class="keyword">sizeof</span> ex_y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N; ++i)&#123;</span><br><span class="line">        ex_x[i] = space[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; N; ++j)&#123;</span><br><span class="line">            ex_x[i] = max(ex_x[i],space[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(slack,INF,<span class="keyword">sizeof</span> slack);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis_x,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis_x);</span><br><span class="line">            <span class="built_in">memset</span>(vis_y,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis_y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dfs(i))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> d = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (vis_y[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    d = min(slack[j],d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (vis_x[j] == <span class="literal">true</span>)&#123;</span><br><span class="line">                    ex_x[j] -= d;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (vis_y[j] == <span class="literal">true</span>)&#123;</span><br><span class="line">                    ex_y[j] += d;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    slack[j] -= d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N; ++i)&#123;</span><br><span class="line">        ans += space[match[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;N))&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N; ++j)</span><br><span class="line">                <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;space[i][j]);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,KM());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2255&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU-2255 奔小康赚大钱&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem Description&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;传说在遥远的地方有一个非常富裕的村落,有一天,村长决定进行制度改革：重新分配房子。&lt;br&gt;这可是一件大事,关系到人民的住房问题啊。村里共有n间房间,刚好有n家老百姓,考虑到每家都要有房住（如果有老百姓没房子住的话，容易引起不安定因素），每家必须分配到一间房子且只能得到一间房子。&lt;br&gt;另一方面,村长和另外的村领导希望得到最大的效益,这样村里的机构才会有钱.由于老百姓都比较富裕,他们都能对每一间房子在他们的经济范围内出一定的价格,比如有3间房子,一家老百姓可以对第一间出10万,对第2间出2万,对第3间出20万.(当然是在他们的经济范围内).现在这个问题就是村领导怎样分配房子才能使收入最大.(村民即使有钱购买一间房子但不一定能买到,要看村领导分配的).&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="https://amannix.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图" scheme="https://amannix.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>POJ-3041 Asteroids(二分图最小点覆盖)</title>
    <link href="https://amannix.github.io/2018/09/16/POJ-3041/"/>
    <id>https://amannix.github.io/2018/09/16/POJ-3041/</id>
    <published>2018-09-16T10:35:23.000Z</published>
    <updated>2018-09-27T05:18:18.234Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=3041" target="_blank" rel="noopener">POJ-3041 Asteroids</a></p><p><strong>Description</strong></p><div class="note default"><p>Bessie wants to navigate her spaceship through a dangerous asteroid field in the shape of an N x N grid (1 &lt;= N &lt;= 500). The grid contains K asteroids (1 &lt;= K &lt;= 10,000), which are conveniently located at the lattice points of the grid.</p><p>Fortunately, Bessie has a powerful weapon that can vaporize all the asteroids in any given row or column of the grid with a single shot.This weapon is quite expensive, so she wishes to use it sparingly.Given the location of all the asteroids in the field, find the minimum number of shots Bessie needs to fire to eliminate all of the asteroids.</p></div><a id="more"></a><p><strong>Input</strong></p><div class="note default"><ul><li>Line 1: Two integers N and K, separated by a single space.</li><li>Lines 2..K+1: Each line contains two space-separated integers R and C (1 &lt;= R, C &lt;= N) denoting the row and column coordinates of an asteroid, respectively.</li></ul></div><p><strong>Output</strong></p><div class="note default"><ul><li>Line 1: The integer representing the minimum number of times Bessie must shoot.</li></ul></div><p><strong>Sample Input</strong></p><blockquote><p>3 4<br>1 1<br>1 3<br>2 2<br>3 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2</p></blockquote><p><strong>Hint</strong></p><div class="note default"><p>INPUT DETAILS:<br>The following diagram represents the data, where “X” is an asteroid and “.” is empty space:<br>X.X<br>.X.<br>.X.</p></div><p><strong>思路</strong></p><p>大致题意是说有一片区域用坐标表示，这个区域上有很多的障碍物，然后飞船可以发射激光消灭每一行或者每一列的所有障碍物，求最小发射次数。可以令坐标x，y分别作为顶点建立二分图模型，每个障碍作为连接顶点的边来看。这样便转化为了求图上最少的顶点数使得所有的边都被关联进去（有点像是最小生成树的概念……），也就是二分图最小点覆盖的问题。根据二分图模型某个定理：最大匹配数=最小点覆盖。于是乎就是非常简单的匈牙利模板。</p><p>二分图的最小点覆盖，实质是一个点集，这个集合内的所有顶点可以连接所有的边，然后求最小集合数的问题。</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n,<span class="built_in">map</span>[Max][Max],match[Max];</span><br><span class="line"><span class="keyword">bool</span> vis[Max];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="literal">false</span> &amp;&amp; <span class="built_in">map</span>[u][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[i] == <span class="number">-1</span> || find(match[i]))&#123;</span><br><span class="line">                match[i] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>,<span class="number">0</span>,<span class="keyword">sizeof</span> <span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">map</span>[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">if</span> (find(i))</span><br><span class="line">            ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lyy289065406/article/details/6646007" target="_blank" rel="noopener">Hint</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=3041&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-3041 Asteroids&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Bessie wants to navigate her spaceship through a dangerous asteroid field in the shape of an N x N grid (1 &amp;lt;= N &amp;lt;= 500). The grid contains K asteroids (1 &amp;lt;= K &amp;lt;= 10,000), which are conveniently located at the lattice points of the grid.&lt;/p&gt;
&lt;p&gt;Fortunately, Bessie has a powerful weapon that can vaporize all the asteroids in any given row or column of the grid with a single shot.This weapon is quite expensive, so she wishes to use it sparingly.Given the location of all the asteroids in the field, find the minimum number of shots Bessie needs to fire to eliminate all of the asteroids.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="https://amannix.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图" scheme="https://amannix.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>POJ-1094 Sorting It All Out(拓扑排序)</title>
    <link href="https://amannix.github.io/2018/09/14/POJ-1094/"/>
    <id>https://amannix.github.io/2018/09/14/POJ-1094/</id>
    <published>2018-09-14T06:42:07.000Z</published>
    <updated>2018-09-14T07:03:02.669Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=1094" target="_blank" rel="noopener">POJ-1094 Sorting It All Out</a></p><p><strong>Description</strong></p><div class="note default"><p>An ascending sorted sequence of distinct values is one in which some form of a less-than operator is used to order the elements from smallest to largest. For example, the sorted sequence A, B, C, D implies that A &lt; B, B &lt; C and C &lt; D. in this problem, we will give you a set of relations of the form A &lt; B and ask you to determine whether a sorted order has been specified or not.</p></div><a id="more"></a><p><strong>Input</strong></p><div class="note default"><p>Input consists of multiple problem instances. Each instance starts with a line containing two positive integers n and m. the first value indicated the number of objects to sort, where 2 &lt;= n &lt;= 26. The objects to be sorted will be the first n characters of the uppercase alphabet. The second value m indicates the number of relations of the form A &lt; B which will be given in this problem instance. Next will be m lines, each containing one such relation consisting of three characters: an uppercase letter, the character “&lt;” and a second uppercase letter. No letter will be outside the range of the first n letters of the alphabet. Values of n = m = 0 indicate end of input.</p></div><p><strong>Output</strong></p><div class="note default"><p>For each problem instance, output consists of one line. This line should be one of the following three:</p><p>Sorted sequence determined after xxx relations: yyy…y.<br>Sorted sequence cannot be determined.<br>Inconsistency found after xxx relations.</p><p>where xxx is the number of relations processed at the time either a sorted sequence is determined or an inconsistency is found, whichever comes first, and yyy…y is the sorted, ascending sequence.</p></div><p><strong>Sample Input</strong></p><blockquote><p>4 6<br>A&lt;B<br>A&lt;C<br>B&lt;C<br>C&lt;D<br>B&lt;D<br>A&lt;B<br>3 2<br>A&lt;B<br>B&lt;A<br>26 1<br>A&lt;Z<br>0 0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Sorted sequence determined after 4 relations: ABCD.<br>Inconsistency found after 2 relations.<br>Sorted sequence cannot be determined.</p></blockquote><p><strong>思路</strong><br>题目的意思有点恶心，它应该是每给出一个关系就做一次拓扑排序，有三种情况：</p><blockquote><p>1、Sorted sequence determined after xxx relations: yyy…y.<br>这表明在xxx次条件之后找到了正确的拓扑排序序列。<br>2、Inconsistency found after xxx relations.<br>这表明在xxx次条件之后发生了逻辑错误，即形成了环。<br>3、Sorted sequence cannot be determined.<br>除了以上两种情况以外都输出这个。</p></blockquote><p>但是需要注意的是，第1种情况要求必须是固定的序列，拓扑排序可能发生有多种排序情况。因此每次找入度的时候必须是1。还有就是情况1中xxx不一定是输入的节点数量n，这个没看懂WA无数。还有就是不需要去重。</p><p><strong>Code</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">40</span>][<span class="number">40</span>],pre[<span class="number">40</span>],flag,ans[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cut = <span class="number">0</span>,temp[<span class="number">40</span>],s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++j)&#123;</span><br><span class="line">        temp[j] = pre[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>;t &lt; n; ++t)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>,index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                cnt++;<span class="comment">//计算入度</span></span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>)&#123;<span class="comment">//有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>)&#123;<span class="comment">/*不确定顺序，但是发现顺序不确定不能直接return，</span></span><br><span class="line"><span class="comment">                因为接下来还可能发现存在环的情况。*/</span></span><br><span class="line">            s = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[cut++] = index;</span><br><span class="line">        temp[index] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[index][j])&#123;</span><br><span class="line">                --temp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%lld%lld"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">4</span>];</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">map</span>,<span class="number">0</span>,<span class="keyword">sizeof</span> <span class="built_in">map</span>);</span><br><span class="line">        <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span> pre);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%s"</span>,str);</span><br><span class="line">            <span class="keyword">if</span> (flag)    <span class="keyword">continue</span>;<span class="comment">//确定结果就跳过</span></span><br><span class="line">            <span class="built_in">map</span>[str[<span class="number">0</span>] - <span class="string">'A'</span>][str[<span class="number">2</span>] - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">            ++pre[str[<span class="number">2</span>] - <span class="string">'A'</span>];<span class="comment">//计算入度，注意边不需要去重</span></span><br><span class="line">            <span class="keyword">int</span> s = check(n);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>)&#123;<span class="comment">//有环</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Inconsistency found after %d relations.\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>)&#123;<span class="comment">//发现了唯一的拓扑序列</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Sorted sequence determined after %d relations: "</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">                    <span class="built_in">printf</span> (<span class="string">"%c"</span>,ans[i]+<span class="string">'A'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">".\n"</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Sorted sequence cannot be determined.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=1094&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-1094 Sorting It All Out&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;An ascending sorted sequence of distinct values is one in which some form of a less-than operator is used to order the elements from smallest to largest. For example, the sorted sequence A, B, C, D implies that A &amp;lt; B, B &amp;lt; C and C &amp;lt; D. in this problem, we will give you a set of relations of the form A &amp;lt; B and ask you to determine whether a sorted order has been specified or not.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="https://amannix.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
</feed>
