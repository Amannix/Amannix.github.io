<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiong&#39;blog</title>
  
  <subtitle>渡得八千风沙起，揽下九天明月心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-02T06:25:17.268Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>熊梦彪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF 505 Plasticine zebra(环状字符串处理)</title>
    <link href="http://yoursite.com/2018/09/02/Plasticine%20zebra/"/>
    <id>http://yoursite.com/2018/09/02/Plasticine zebra/</id>
    <published>2018-09-02T05:40:22.000Z</published>
    <updated>2018-09-02T06:25:17.268Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1025/problem/C" target="_blank" rel="noopener">Codeforces Round #505 (rated, Div. 1 + Div. 2) Problem C</a></p><p><strong>Description</strong>  </p><div class="note default"><p>Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras.</p><p>Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let’s call the number of selected pieces the length of the zebra.</p><p>Before assembling the zebra Grisha can make the following operation 00 or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order “bwbbw” (here ‘b’ denotes a black strip, and ‘w’ denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain “wbwbb”.</p><p>Determine the maximum possible length of the zebra that Grisha can produce.</p></div><a id="more"></a><p><strong>Input</strong></p><div class="note default"><p>The only line contains a string ss (1≤|s|≤10^5, where |s| denotes the length of the string ss) comprised of lowercase English letters ‘b’ and ‘w’ only, where ‘w’ denotes a white piece and ‘b’ denotes a black piece.</p></div><p><strong>Output</strong></p><div class="note default"><p>Print a single integer — the maximum possible zebra length.</p></div><table><thead><tr><th style="text-align:center">Input</th><th style="text-align:center">Output</th></tr></thead><tbody><tr><td style="text-align:center">bwwwbwwbw</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">bwwbwwb</td><td style="text-align:center">3</td></tr></tbody></table><p><strong>题意</strong></p><div class="note default"><p>给出一个字符串，该串只有两种字母。然后可以在任意处切开形成两个字符串，然后反转之后再拼接到一起，可以做任意次该操作。求最长交错的字符串长度。如wwbwbbbw，最长交错字符串为wbwb。</p></div><p><strong>思路</strong></p><div class="note default"><p>在该字符串中任意一点切开反转再连接。无论如何必定会使首尾相连。如果一开始就将首尾连接形成一个环的话。那么在这个环上任意一点切开反转之后再连接和原来一模一样，只是起点位发生变化。也可以说，无论原来的串经过多少次合法操作，它始终都是这个环的子串。例如abcdef首尾连接形成环，从cd处操作。最后形成cbafed，首尾连接后依旧符合abcdef的环。那么无论做多少次操作都和做一次是一样的。因此对于本题来说只需要对环上直接找出最长交错子串即可。对于选取起点的问题，可以在环上找任意起点，循环扫描两遍即可。不需要对每一个字符做作为起点进行扫描，那样的时间复杂度是O(n^2)。也可以复制字符串拼接起来扫描一遍，但这样的问题就是当一开始就是交错字符串的情况需要特殊判断。</p></div><p><strong>code</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100100</span>*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>,str);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str),ans = <span class="number">1</span>,max_ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len; ++i)&#123;<span class="comment">//特殊处理一开始就是交错字符串的情况</span></span><br><span class="line"><span class="keyword">if</span> (str[i] == str[i<span class="number">-1</span>])&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; ++i)&#123;<span class="comment">//复制字符串</span></span><br><span class="line">str[i+len] = str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; len*<span class="number">2</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != str[i<span class="number">-1</span>])&#123;</span><br><span class="line">++ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">max_ans = max(max_ans,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max_ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1025/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round #505 (rated, Div. 1 + Div. 2) Problem C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras.&lt;/p&gt;
&lt;p&gt;Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let’s call the number of selected pieces the length of the zebra.&lt;/p&gt;
&lt;p&gt;Before assembling the zebra Grisha can make the following operation 00 or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order “bwbbw” (here ‘b’ denotes a black strip, and ‘w’ denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain “wbwbb”.&lt;/p&gt;
&lt;p&gt;Determine the maximum possible length of the zebra that Grisha can produce.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="http://yoursite.com/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Weakened Common Divisor</title>
    <link href="http://yoursite.com/2018/09/01/Weakened%20Common%20Divisor/"/>
    <id>http://yoursite.com/2018/09/01/Weakened Common Divisor/</id>
    <published>2018-09-01T15:02:35.000Z</published>
    <updated>2018-09-01T15:47:59.532Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1025/problem/B" target="_blank" rel="noopener">Codeforces Round #505 Weakened Common Divisor</a></p><p><strong>Description</strong></p><div class="note default"><p>During the research on properties of the greatest common divisor (GCD) of a set of numbers, Ildar, a famous mathematician, introduced a brand new concept of the weakened common divisor (WCD) of a list of pairs of integers.</p><p>For a given list of pairs of integers (a1,b1)(a1,b1), (a2,b2)(a2,b2), …, (an,bn)(an,bn) their WCD is arbitrary integer greater than 11, such that it divides at least one element in each pair. WCD may not exist for some lists.</p><p>For example, if the list looks like [(12,15),(25,18),(10,24)], then their WCD can be equal to 22, 33, 55 or 66 (each of these numbers is strictly greater than 11 and divides at least one number in each pair).</p><p>You’re currently pursuing your PhD degree under Ildar’s mentorship, and that’s why this problem was delegated to you. Your task is to calculate WCD efficiently.</p></div><a id="more"></a><p><strong>Input</strong></p><div class="note default"><p>The first line contains a single integer nn (1≤n≤150000) — the number of pairs.</p><p>Each of the next nn lines contains two integer values aiai, bibi (2≤ai,bi≤2⋅10^9).</p></div><p><strong>Output</strong></p><div class="note default"><p>Print a single integer — the WCD of the set of pairs.</p><p>If there are multiple possible answers, output any; if there is no answer, print −1−1.</p></div><p><strong>input</strong></p><blockquote><p>3<br>17 18<br>15 24<br>12 15  </p></blockquote><p><strong>output</strong></p><blockquote><p>6  </p></blockquote><p><strong>input</strong></p><blockquote><p>2<br>10 16<br>7 17  </p></blockquote><p><strong>output</strong></p><blockquote><p>-1  </p></blockquote><p><strong>input</strong></p><blockquote><p>5<br>90 108<br>45 105<br>75 40<br>165 175<br>33 30</p></blockquote><p><strong>output</strong></p><blockquote><p>5  </p></blockquote><p><strong>题意</strong><br><div class="note default"><p>大意是说给出n组数，每组两个数字。从每组数中取出一个数，求n组数的质因数。不存在则输出-1。  </p></div></p><p><strong>思路</strong><br><div class="note default"><p>假设给出一组数a b，a或b的质因数必然也是a*b的质因数。之后再枚举第一组数据的质因数即可。</p></div></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get_ans</span><span class="params">(ll n)</span><span class="comment">//为了防止最初的答案大于题目给出的数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll a,b,n,A,B;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">while</span> (--n)&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lld%lld"</span>,&amp;A,&amp;B);</span><br><span class="line">a = gcd(A*B,a);</span><br><span class="line">b = gcd(A*B,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,get_ans(a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,get_ans(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"-1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1025/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round #505 Weakened Common Divisor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;During the research on properties of the greatest common divisor (GCD) of a set of numbers, Ildar, a famous mathematician, introduced a brand new concept of the weakened common divisor (WCD) of a list of pairs of integers.&lt;/p&gt;
&lt;p&gt;For a given list of pairs of integers (a1,b1)(a1,b1), (a2,b2)(a2,b2), …, (an,bn)(an,bn) their WCD is arbitrary integer greater than 11, such that it divides at least one element in each pair. WCD may not exist for some lists.&lt;/p&gt;
&lt;p&gt;For example, if the list looks like [(12,15),(25,18),(10,24)], then their WCD can be equal to 22, 33, 55 or 66 (each of these numbers is strictly greater than 11 and divides at least one number in each pair).&lt;/p&gt;
&lt;p&gt;You’re currently pursuing your PhD degree under Ildar’s mentorship, and that’s why this problem was delegated to you. Your task is to calculate WCD efficiently.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="http://yoursite.com/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="基础数学" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>codeforces Round 49-Minimum Value Rectangle</title>
    <link href="http://yoursite.com/2018/08/20/Minimum%20Value%20Rectangle/"/>
    <id>http://yoursite.com/2018/08/20/Minimum Value Rectangle/</id>
    <published>2018-08-20T15:39:06.000Z</published>
    <updated>2018-09-01T15:42:54.252Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1027/problem/C" target="_blank" rel="noopener">C. Minimum Value Rectangle</a></p><p><strong>Problem Description</strong></p><p>You have n sticks of the given lengths.</p><p>Your task is to choose exactly four of them in such a way that they can form a rectangle. No sticks can be cut to pieces, each side of the rectangle must be formed by a single stick. No stick can be chosen multiple times. It is guaranteed that it is always possible to choose such sticks.</p><p>Let S be the area of the rectangle and P be the perimeter of the rectangle.</p><p>The chosen rectangle should have the value <em>P^2/S</em> minimal possible. The value is taken without any rounding.</p><p>If there are multiple answers, print any of them.</p><p>Each testcase contains several lists of sticks, for each of them you are required to solve the problem separately.<br><a id="more"></a><br><strong>Example</strong></p><blockquote><p>Input<br>3<br>4<br>7 2 2 7<br>8<br>2 8 1 4 8 2 1 5<br>5<br>5 5 5 5 5  </p></blockquote><blockquote><p>Output<br>2 7 7 2<br>2 2 1 1<br>5 5 5 5  </p></blockquote><p>大意就是说有T次查询，每次给出n条边，选出四条边组成一个矩形。然后P是其周长，S是面积现在求出P^2/S最小时，边长的组合。答案不唯一。每条边的边长不超过10^4。在所有的T次查询中，所有边的数量之和不会超过10^6。</p><p><strong>思路:</strong><br>由于矩形的定义就是四个角都是直角。所以可以假设边长为a，b。代入P^2/S中得 <strong>4*(a/b + b/a + 2)</strong> 其中 <strong>a/b + b/a</strong> 可以令 <strong>t = a/b</strong> 转化成 <strong>(t + 1/t)</strong> .这个这里可以得出当a == b时式子最小等于2。于是可以得出原式 <strong>&gt;=16</strong> 。并且我们可以看出去最小时a，b之间的关系是a和b尽可能的相等。于是这道题只需要排序之后把大于2的边拿出来。<strong>答案一定是排序之后两条长度相邻的边。</strong> 然后从小到大两两进行比较，找出最优解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> edg[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> temp[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    ++t;</span><br><span class="line">    <span class="keyword">while</span> (--t)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;edg[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort (edg,edg+n);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (edg[i] == edg[i<span class="number">-1</span>])&#123;<span class="comment">//如果有两条相等的边，就把它放入temp数组</span></span><br><span class="line">                temp[++cnt] = edg[i];</span><br><span class="line">                edg[i] = edg[i<span class="number">-1</span>] = <span class="number">-1</span>;<span class="comment">/*这一步是必须的，否则会误判边的数量</span></span><br><span class="line"><span class="comment">                如果edg有1 1 1.三个数，那么根据规律会有两个1被选入temp</span></span><br><span class="line"><span class="comment">                接下来的处理中就会使用两条边为 1和1来组成矩形。可实际上并没有四条长度为1的边。*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">double</span> Min = <span class="number">999989.0</span>;</span><br><span class="line">        <span class="keyword">double</span> t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt; ++i)&#123;</span><br><span class="line">            <span class="comment">//枚举两条相邻的边找出最优解</span></span><br><span class="line">            t = <span class="number">4</span> * (<span class="keyword">double</span>)(temp[i<span class="number">-1</span>]+temp[i]) * (<span class="keyword">double</span>)(temp[i<span class="number">-1</span>]+temp[i]) / (<span class="keyword">double</span>)(temp[i<span class="number">-1</span>]*temp[i]);</span><br><span class="line">            <span class="comment">//printf ("%d %d   %lf\n",temp[i],temp[i-1],t);</span></span><br><span class="line">            <span class="keyword">if</span> (Min &gt; t)&#123;</span><br><span class="line">                Min = t;</span><br><span class="line">                s = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d %d %d %d\n"</span>,temp[s],temp[s],temp[s<span class="number">-1</span>],temp[s<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1027/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C. Minimum Value Rectangle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You have n sticks of the given lengths.&lt;/p&gt;
&lt;p&gt;Your task is to choose exactly four of them in such a way that they can form a rectangle. No sticks can be cut to pieces, each side of the rectangle must be formed by a single stick. No stick can be chosen multiple times. It is guaranteed that it is always possible to choose such sticks.&lt;/p&gt;
&lt;p&gt;Let S be the area of the rectangle and P be the perimeter of the rectangle.&lt;/p&gt;
&lt;p&gt;The chosen rectangle should have the value &lt;em&gt;P^2/S&lt;/em&gt; minimal possible. The value is taken without any rounding.&lt;/p&gt;
&lt;p&gt;If there are multiple answers, print any of them.&lt;/p&gt;
&lt;p&gt;Each testcase contains several lists of sticks, for each of them you are required to solve the problem separately.&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="http://yoursite.com/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="基础数学" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>hdu-4081 Qin Shi Huang&#39;s National Road System(次小生成树)</title>
    <link href="http://yoursite.com/2018/08/17/hdu-4081/"/>
    <id>http://yoursite.com/2018/08/17/hdu-4081/</id>
    <published>2018-08-17T14:25:50.000Z</published>
    <updated>2018-08-17T16:13:05.896Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4081" target="_blank" rel="noopener">Qin Shi Huang’s National Road System</a><br><strong>Problem Description</strong></p><p>During the Warring States Period of ancient China(476 BC to 221 BC), there were seven kingdoms in China —- they were Qi, Chu, Yan, Han, Zhao, Wei and Qin. Ying Zheng was the king of the kingdom Qin. Through 9 years of wars, he finally conquered all six other kingdoms and became the first emperor of a unified China in 221 BC. That was Qin dynasty —- the first imperial dynasty of China(not to be confused with the Qing Dynasty, the last dynasty of China). So Ying Zheng named himself “Qin Shi Huang” because “Shi Huang” means “the first emperor” in Chinese.<br>Qin Shi Huang undertook gigantic projects, including the first version of the Great Wall of China, the now famous city-sized mausoleum guarded by a life-sized Terracotta Army, and a massive national road system. There is a story about the road system:<br>There were n cities in China and Qin Shi Huang wanted them all be connected by n-1 roads, in order that he could go to every city from the capital city Xianyang.<br>Although Qin Shi Huang was a tyrant, he wanted the total length of all roads to be minimum,so that the road system may not cost too many people’s life. A daoshi (some kind of monk) named Xu Fu told Qin Shi Huang that he could build a road by magic and that magic road would cost no money and no labor. But Xu Fu could only build ONE magic road for Qin Shi Huang. So Qin Shi Huang had to decide where to build the magic road. Qin Shi Huang wanted the total length of all none magic roads to be as small as possible, but Xu Fu wanted the magic road to benefit as many people as possible —- So Qin Shi Huang decided that the value of A/B (the ratio of A to B) must be the maximum, which A is the total population of the two cites connected by the magic road, and B is the total length of none magic roads.<br>Would you help Qin Shi Huang?<br>A city can be considered as a point, and a road can be considered as a line segment connecting two points.</p><a id="more"></a><p><strong>Input</strong></p><p>The first line contains an integer t meaning that there are t test cases(t &lt;= 10).<br>For each test case:<br>The first line is an integer n meaning that there are n cities(2 &lt; n &lt;= 1000).<br>Then n lines follow. Each line contains three integers X, Y and P ( 0 &lt;= X, Y &lt;= 1000, 0 &lt; P &lt; 100000). (X, Y) is the coordinate of a city and P is the population of that city.<br>It is guaranteed that each city has a distinct location.<br><strong>Output</strong></p><p>For each test case, print a line indicating the above mentioned maximum ratio A/B. The result should be rounded to 2 digits after decimal point.</p><p><strong>Sample Input</strong></p><p>2<br>4<br>1 1 20<br>1 2 30<br>200 2 80<br>200 1 100<br>3<br>1 1 20<br>1 2 30<br>2 2 40  </p><p><strong>Sample Output</strong></p><p>65.00<br>70.00</p><p>&emsp;&emsp;题意：给出一堆城市，现在要在每个城市修建公路。要求在公路总长度尽可能的短，并且连接所有的城市。然后这个城市都有一定的人口，现在有一个道士可以使得某条道路不花费任何资源直接变出来。现在要求是，假设这条变出来的道路所连接城市的人口是A ，总的道路长度减去变出来那条路的长度为B。求A/B的最大值，保证A/B最大的同时其他道路总长要求尽可能的短</p><p>&emsp;&emsp;思路：先求最小生成树，然后在题目给的无向图里面枚举每一条边，如果这条边没在生成树里面的话就暂时把它加进去，但是加进去的话生成树就会形成一个环。这时就要找出这个环里面的最大的边把它删掉，求出次小生成树。然后把最小生成树的总权值减去之后删掉的边就是B，那条加入的边连接的两点人数之和就是A。重复枚举边做这个过程找出最大的A/B。<br>&emsp;&emsp;这里关于prim算法有一个以前没注意到的细节，那就是prim算法每次确定下一条边的时候，这个确定的<strong>顺序一定是按照从根节点开始向下延伸的</strong>。<br>&emsp;&emsp;所以关于建树，用一个数组记录每次使用的边的前驱即可。假设low数组中求得的最小值位置为index，那么low[index]代表的是一条边，并且<strong>这个index代表的节点一定是这条边上更加远离根节点的</strong>。所以在下一步对生成树进行优化的时候。对于可被优化的low[p];<br>应令pre[p] = index;去记录前驱。<br>&emsp;&emsp;感觉这题最难的地方是由于新加入的边必定会连接A-B两个点。那么便要DP找出最小生成树上A-B两点之间的最大边以便将其删除。其状态转移方程如下：</p><blockquote><p>vis[j][index] = vis[index][j] = max(vis[j][pre[index]],low[index]);  </p></blockquote><p>&emsp;&emsp;在这个式子中，vis保存任意两点之间的最大边，pre是前驱。那么对于某一个节点j，<strong>当j是prim算法使用过的节点</strong>。那么，j到其他已经被确定的点之间的最大边必定是处理过的。又由于生成树的过程是从根节点开始延伸，所以只需要每次确定出index的时候遍历出v[j]，如果j被使用过，就比较index的前驱（这里pre[index]由于生成树的过程是从根节点开始延伸，所以与j之间的最长边必定被处理过）与index到pre[index]这条边就可以了。这里low[index]就是index-pre[index]这条边。这个DP还是比较难以理解的。</p><p><img src="https://raw.githubusercontent.com/Amannix/Amannix.github.io/master/images/blog_caption/hdu-4081.PNG" alt=""></p><p>&emsp;&emsp;如上图所示，vis所谓的两点之间最长边就是指如果我把7-9这条边加进去，那么3-6-9-7便形成环，所以我就要求出vis[7][9]–7到9之间的在原本还不是环的时候（也就是最小生成树上的）的最大边也就是6-9（权值为4）。这时我要求7-9的最大边，假设我当前index为7且9被使用过。那么比较pre[7]（也就是3）到9的最大边和7到3的边就OK了。再次重申由于最小生成树建树是从根节点开始延伸，所以index的前驱和其他被使用过的节点之间一定被处理过。  </p><p>&emsp;&emsp;有个坑点是在传统prim算法中，用index去优化low数组时，会加上一个条件是当前被优化的j节点没被使用过，但是这个条件不加上的话对于生成树的最后答案并无影响，可是却会对严重影响DP的过程，因为这个原因WA了好几发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> vis[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p;<span class="comment">//两城市之间人口</span></span><br><span class="line">    <span class="keyword">double</span> dis;<span class="comment">//城市之间距离</span></span><br><span class="line">&#125;ma[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> v;<span class="comment">//城市的人口</span></span><br><span class="line">&#125;point[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dis</span><span class="params">(Point a,Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>)(a.x-b.x)*(a.x-b.x)+(<span class="keyword">double</span>)(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;,pre[<span class="number">1005</span>];</span><br><span class="line">    <span class="keyword">double</span> dis[<span class="number">1005</span>],ans = <span class="number">0</span>;</span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        dis[i] = ma[<span class="number">1</span>][i].dis;<span class="comment">//1为根节点</span></span><br><span class="line">        pre[i] = <span class="number">1</span>;<span class="comment">//节点的前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((index == <span class="number">0</span> || dis[index] &gt; dis[j]) &amp;&amp; !v[j])&#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v[index] = <span class="number">1</span>;</span><br><span class="line">        ans += dis[index];</span><br><span class="line">        book[index][pre[index]] = book[pre[index]][index] = <span class="number">1</span>;<span class="comment">//记录被使用过的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (v[j] &amp;&amp; j != index)&#123;</span><br><span class="line">                <span class="comment">//这里一个DP找出生成树上任意两点间的最大边</span></span><br><span class="line">                vis[j][index] = vis[index][j] = max(vis[j][pre[index]],dis[index]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!v[j] &amp;&amp; dis[j] &gt; ma[index][j].dis)&#123;<span class="comment">//这里优化的时候!v[j]这个条件必须加上！！！！</span></span><br><span class="line">                dis[j] = ma[index][j].dis;</span><br><span class="line">                pre[j] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j)&#123;</span><br><span class="line">                ma[i][j].dis = ma[j][i].dis = Inf*<span class="number">1.0</span>;</span><br><span class="line">                ma[i][j].p = ma[j][i].p = Inf*<span class="number">1.0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ma[i][j].dis = ma[j][i].dis = Dis(point[i],point[j]);</span><br><span class="line">            ma[i][j].p = ma[j][i].p = point[i].v + point[j].v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">double</span> MST)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (book[i][j])&#123;<span class="comment">//如果当前遍历的边就在最小生成树上</span></span><br><span class="line">                    ans = max(ans,<span class="number">1.0</span>*(ma[i][j].p)/(MST - ma[i][j].dis));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = max(ans,<span class="number">1.0</span>*(ma[i][j].p)/(MST - vis[i][j]));<span class="comment">//如果不在</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="keyword">double</span> MST,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        ans = <span class="number">0</span>;<span class="comment">//又他娘的忘记初始化WA好几发-.-!</span></span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(book,<span class="number">0</span>,<span class="keyword">sizeof</span> book);</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">memset</span>(ma,<span class="number">0</span>,<span class="keyword">sizeof</span> ma);</span><br><span class="line">        <span class="built_in">memset</span>(point,<span class="number">0</span>,<span class="keyword">sizeof</span> point);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>,&amp;point[i].x,&amp;point[i].y,&amp;point[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">        create(n);</span><br><span class="line">        MST = prim(n);</span><br><span class="line">        ans = DP(n,MST);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%.2f\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4081&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Qin Shi Huang’s National Road System&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Problem Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;During the Warring States Period of ancient China(476 BC to 221 BC), there were seven kingdoms in China —- they were Qi, Chu, Yan, Han, Zhao, Wei and Qin. Ying Zheng was the king of the kingdom Qin. Through 9 years of wars, he finally conquered all six other kingdoms and became the first emperor of a unified China in 221 BC. That was Qin dynasty —- the first imperial dynasty of China(not to be confused with the Qing Dynasty, the last dynasty of China). So Ying Zheng named himself “Qin Shi Huang” because “Shi Huang” means “the first emperor” in Chinese.&lt;br&gt;Qin Shi Huang undertook gigantic projects, including the first version of the Great Wall of China, the now famous city-sized mausoleum guarded by a life-sized Terracotta Army, and a massive national road system. There is a story about the road system:&lt;br&gt;There were n cities in China and Qin Shi Huang wanted them all be connected by n-1 roads, in order that he could go to every city from the capital city Xianyang.&lt;br&gt;Although Qin Shi Huang was a tyrant, he wanted the total length of all roads to be minimum,so that the road system may not cost too many people’s life. A daoshi (some kind of monk) named Xu Fu told Qin Shi Huang that he could build a road by magic and that magic road would cost no money and no labor. But Xu Fu could only build ONE magic road for Qin Shi Huang. So Qin Shi Huang had to decide where to build the magic road. Qin Shi Huang wanted the total length of all none magic roads to be as small as possible, but Xu Fu wanted the magic road to benefit as many people as possible —- So Qin Shi Huang decided that the value of A/B (the ratio of A to B) must be the maximum, which A is the total population of the two cites connected by the magic road, and B is the total length of none magic roads.&lt;br&gt;Would you help Qin Shi Huang?&lt;br&gt;A city can be considered as a point, and a road can be considered as a line segment connecting two points.&lt;/p&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="http://yoursite.com/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="生成树" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="次小生成树" scheme="http://yoursite.com/tags/%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>POJ-1679 Unique MST(判断最小生成树是否唯一)</title>
    <link href="http://yoursite.com/2018/08/16/POJ-1679%20Unique%20MST/"/>
    <id>http://yoursite.com/2018/08/16/POJ-1679 Unique MST/</id>
    <published>2018-08-15T17:28:21.000Z</published>
    <updated>2018-08-15T16:33:24.009Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=1679" target="_blank" rel="noopener">POJ-1679 Unique MST</a>  </p><p><strong>Description</strong></p><p>Given a connected undirected graph, tell if its minimum spanning tree is unique. </p><p>Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: </p><ol><li>V’ = V. </li><li>T is connected and acyclic. </li></ol><p>Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’.<br><a id="more"></a><br><strong>Input</strong></p><p>The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. Each case represents a graph. It begins with a line containing two integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the following m lines contains a triple (xi, yi, wi), indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them.<br><strong>Output</strong></p><p>For each input, if the MST is unique, print the total cost of it, or otherwise print the string ‘Not Unique!’.<br><strong>Sample Input</strong></p><p>2<br>3 3<br>1 2 1<br>2 3 2<br>3 1 3<br>4 4<br>1 2 2<br>2 3 2<br>3 4 2<br>4 1 2<br><strong>Sample Output</strong></p><p>3<br>Not Unique!</p><p><strong>思路</strong><br>选择邻接矩阵存图，读取边的时候先判断是否存在两条相同的边，如果存在则MST不唯一。再做出最小生成树，将所有已经使用过的边，依次从邻接矩阵中删除，再求最小生成树<br>如果两次答案一致，则MST不唯一。不要忘记删除过的边要再放回去。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,e,v;</span><br><span class="line">&#125;edg[<span class="number">205</span>];<span class="comment">//记录最小生成树所包含的边的信息</span></span><br><span class="line"><span class="keyword">int</span> ma[<span class="number">205</span>][<span class="number">205</span>],cnt;<span class="comment">//cnt记录最小生成树的边的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">bool</span> bug)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v &gt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> cnt,<span class="keyword">int</span> n,<span class="keyword">int</span> ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(edg,edg+cnt,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cnt; ++i)&#123;</span><br><span class="line">        <span class="comment">/*将每条使用过的边都从邻接矩阵中删除，再求一次最小生成树，</span></span><br><span class="line"><span class="comment">        如果与之前相同，则MST不唯一*/</span></span><br><span class="line">        ma[edg[i].s][edg[i].e] = Inf;</span><br><span class="line">        ma[edg[i].e][edg[i].s] = Inf;</span><br><span class="line">        <span class="keyword">if</span> (prime(n,<span class="literal">false</span>) == ans)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不要忘了删掉的边要再添加回去</span></span><br><span class="line">        ma[edg[i].s][edg[i].e] = edg[i].v;</span><br><span class="line">        ma[edg[i].e][edg[i].s] = edg[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">bool</span> bug)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">205</span>] = &#123;<span class="number">0</span>&#125;,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bug)&#123;<span class="comment">//bug变量标记在judge函数中调用不需要对edg做修改</span></span><br><span class="line">        <span class="built_in">memset</span>(edg,<span class="number">0</span>,<span class="keyword">sizeof</span> edg);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node temp[<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        temp[i].v = ma[<span class="number">1</span>][i];</span><br><span class="line">        temp[i].s = <span class="number">1</span>;</span><br><span class="line">        temp[i].e  = i;</span><br><span class="line">        <span class="comment">//printf ("%d\n",temp[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>,Min = Inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (Min &gt; temp[j].v &amp;&amp; !vis[j])&#123;</span><br><span class="line">                Min = temp[j].v;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bug)</span><br><span class="line">            edg[cnt++] = temp[index];</span><br><span class="line">        vis[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//printf ("%d\n",index);</span></span><br><span class="line">        ans += temp[index].v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[j].v &gt; ma[index][j])&#123;</span><br><span class="line">                temp[j].v = ma[index][j];</span><br><span class="line">                temp[j].s = index;</span><br><span class="line">                temp[j].e = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,m,n,a,b,c,ans;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ma,Inf,<span class="keyword">sizeof</span> ma);</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="keyword">if</span> (c == ma[a][b])&#123;<span class="comment">//判断是否存在两条相同的边。</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ma[a][b] = min(ma[a][b],c);<span class="comment">//每条边只取最小值</span></span><br><span class="line">            ma[b][a] = min(ma[b][a],c);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = prime(n,<span class="literal">true</span>);</span><br><span class="line">        judge(cnt,n,ans);</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"Not Unique!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=1679&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-1679 Unique MST&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a connected undirected graph, tell if its minimum spanning tree is unique. &lt;/p&gt;
&lt;p&gt;Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;V’ = V. &lt;/li&gt;
&lt;li&gt;T is connected and acyclic. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’.&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="http://yoursite.com/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小生成树" scheme="http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PID算法小结</title>
    <link href="http://yoursite.com/2018/08/15/PID%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/15/PID算法小结/</id>
    <published>2018-08-15T08:25:21.000Z</published>
    <updated>2018-08-15T14:02:05.742Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在控制算法系统中，先设定一个目标值假设为S，再由传感器定时采样。假设读取的值为依次为X1，X2，X3……Xk。</p><a id="more"></a><h3 id="P-比例-控制"><a href="#P-比例-控制" class="headerlink" title="P(比例)控制:"></a>P(比例)控制:</h3><p>&emsp;&emsp;假设对每次采样的结果Xk，使<strong>Pk = S - Xk</strong>。其产生三种结果</p><blockquote><p>Pk &gt; 0  当前值未达标<br>Pk == 0  当前值已达标<br>Pk &lt; 0  当前值超标</p></blockquote><p>&emsp;&emsp;则在P控制中，<strong>TOUT = Kp * Pk</strong>，其中Kp为常数，起到一个等比例放大或缩小的作用<br>Pk实际意义便是与目标的差值，P控制的输出量由这个差值等比例放大决定。</p><h3 id="I-积分-控制"><a href="#I-积分-控制" class="headerlink" title="I(积分)控制"></a>I(积分)控制</h3><p>&emsp;&emsp;假设<strong>Sk = ∑Pn （n ∈[1,k]）</strong>。同样的，由于Pk的值有正有负。因此Sk的值也分为三种情况</p><blockquote><p>Sk &gt; 0  在过去的时间内，系统总体上是不达标的<br>Sk == 0   在过去的时间内，系统总体上是达标的<br>Sk &lt; 0   在过去的时间内，系统总体上是超标的</p></blockquote><p>&emsp;&emsp;此时<strong>TOUT = Kp * Sk</strong> 对应的是积分操作，由过去历史总体情况作出预测。缺点是较长时间之前的<br>数据也会对现在的预测产生影响。</p><h3 id="D-微分-控制"><a href="#D-微分-控制" class="headerlink" title="D(微分)控制"></a>D(微分)控制</h3><p>&emsp;&emsp;由于之前已经取得了每个采集样本的Pk值，即采集值与目标值的偏移量，使<strong>Dk = Pk - P(k-1)</strong><br>则Dk描述了此偏移量的变化的快慢。同样分为三种结果</p><blockquote><p>Dk &gt; 0<br>Dk == 0<br>Dk &lt; 0  </p></blockquote><p>&emsp;&emsp;此时的TOUT = Kp * Dk，显而易见这时的输出量由变化率决定。变化率越大，则输出值越大</p><h3 id="PID的数学模型"><a href="#PID的数学模型" class="headerlink" title="PID的数学模型"></a>PID的数学模型</h3><p>&emsp;&emsp;基于上式，最后输出值<strong>TOUT = Pout + Iout + Dout</strong><br>代入合并之后 <strong>Tout = (Kp <em> Pk) + (Kp </em> Sk) + (Kp * Dk)</strong></p><p>(关于Sk Dk的处理下次在写叭)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在控制算法系统中，先设定一个目标值假设为S，再由传感器定时采样。假设读取的值为依次为X1，X2，X3……Xk。&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式算法" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PID" scheme="http://yoursite.com/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>牛客网练习赛24-B凤凰</title>
    <link href="http://yoursite.com/2018/08/12/%E7%BB%83%E4%B9%A0%E8%B5%9B24-B%E5%87%A4%E5%87%B0/"/>
    <id>http://yoursite.com/2018/08/12/练习赛24-B凤凰/</id>
    <published>2018-08-11T17:28:21.000Z</published>
    <updated>2018-08-15T16:33:02.279Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.nowcoder.com/acm/contest/157/B" target="_blank" rel="noopener">牛客网练习赛24-B凤凰</a></p><p><strong>Describe</strong></p><blockquote><p>凤凰于飞，翙翙其羽，亦集爰止。<br>《诗经·卷阿》<br>传说，凤凰是百鸟之王。有一天，凤凰要召开百鸟大会，百鸟国是一个由n个节点组成的树，每个节点有一只鸟，开会的节点定在1号节点。每只鸟可以花费1s通过一条边，由于每根树枝(边)的载重有限，只允许一只鸟同时通过。作为会议的策划师，HtBest想知道百鸟国的所有鸟在1点集合最少需要多少秒。  </p></blockquote><a id="more"></a><p><strong>Input</strong></p><blockquote><p>第一行有一个正整数n，表示百鸟国节点个数。<br>接下来n-1行，第i行两个正整数ai,bi用空格隔开，表示树上节点ai,bi之间有一条边。</p></blockquote><p><strong>Output</strong></p><blockquote><p>第一行一个整数，表示集合最少需要的时间。</p></blockquote><p><strong>Example1</strong></p><blockquote><p>Input<br>3<br>1 2<br>2 3<br>Output<br>2</p></blockquote><p><strong>Example2</strong></p><blockquote><p>Input<br>3<br>1 2<br>1 3<br>Output<br>1</p></blockquote><p><strong>Example3</strong></p><blockquote><p>Input<br>4<br>1 2<br>2 3<br>2 4<br>Output<br>3</p></blockquote><p><strong>Remark</strong></p><blockquote><p>对于100%的测试数据：<br>1 ≤ n ≤ 1000000<br>数据量较大，注意使用更快的输入输出方式。</p></blockquote><p>&emsp;&emsp;首先明确每一个节点上都存在一只鸟，假设存在n条通往根节点（1）的路径。因此可以得到有n颗子树挂载在根节点上，不难发现所有子树上如果有m只鸟那么想要全部到达根节点必定要花费m秒。<br>&emsp;&emsp;由于每一个节点必定存在一只鸟，因此不难证明不存在子树上有某只鸟还没通过靠近根节点路径，但是其他鸟已经全部抵达的情况。还有就是题目明确指出是树形结构，所以也不存在一颗子树存在两条通往根节点的路径的情况，否则便是图形结构。<br>&emsp;&emsp;因此题目转化为求最大子树的节点数。两种思路可广搜遍历子树求得节点数，更为便捷的方式是并查集求解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ll F[maxn],sum[maxn];</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == F[u] ? u : F[u] = find(F[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_union</span><span class="params">(ll u,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x = find(u),y = find(v);</span><br><span class="line">    <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">        F[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cnt;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;cnt);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= cnt; ++i)&#123;</span><br><span class="line">        F[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt; cnt; ++i)&#123;</span><br><span class="line">        ll a,b;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%lld%lld"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">1</span> &amp;&amp; b != <span class="number">1</span>)<span class="comment">//由于题目给出的是整颗数，所以要排除根节点以外求子树</span></span><br><span class="line">            fun_union(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= cnt; ++i)&#123;</span><br><span class="line">        ++sum[F[find(i)]];<span class="comment">//求不同子树的节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,*max_element(sum+<span class="number">1</span>,sum+cnt+<span class="number">1</span>));<span class="comment">//该函数求区间内最大值，返回一个指针。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/157/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网练习赛24-B凤凰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Describe&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;凤凰于飞，翙翙其羽，亦集爰止。&lt;br&gt;《诗经·卷阿》&lt;br&gt;传说，凤凰是百鸟之王。有一天，凤凰要召开百鸟大会，百鸟国是一个由n个节点组成的树，每个节点有一只鸟，开会的节点定在1号节点。每只鸟可以花费1s通过一条边，由于每根树枝(边)的载重有限，只允许一只鸟同时通过。作为会议的策划师，HtBest想知道百鸟国的所有鸟在1点集合最少需要多少秒。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="http://yoursite.com/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
