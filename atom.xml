<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiong&#39;blog</title>
  
  <subtitle>渡得八千风沙起，揽下九天明月心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://amannix.github.io/"/>
  <updated>2018-11-11T02:48:55.832Z</updated>
  <id>https://amannix.github.io/</id>
  
  <author>
    <name>熊梦彪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Curiosity Has No Limits(搜索)</title>
    <link href="https://amannix.github.io/2018/11/11/Curiosity%20Has%20No%20Limits/"/>
    <id>https://amannix.github.io/2018/11/11/Curiosity Has No Limits/</id>
    <published>2018-11-11T02:36:45.000Z</published>
    <updated>2018-11-11T02:48:55.832Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1031/problem/B" target="_blank" rel="noopener">Technocup 2019 - Elimination Round 2 B.Curiosity Has No Limits</a><br><strong>Description</strong><br><div class="note default"><p>When Masha came to math classes today, she saw two integer sequences of length n−1n−1 on the blackboard. Let’s denote the elements of the first sequence as ai (0≤ai≤3), and the elements of the second sequence as bi (0≤bi≤3).</p><p>Masha became interested if or not there is an integer sequence of length nn, which elements we will denote as ti (0≤ti≤3), so that for every i (1≤i≤n−1) the following is true:</p><blockquote><p>ai=ti|t(i+1) and bi=ti&amp;t(i+1)</p></blockquote><p>The question appeared to be too difficult for Masha, so now she asked you to check whether such a sequence ti of length n exists. If it exists,find such a sequence. If there are multiple such sequences, find any of them.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains a single integer n (2≤n≤10^5) — the length of the sequence ti.<br>The second line contains n−1n−1 integers a1,a2,…,an−1a1,a2,…,an−1 (0≤ai≤3) — the first sequence on the blackboard.<br>The third line contains n−1n−1 integers b1,b2,…,bn−1b1,b2,…,bn−1 (0≤bi≤3) — the second sequence on the blackboard.  </p></div><br><strong>Output</strong><br><div class="note default"><p>In the first line print “YES” (without quotes), if there is a sequence ti that satisfies the conditions from the statements, and “NO” (without quotes), if there is no such sequence.<br>If there is such a sequence, on the second line print nn integers t1,t2,…,tn (0≤ti≤3) — the sequence that satisfies the statements conditions.<br>If there are multiple answers, print any of them.  </p></div><br><strong>Sample Input</strong></p><blockquote><p>4<br>3 3 2<br>1 2 0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>YES<br>1 3 2 0</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>3<br>1 3<br>3 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>NO</p></blockquote><p><strong>Thinking</strong><br>给出两个数列，每个元素只由0 1 2 3组成。要求构造第三个数列t，使得满足ai=ti|t(i+1) and bi=ti&amp;t(i+1)。答案给的是找规律的解法，但是有一种解法是深搜剪枝可解。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">100010</span>],a[<span class="number">100010</span>],b[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == n)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (flag)<span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (((k|i) == a[pos]) &amp;&amp; ((k&amp;i) == b[pos]))&#123;</span><br><span class="line">buf[pos+<span class="number">1</span>] = i;</span><br><span class="line">bfs(pos+<span class="number">1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>; ++i)&#123;</span><br><span class="line">buf[<span class="number">1</span>] = i;</span><br><span class="line">bfs(<span class="number">1</span>,i);</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1031/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Technocup 2019 - Elimination Round 2 B.Curiosity Has No Limits&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;When Masha came to math classes today, she saw two integer sequences of length n−1n−1 on the blackboard. Let’s denote the elements of the first sequence as ai (0≤ai≤3), and the elements of the second sequence as bi (0≤bi≤3).&lt;/p&gt;
&lt;p&gt;Masha became interested if or not there is an integer sequence of length nn, which elements we will denote as ti (0≤ti≤3), so that for every i (1≤i≤n−1) the following is true:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ai=ti|t(i+1) and bi=ti&amp;amp;t(i+1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The question appeared to be too difficult for Masha, so now she asked you to check whether such a sequence ti of length n exists. If it exists,find such a sequence. If there are multiple such sequences, find any of them.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="搜索" scheme="https://amannix.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LCM (分解定理求约数的个数)</title>
    <link href="https://amannix.github.io/2018/11/11/LCM/"/>
    <id>https://amannix.github.io/2018/11/11/LCM/</id>
    <published>2018-11-11T02:01:32.000Z</published>
    <updated>2018-11-11T02:35:54.810Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1068/problem/B" target="_blank" rel="noopener">Codeforces Round 518 (Div. 2) B.LCM</a><br><strong>Description</strong><br><div class="note default"><p>Ivan has number b. He is sorting through the numbers aa from 1 to 10^18, and for every aa writes [a,b]/a on blackboard. Here [a,b] stands for least common multiple of aa and bb. Ivan is very lazy, that’s why this task bored him soon. But he is interested in how many different numbers he would write on the board if he would finish the task. Help him to find the quantity of different numbers he would write on the board.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The only line contains one integer — b (1≤b≤10^10).</p></div><br><strong>Output</strong><br><div class="note default"><p>Print one number — answer for the problem.</p></div><br><strong>Sample Input</strong></p><blockquote><p>1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2</p></blockquote><p><strong>Thinking</strong><br>给出一个数字b，然后求[a,b]/a，的不同取值有多少种，[a,b]值最小公倍数。这里有(a*b)/gcd(a,b) == [a,b]。原式转化为b/gcd(a,b)。当分母gcd(a,b)&gt;b的时候，取值唯一变成0，实际上也永远不可能大于b。因此答案就变成了求b的约数的个数。可以线性遍历求出约数个数，复杂度为O(sqrt(b))。但这里利用唯一分解定理。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> isprime[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100000</span>; ++i)&#123;</span><br><span class="line">isprime[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i*i &lt;= <span class="number">100000</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i*i;j &lt;= <span class="number">100000</span>; j += i)&#123;</span><br><span class="line">isprime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100000</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i])&#123;</span><br><span class="line">prime[index++] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">get_prime();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> total;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;total);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[i] &gt; total)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (total % prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span> (total%prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">++num;</span><br><span class="line">total /= prime[i];</span><br><span class="line">&#125;</span><br><span class="line">ans *= (num + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (total &gt; <span class="number">1</span>)&#123;<span class="comment">//这判断最后一次除法是否将其整除</span></span><br><span class="line">ans *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1068/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round 518 (Div. 2) B.LCM&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Ivan has number b. He is sorting through the numbers aa from 1 to 10^18, and for every aa writes [a,b]/a on blackboard. Here [a,b] stands for least common multiple of aa and bb. Ivan is very lazy, that’s why this task bored him soon. But he is interested in how many different numbers he would write on the board if he would finish the task. Help him to find the quantity of different numbers he would write on the board.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="https://amannix.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>HDU-3085 Nightmare Ⅱ(双向搜索)</title>
    <link href="https://amannix.github.io/2018/11/11/HDU-3085%20Nightmare%20%E2%85%A1/"/>
    <id>https://amannix.github.io/2018/11/11/HDU-3085 Nightmare Ⅱ/</id>
    <published>2018-11-11T01:43:50.000Z</published>
    <updated>2018-11-11T02:01:25.261Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3085" target="_blank" rel="noopener">HDU-3085 Nightmare Ⅱ</a><br><strong>Description</strong><br><div class="note default"><p>Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.<br>You may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.<br>Note: the new ghosts also can devide as the original ghost.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The input starts with an integer T, means the number of test cases.<br>Each test case starts with a line contains two integers n and m, means the size of the maze. (1&lt;n, m&lt;800)<br>The next n lines describe the maze. Each line contains m characters. The characters may be:<br>‘.’ denotes an empty place, all can walk on.<br>‘X’ denotes a wall, only people can’t walk on.<br>‘M’ denotes little erriyue<br>‘G’ denotes the girl friend.<br>‘Z’ denotes the ghosts.<br>It is guaranteed that will contain exactly one letter M, one letter G and two letters Z.</p></div><br><strong>Output</strong><br><div class="note default"><p>Output a single integer S in one line, denotes erriyue and his girlfriend will meet in the minimum time S if they can meet successfully, or output -1 denotes they failed to meet.</p></div><br><strong>Sample Input</strong><br><div class="note default"><p>3<br>5 6<br>XXXXXX<br>XZ..ZX<br>XXXXXX<br>M.G…<br>……<br>5 6<br>XXXXXX<br>XZZ..X<br>XXXXXX<br>M…..<br>..G…</p><p>10 10<br>……….<br>..X…….<br>..M.X…X.<br>X………<br>.X..X.X.X.<br>………X<br>..XX….X.<br>X….G…X<br>…ZX.X…<br>…Z..X..X</p></div><br><strong>Sample Output</strong><br><div class="note default"><p>1<br>1<br>-1</p></div></p><p><strong>Thinking</strong><br>在一个迷宫上面两只鬼，以及erriyue和他女朋友，每轮鬼先分裂出两个填充其他格子，然后erriyue走三步，他女朋友走一步。鬼分裂出的鬼又可以再分裂，直到填充所有空间，判断M是否能够找到他女朋友。<br>双向搜索，从M和G两边开始，由于M可以走三步，在走的过程中还需要一次判断是否路径合法，并且这三步有多种可走的方法，所以只能把三步分成三次搜索。与鬼的判断只需要判断走的回合数乘以2是否大于角色与鬼初始位置的哈曼顿距离。将M，G的路径标记，如果出现重合即两人到达。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">880</span>][<span class="number">880</span>];</span><br><span class="line"><span class="keyword">int</span> t, n, m, step;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;gg, mm, zz[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;q[<span class="number">2</span>], qt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isok</span><span class="params">(node t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t.x&lt;<span class="number">1</span> || t.x&gt;n || t.y&lt;<span class="number">1</span> || t.y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断越界可以先填充0</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(t.x-zz[i].x)+<span class="built_in">abs</span>(t.y-zz[i].y)&lt;=<span class="number">2</span>*step || str[t.x][t.y]==<span class="string">'X'</span> || str[t.x][t.y]==<span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> mark, <span class="keyword">int</span> num, <span class="keyword">char</span> start, <span class="keyword">char</span> endd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node a, b;</span><br><span class="line">    qt=q[mark];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">    &#123;<span class="comment">/*主要是这里，用了一个中间队列，限制了搜索起点的范围这样就确保了只搜索num步*/</span></span><br><span class="line">        <span class="keyword">while</span>(!qt.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            a=qt.front(), qt.pop(), q[mark].pop();<span class="comment">//很坑的就是M不一定就是只能走三步，而是小于等于三步</span></span><br><span class="line">            <span class="keyword">if</span>(!isok(a)) <span class="keyword">continue</span>;<span class="comment">//鬼先走，每增加一步，先判断鬼能不能把人吃掉</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                b = a;</span><br><span class="line">                b.x+=f[i][<span class="number">0</span>], b.y+=f[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(!isok(b)||str[b.x][b.y]==start) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(str[b.x][b.y]==endd) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//其中一个人到达了另一个人曾经到达的地方，两人相遇了</span></span><br><span class="line">                str[b.x][b.y]=start;<span class="comment">//标记已经走过的地方</span></span><br><span class="line">                q[mark].push(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        qt=q[mark];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">0</span>].empty()) q[<span class="number">0</span>].pop();</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">1</span>].empty()) q[<span class="number">1</span>].pop();</span><br><span class="line">    <span class="keyword">while</span>(!qt.empty()) qt.pop();</span><br><span class="line">    q[<span class="number">0</span>].push(mm), q[<span class="number">1</span>].push(gg);</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">0</span>].empty() &amp;&amp; !q[<span class="number">1</span>].empty())<span class="comment">//用了两个队列维护一步之内走的范围，</span></span><br><span class="line">    &#123;</span><br><span class="line">        step++;<span class="comment">//枚举走的步数，</span></span><br><span class="line">        <span class="keyword">bool</span> flag1 = bfs(<span class="number">0</span>,<span class="number">3</span>,<span class="string">'M'</span>,<span class="string">'G'</span>);<span class="comment">//每次bfs只仅仅走一步</span></span><br><span class="line">        <span class="keyword">bool</span> flag2 = bfs(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'G'</span>,<span class="string">'M'</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag1||flag2) <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">memset</span>(str,<span class="string">'X'</span>,<span class="keyword">sizeof</span>(str));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>,i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i][j]==<span class="string">'M'</span>) mm.x=i, mm.y=j;</span><br><span class="line">                <span class="keyword">if</span>(str[i][j]==<span class="string">'G'</span>) gg.x=i, gg.y=j;</span><br><span class="line">                <span class="keyword">if</span>(str[i][j]==<span class="string">'Z'</span>) zz[k].x=i, zz[k].y=j, k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3085&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU-3085 Nightmare Ⅱ&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.&lt;br&gt;You may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.&lt;br&gt;Note: the new ghosts also can devide as the original ghost.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="搜索" scheme="https://amannix.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>DNA sequence(IDA*)</title>
    <link href="https://amannix.github.io/2018/11/11/HDU-1560%20DNA%20sequence/"/>
    <id>https://amannix.github.io/2018/11/11/HDU-1560 DNA sequence/</id>
    <published>2018-11-11T01:30:55.000Z</published>
    <updated>2018-11-11T01:45:09.357Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1560" target="_blank" rel="noopener">HDU - 1560 DNA sequence</a><br><strong>Description</strong><br><div class="note default"><p>The twenty-first century is a biology-technology developing century. We know that a gene is made of DNA. The nucleotide bases from which DNA is built are A(adenine), C(cytosine), G(guanine), and T(thymine). Finding the longest common subsequence between DNA/Protein sequences is one of the basic problems in modern computational molecular biology. But this problem is a little different. Given several DNA sequences, you are asked to make a shortest sequence from them so that each of the given sequence is the subsequence of it.</p><p>For example, given “ACGT”,”ATGC”,”CGTT” and “CAGT”, you can make a sequence in the following way. It is the shortest but may be not the only one.<br><img src="https://vj.e949.cn/484ac84a1e7eb5b60c2d9f0ac6e356c7?v=1541632888" alt=""></p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line is the test case number t. Then t test cases follow. In each case, the first line is an integer n ( 1&lt;=n&lt;=8 ) represents number of the DNA sequences. The following k lines contain the k sequences, one per line. Assuming that the length of any sequence is between 1 and 5.</p></div><br><strong>Output</strong><br><div class="note default"><p>For each test case, print a line containing the length of the shortest sequence that can be made from these sequences.</p></div><br><strong>Sample Input</strong></p><blockquote><p>1<br>4<br>ACGT<br>ATGC<br>CGTT<br>CAGT  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>8</p></blockquote><p><strong>Thinking</strong><br>给出N组DNA的序列，求构造一个序列使得每组DNA序列都能够按照原来的顺序在新序列中匹配，注意并不是子串的关系。<br>IDA*搜索构造新串，先枚举搜索深度，按照这个搜索深度，只要超出该深度则回溯。并且每次计算最少还需搜索的长度加上当前搜索的长度超过了预计长度也回溯。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IDA*</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,deep,ans;</span><br><span class="line"><span class="keyword">int</span> size[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> dna[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">4</span>] = &#123;<span class="string">'A'</span>,<span class="string">'C'</span>,<span class="string">'G'</span>,<span class="string">'T'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> len[])</span><span class="comment">//len也是当前匹配到的位置，但是通过两个数组交替使回溯的值可保持原样</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k &gt; deep)<span class="keyword">return</span> ;<span class="comment">//深度大于预期深度则回溯</span></span><br><span class="line"><span class="keyword">int</span> maxx = <span class="number">0</span>;<span class="comment">//找出当前还需匹配的最少数目</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (size[i]-len[i] &gt; maxx)&#123;</span><br><span class="line"><span class="keyword">if</span> (maxx &lt; size[i]-len[i])</span><br><span class="line">maxx = size[i]-len[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxx == <span class="number">0</span>)&#123;<span class="comment">//如果当前没有需要匹配的则得到答案</span></span><br><span class="line">ans = k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k + maxx &gt; deep)&#123;<span class="comment">//最少匹配数加上当前深度大于预期深度则回溯</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//记录当前字符串已经匹配到的位置</span></span><br><span class="line"><span class="keyword">if</span> (ans != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;<span class="comment">//与每一个字符串进行匹配</span></span><br><span class="line"><span class="keyword">if</span> (dna[j][len[j]] == ch[i])&#123;</span><br><span class="line">pos[j] = len[j] + <span class="number">1</span>;<span class="comment">//改变当前已匹配的位置</span></span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pos[j] = len[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;<span class="comment">//必须发生过一个匹配才继续深搜</span></span><br><span class="line">dfs(k+<span class="number">1</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T,maxn = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)&#123;</span><br><span class="line">maxn = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">getchar ();</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>,dna[i]);</span><br><span class="line">size[i] = <span class="built_in">strlen</span>(dna[i]);</span><br><span class="line"><span class="keyword">if</span> (size[i] &gt; maxn)maxn = size[i];</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">-1</span>;</span><br><span class="line">deep = maxn;<span class="comment">//迭代加深的起点</span></span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">dfs(<span class="number">0</span>,pos);</span><br><span class="line"><span class="keyword">if</span> (ans != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">deep++;<span class="comment">//迭代加深</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU - 1560 DNA sequence&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;The twenty-first century is a biology-technology developing century. We know that a gene is made of DNA. The nucleotide bases from which DNA is built are A(adenine), C(cytosine), G(guanine), and T(thymine). Finding the longest common subsequence between DNA/Protein sequences is one of the basic problems in modern computational molecular biology. But this problem is a little different. Given several DNA sequences, you are asked to make a shortest sequence from them so that each of the given sequence is the subsequence of it.&lt;/p&gt;
&lt;p&gt;For example, given “ACGT”,”ATGC”,”CGTT” and “CAGT”, you can make a sequence in the following way. It is the shortest but may be not the only one.&lt;br&gt;&lt;img src=&quot;https://vj.e949.cn/484ac84a1e7eb5b60c2d9f0ac6e356c7?v=1541632888&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="搜索" scheme="https://amannix.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Vasya and Robot(二分)</title>
    <link href="https://amannix.github.io/2018/11/07/Vasya%20and%20Robot/"/>
    <id>https://amannix.github.io/2018/11/07/Vasya and Robot/</id>
    <published>2018-11-07T15:57:29.000Z</published>
    <updated>2018-11-08T04:09:27.317Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1073/problem/C" target="_blank" rel="noopener">Educational Codeforces Round 53</a><br><strong>Description</strong><br><div class="note default"><p>Vasya has got a robot which is situated on an infinite Cartesian plane, initially in the cell (0,0). Robot can perform the following four kinds of operations:</p><blockquote><p>U — move from (x,y)(x,y) to (x,y+1)(x,y+1);<br>D — move from (x,y)(x,y) to (x,y−1)(x,y−1);<br>L — move from (x,y)(x,y) to (x−1,y)(x−1,y);<br>R — move from (x,y)(x,y) to (x+1,y)(x+1,y).</p></blockquote><p>Vasya also has got a sequence of n operations. Vasya wants to modify this sequence so after performing it the robot will end up in (x,y)<br>Vasya wants to change the sequence so the length of changed subsegment is minimum possible. This length can be calculated as follows: maxID−minID+1, where maxID is the maximum index of a changed operation, and minID is the minimum index of a changed operation. For example, if Vasya changes RRRRRRR to RLRRLRL, then the operations with indices 2, 5 and 7 are changed, so the length of changed subsegment is 7−2+1=6. Another example: if Vasya changes DDDD to DDRD, then the length of changed subsegment is 1.</p><p>If there are no changes, then the length of changed subsegment is 0. Changing an operation means replacing it with some operation (possibly the same); Vasya can’t insert new operations into the sequence or remove them.</p><p>Help Vasya! Tell him the minimum length of subsegment that he needs to change so that the robot will go from (0,0) to (x,y), or tell him that it’s impossible.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains one integer number n (1≤n≤2⋅105) — the number of operations.</p><p>The second line contains the sequence of operations — a string of n characters. Each character is either U, D, L or R.</p><p>The third line contains two integers x,y (−109≤x,y≤109) — the coordinates of the cell where the robot should end its path.</p></div><br><strong>Output</strong><br><div class="note default"><p>Print one integer — the minimum possible length of subsegment that can be changed so the resulting sequence of operations moves the robot from (0,0) to (x,y). If this change is impossible, print −1.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>RURUU<br>-2 3  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>3</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>4<br>RULR<br>1 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0</p></blockquote><p><strong>Thinking</strong><br>给出一个字符串，只由UDLR组成，代表了从(0,0)开始的移动轨迹，再给出一个坐标，求在这个移动操作的字符串中，能否更改一段区间，使得通过这个新操作可以到达目的地，求最小改变区间。首先一个结论就是看这个操作次数，操作次数一定要等于目标点到原点的哈曼顿距离，在大于的情况下，可以两两抵消使得操作数变少最后等于目标点到原点的哈曼顿距离，因此必须先特判操作次数需与哈曼顿距离的奇偶性相同。接着就是求最小改变区间。可以根据哈曼顿距离的奇偶性来暴力枚举区间长度。但是也会TLE，由于其改变的区间长度最大必定是整个操作数，最小为0.所以只需要在0到n之间找到一个最佳枚举区间，因此可以二分区间长度，如果mid是一个合理的区间就向下搜索，如果不合理就向上搜索。每二分到一个区间长度，就从1开始遍历区间位置逐一判断，此时需要先将每一个操作对应的坐标偏移量求出前缀和，然后将每一个对应的长度的区间所做的偏移全部删去，更新终点位置，最后计算终点位置与目标位置的哈曼顿距离，然后根据上面的同样的方法，用操作次数和奇偶性来判断是否更改的区间合理。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> x,y;</span><br><span class="line">&#125;buf[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">long</span> l,r,mid;</span><br><span class="line"><span class="keyword">long</span> dis;</span><br><span class="line"><span class="keyword">long</span> x,y;</span><br><span class="line"><span class="keyword">long</span> n,ans = <span class="number">99999</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>;i &lt;= n-mid; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> a = buf[i+mid].x-buf[i].x,b = buf[i+mid].y-buf[i].y;</span><br><span class="line">        <span class="comment">//计算mid区间内偏移量是多少</span></span><br><span class="line">        <span class="keyword">long</span> temp_x = buf[n].x - a,temp_y = buf[n].y - b;</span><br><span class="line">        <span class="comment">//最后总的长度减去偏移量，重新计算终点坐标</span></span><br><span class="line">        <span class="keyword">long</span> cut = mid,temp_dis = <span class="built_in">abs</span>(x-temp_x) + <span class="built_in">abs</span>(y-temp_y);</span><br><span class="line">        <span class="comment">//计算终点到目标点的哈曼顿距离。</span></span><br><span class="line">        <span class="keyword">if</span> (cut - temp_dis &gt;= <span class="number">0</span> &amp;&amp; cut%<span class="number">2</span> == temp_dis%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//同样的方法判断是否能够到达目标</span></span><br><span class="line">            ans = min(ans,cut);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%ld"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%s"</span>,str);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%ld%ld"</span>,&amp;x,&amp;y);</span><br><span class="line">    dis = <span class="built_in">abs</span>(x)+<span class="built_in">abs</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; n || n%<span class="number">2</span> != dis%<span class="number">2</span>)&#123;<span class="comment">/*如果总步数都无法走到就直接输出-1</span></span><br><span class="line"><span class="comment">            但是所有能走到的前提都是总步数和距离的长度的奇偶性的相同*/</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;<span class="comment">//求偏移值量前缀和</span></span><br><span class="line">        <span class="keyword">switch</span> (str[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>:buf[i+<span class="number">1</span>].y = buf[i].y+<span class="number">1</span>;buf[i+<span class="number">1</span>].x = buf[i].x;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:buf[i+<span class="number">1</span>].y = buf[i].y<span class="number">-1</span>;buf[i+<span class="number">1</span>].x = buf[i].x;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:buf[i+<span class="number">1</span>].x = buf[i].x<span class="number">-1</span>;buf[i+<span class="number">1</span>].y = buf[i].y;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'R'</span>:buf[i+<span class="number">1</span>].x = buf[i].x+<span class="number">1</span>;buf[i+<span class="number">1</span>].y = buf[i].y;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = n;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = n<span class="number">-1</span>;</span><br><span class="line">    mid =(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;<span class="comment">//二分搜索区间</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid))&#123;<span class="comment">//如果mid是一个符合的区间就小的方向搜索</span></span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%ld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1073/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Educational Codeforces Round 53&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Vasya has got a robot which is situated on an infinite Cartesian plane, initially in the cell (0,0). Robot can perform the following four kinds of operations:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;U — move from (x,y)(x,y) to (x,y+1)(x,y+1);&lt;br&gt;D — move from (x,y)(x,y) to (x,y−1)(x,y−1);&lt;br&gt;L — move from (x,y)(x,y) to (x−1,y)(x−1,y);&lt;br&gt;R — move from (x,y)(x,y) to (x+1,y)(x+1,y).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vasya also has got a sequence of n operations. Vasya wants to modify this sequence so after performing it the robot will end up in (x,y)&lt;br&gt;Vasya wants to change the sequence so the length of changed subsegment is minimum possible. This length can be calculated as follows: maxID−minID+1, where maxID is the maximum index of a changed operation, and minID is the minimum index of a changed operation. For example, if Vasya changes RRRRRRR to RLRRLRL, then the operations with indices 2, 5 and 7 are changed, so the length of changed subsegment is 7−2+1=6. Another example: if Vasya changes DDDD to DDRD, then the length of changed subsegment is 1.&lt;/p&gt;
&lt;p&gt;If there are no changes, then the length of changed subsegment is 0. Changing an operation means replacing it with some operation (possibly the same); Vasya can’t insert new operations into the sequence or remove them.&lt;/p&gt;
&lt;p&gt;Help Vasya! Tell him the minimum length of subsegment that he needs to change so that the robot will go from (0,0) to (x,y), or tell him that it’s impossible.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="二分" scheme="https://amannix.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysterious Crime(子区间匹配)</title>
    <link href="https://amannix.github.io/2018/11/07/Mysterious%20Crime/"/>
    <id>https://amannix.github.io/2018/11/07/Mysterious Crime/</id>
    <published>2018-11-07T11:52:37.000Z</published>
    <updated>2018-11-07T12:30:54.645Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1043/problem/D" target="_blank" rel="noopener">Codeforces Round #519</a><br><strong>Description</strong><br><div class="note default"><p>Acingel is a small town. There was only one doctor here — Miss Ada. She was very friendly and nobody has ever said something bad about her, so who could’ve expected that Ada will be found dead in her house? Mr Gawry, world-famous detective, is appointed to find the criminal. He asked m neighbours of Ada about clients who have visited her in that unlucky day. Let’s number the clients from 1 to n. Each neighbour’s testimony is a permutation of these numbers, which describes the order in which clients have been seen by the asked neighbour.</p><p>However, some facts are very suspicious – how it is that, according to some of given permutations, some client has been seen in the morning, while in others he has been seen in the evening? “In the morning some of neighbours must have been sleeping!” — thinks Gawry — “and in the evening there’s been too dark to see somebody’s face…”. Now he wants to delete some prefix and some suffix (both prefix and suffix can be empty) in each permutation, so that they’ll be non-empty and equal to each other after that — some of the potential criminals may disappear, but the testimony won’t stand in contradiction to each other.</p><p>In how many ways he can do it? Two ways are called different if the remaining common part is different.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains two integers n and m (1≤n≤100000, 1≤m≤10) — the number of suspects and the number of asked neighbors.</p><p>Each of the next m lines contains nn integers a1,a2,…,an (1≤ai≤n). It is guaranteed that these integers form a correct permutation (that is, each number from 1 to n appears exactly once).</p></div><br><strong>Output</strong><br><div class="note default"><p>Output a single integer denoting the number of ways to delete some prefix and some suffix of each permutation (possibly empty), such that the remaining parts will be equal and non-empty.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5 6<br>1 2 3 4 5<br>2 3 1 4 5<br>3 4 5 1 2<br>3 5 4 2 1<br>2 3 5 4 1<br>1 2 3 4 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>5</p></blockquote><p><strong>Thinking</strong><br>灰常有意思的一道区间匹配问题，给出一行1到N的全排列，总共有M行。求这M行中的公共子区间是多少，例如：12543和43512.首先每个单独的数字就是他们最小的一个子区间，然后12也是他们的公共子区间，这道题就是要求出所有的公共子区间有多少。首先暴力肯定是不能暴力的了，由于每个数字在一行上只会出现一次。所以可以桶哈希记录每个数字出现的位置，方便查找。接下来就是匹配子区间了，以第一行为基准枚举，从第一个数字开始纵向匹配，去匹配最长的公共子区间如果找到一个子区间，那么枚举变量跳转到区间左边（最小的区间一定是单个数字）那么对于横向枚举来说一定是线性时间，由于要纵向对比，所以总的时间复杂度是O(N*M)。现在如果匹配到了一个子区间长度为K，那么对于这段子区间来说它的所有的子区间都一定是公共子区间，所以它包含的公共子区间一定是1+2+3…+K。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">15</span>][<span class="number">200010</span>],hash[<span class="number">15</span>][<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//直接求出第一组第s个数据开始向后最多可以匹配到多长的公共子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="comment">/*由于这个匹配是默认从第二组开始的所以无法判断只有一组数据的情况</span></span><br><span class="line"><span class="comment">             *理论上改成i = 1可解决。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> k = hash[i][buf[<span class="number">1</span>][s]] + cnt;</span><br><span class="line">            <span class="keyword">if</span> (buf[<span class="number">1</span>][s+cnt] != buf[i][k] || s+cnt &gt; n || k &gt; n)&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">fact</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//注意这个前k项和的数据范围</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k; ++i)&#123;</span><br><span class="line">        ans += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;buf[i][j]);</span><br><span class="line">            hash[i][buf[i][j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)&#123;<span class="comment">//需要特判一下只有一组数据的情况</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,fact(n));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = judge(i);</span><br><span class="line">        ans += fact(temp);<span class="comment">//这段公共子串的组合数等于其长度的1+2+3……+temp。</span></span><br><span class="line">        i += temp;<span class="comment">//跳过这段公共子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1043/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round #519&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Acingel is a small town. There was only one doctor here — Miss Ada. She was very friendly and nobody has ever said something bad about her, so who could’ve expected that Ada will be found dead in her house? Mr Gawry, world-famous detective, is appointed to find the criminal. He asked m neighbours of Ada about clients who have visited her in that unlucky day. Let’s number the clients from 1 to n. Each neighbour’s testimony is a permutation of these numbers, which describes the order in which clients have been seen by the asked neighbour.&lt;/p&gt;
&lt;p&gt;However, some facts are very suspicious – how it is that, according to some of given permutations, some client has been seen in the morning, while in others he has been seen in the evening? “In the morning some of neighbours must have been sleeping!” — thinks Gawry — “and in the evening there’s been too dark to see somebody’s face…”. Now he wants to delete some prefix and some suffix (both prefix and suffix can be empty) in each permutation, so that they’ll be non-empty and equal to each other after that — some of the potential criminals may disappear, but the testimony won’t stand in contradiction to each other.&lt;/p&gt;
&lt;p&gt;In how many ways he can do it? Two ways are called different if the remaining common part is different.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://amannix.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Smallest Word(思维、字符串)</title>
    <link href="https://amannix.github.io/2018/11/07/Smallest%20Word/"/>
    <id>https://amannix.github.io/2018/11/07/Smallest Word/</id>
    <published>2018-11-07T10:21:11.000Z</published>
    <updated>2018-11-07T12:23:14.479Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1043/problem/C" target="_blank" rel="noopener">Codeforces Round 519</a><br><strong>Description</strong><br><div class="note default"><p>IA has so many colorful magnets on her fridge! Exactly one letter is written on each magnet, ‘a’ or ‘b’. She loves to play with them, placing all magnets in a row. However, the girl is quickly bored and usually thinks how to make her entertainment more interesting.</p><p>Today, when IA looked at the fridge, she noticed that the word formed by magnets is really messy. “It would look much better when I’ll swap some of them!” — thought the girl — “but how to do it?”. After a while, she got an idea. IA will look at all prefixes with lengths from 1 to the length of the word and for each prefix she will either reverse this prefix or leave it as it is. She will consider the prefixes in the fixed order: from the shortest to the largest. She wants to get the lexicographically smallest possible word after she considers all prefixes. Can you help her, telling which prefixes should be chosen for reversing?</p><blockquote><p>A string a is lexicographically smaller than a string b if and only if one of the following holds:</p></blockquote><blockquote><p>a is a prefix of b, but a≠b;</p></blockquote><p>in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first and the only line contains a string s (1≤|s|≤1000), describing the initial string formed by magnets. The string s consists only of characters ‘a’ and ‘b’.</p></div><br><strong>Output</strong><br><div class="note default"><p>Output exactly |s| integers. If IA should reverse the i-th prefix (that is, the substring from 1 to i), the ii-th integer should be equal to 1, and it should be equal to 0 otherwise.</p><p>If there are multiple possible sequences leading to the optimal answer, print any of them.</p></div><br><strong>Sample Input</strong></p><blockquote><p>bbab</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0 1 1 0</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>aaaaa</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 0 0 0 1</p></blockquote><p><strong>Thinking</strong><br>给出一个只有a、b组成的字符串，可以在每一个位置选择是否反转前缀，求一个操作序列使得整个字符串的字典序最小。那最好可以把所有的a都反转到开头的位置就最好了，因此可以在遇到一个’a’的时候，将前面的前缀反转，使得首部的’a’反转到遇到的这个’a’然后在把整各反转回去，例如：abbabb，当遇到第二个’a’的时候，需要先反转成bbaabb，然后再反转成aabbbb。但是需要注意当出现abbaabba的时候，按照之前的规则会导致答案为1 0 1 1 1 0 1 1，但是按照这样的答案是错误的。因为当遇到连续的’a’时，必须直接把这串连续的’a’全部一次反转回去，详情见代码。</p><p><strong>Thinking</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'a'</span>)&#123;</span><br><span class="line">            val[i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt;= len; ++j)&#123;<span class="comment">//搜索连续的'a'区间。</span></span><br><span class="line">                <span class="keyword">if</span> (str[j+<span class="number">1</span>] == <span class="string">'b'</span> || j == len)&#123;</span><br><span class="line">                    val[j] = <span class="number">1</span>;</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,val[i],i==len ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1043/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round 519&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;IA has so many colorful magnets on her fridge! Exactly one letter is written on each magnet, ‘a’ or ‘b’. She loves to play with them, placing all magnets in a row. However, the girl is quickly bored and usually thinks how to make her entertainment more interesting.&lt;/p&gt;
&lt;p&gt;Today, when IA looked at the fridge, she noticed that the word formed by magnets is really messy. “It would look much better when I’ll swap some of them!” — thought the girl — “but how to do it?”. After a while, she got an idea. IA will look at all prefixes with lengths from 1 to the length of the word and for each prefix she will either reverse this prefix or leave it as it is. She will consider the prefixes in the fixed order: from the shortest to the largest. She wants to get the lexicographically smallest possible word after she considers all prefixes. Can you help her, telling which prefixes should be chosen for reversing?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A string a is lexicographically smaller than a string b if and only if one of the following holds:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a is a prefix of b, but a≠b;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://amannix.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Lost Array(推导)</title>
    <link href="https://amannix.github.io/2018/11/07/Lost%20Array/"/>
    <id>https://amannix.github.io/2018/11/07/Lost Array/</id>
    <published>2018-11-07T09:33:21.000Z</published>
    <updated>2018-11-07T10:22:52.627Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1043/problem/B" target="_blank" rel="noopener">Codeforces Round 519 B.Lost Array</a><br><strong>Description</strong><br><div class="note default"><p>Bajtek, known for his unusual gifts, recently got an integer array x0,x1,…,xk−1.</p><p>Unfortunately, after a huge array-party with his extraordinary friends, he realized that he’d lost it. After hours spent on searching for a new toy, Bajtek found on the arrays producer’s website another array a of length n+1. As a formal description of a says, a0=0 and for all other i (1≤i≤n) ai=x(i−1)modk+ai−1, where p mod q denotes the remainder of division p by q.</p><p>For example, if the x=[1,2,3] and n=5, then:<br>a0=0,<br>a1=x0mod3+a0=x0+0=1,<br>a2=x1mod3+a1=x1+1=3,<br>a3=x2mod3+a2=x2+3=6,<br>a4=x3mod3+a3=x0+6=7,<br>a5=x4mod3+a4=x1+7=9.<br>So, if the x=[1,2,3] and n=5, then a=[0,1,3,6,7,9].</p><p>Now the boy hopes that he will be able to restore x from aa! Knowing that 1≤k≤n, help him and find all possible values of k — possible lengths of the lost array.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>输入数据有多组。<br>The first line contains exactly one integer nn (1≤n≤1000) — the length of the array aa, excluding the element a0.</p><p>The second line contains nn integers a1,a2,…,an (1≤ai≤10^6).</p><p>Note that a0 is always 0 and is not given in the input.</p></div><br><strong>Output</strong><br><div class="note default"><p>The first line of the output should contain one integer ll denoting the number of correct lengths of the lost array.</p><p>The second line of the output should contain ll integers — possible lengths of the lost array in increasing order.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>1 2 3 4 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>5<br>1 2 3 4 5</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>5<br>1 3 5 6 8</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2<br>3 5</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>3<br>1 5 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1<br>3  </p></blockquote><p><strong>Thinking</strong><br>说的是有一个数列，这个数列a，同时有一个配套的数列x，x的代表了a数列在之间两两之差，求多长的数组x可以满足a[i]=a[i-1]+x[(i-1)%k].求k可能的值，按从小到大输出。先预处理a数列的两项之差，然后枚举k的值，对每一个k。我们去模拟是否是符合条件的。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,buf[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125;,val[<span class="number">10000</span>],ans[<span class="number">1005</span>],t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;buf[i]);</span><br><span class="line">        val[i<span class="number">-1</span>] = buf[i] - buf[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (buf[j]-buf[j<span class="number">-1</span>] != val[index])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            index %= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            ans[t++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,ans[i],i==t ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1043/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round 519 B.Lost Array&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Bajtek, known for his unusual gifts, recently got an integer array x0,x1,…,xk−1.&lt;/p&gt;
&lt;p&gt;Unfortunately, after a huge array-party with his extraordinary friends, he realized that he’d lost it. After hours spent on searching for a new toy, Bajtek found on the arrays producer’s website another array a of length n+1. As a formal description of a says, a0=0 and for all other i (1≤i≤n) ai=x(i−1)modk+ai−1, where p mod q denotes the remainder of division p by q.&lt;/p&gt;
&lt;p&gt;For example, if the x=[1,2,3] and n=5, then:&lt;br&gt;a0=0,&lt;br&gt;a1=x0mod3+a0=x0+0=1,&lt;br&gt;a2=x1mod3+a1=x1+1=3,&lt;br&gt;a3=x2mod3+a2=x2+3=6,&lt;br&gt;a4=x3mod3+a3=x0+6=7,&lt;br&gt;a5=x4mod3+a4=x1+7=9.&lt;br&gt;So, if the x=[1,2,3] and n=5, then a=[0,1,3,6,7,9].&lt;/p&gt;
&lt;p&gt;Now the boy hopes that he will be able to restore x from aa! Knowing that 1≤k≤n, help him and find all possible values of k — possible lengths of the lost array.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="模拟" scheme="https://amannix.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>UVA-11988 Broken Keyboard(数组模拟链表)</title>
    <link href="https://amannix.github.io/2018/10/27/UVA-11988/"/>
    <id>https://amannix.github.io/2018/10/27/UVA-11988/</id>
    <published>2018-10-27T05:35:02.000Z</published>
    <updated>2018-10-27T06:05:49.174Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-11988" target="_blank" rel="noopener">UVA-11988 Broken Keyboard</a><br><strong>Description</strong><br><div class="note default"><p>WJL同学的键盘出现了奇妙的故障，所有键都会正常的工作，但是键盘上的Home以及End键有时候会莫名其妙的自己按下。但是盲打很熟练的他一般习惯关闭显示器打字，因为这样很酷。<br>现在他正在打一段文本，假设你已经知道这段文本以及Home和End键会什么时候出现故障自行按下。请你编写一个程序，求出他最后打出的文本。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>输入数据有多组。<br>每组数据在一行内包含了至多100000个字母、下划线和两个特别的标点’[‘以及’]’，其中’[‘代表输入到此时”Home”键会被按下。而’]’则代表输入到此时”End”键会被按下。<br>输入数据以EOF作为结束，并且我们保证输入数据的大小不超过5MB。</p></div><br><strong>Output</strong><br><div class="note default"><p>对于每组数据，请在一行之内输出最后他打出的文本是怎样的。</p></div><br><strong>Sample Input</strong></p><blockquote><p>This_is_a_[Sample]_text<br>[[]][][]Nihao_I_am_a_Sample_Input<br>This_pr[oblem_has_a_100]0[m]s_time_limit<br>Maybe_theres_no_bracket  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>SampleThis_is_a__text<br>Nihao_I_am_a_Sample_Input<br>moblem_has_a_100This_pr0s_time_limit<br>Maybe_theres_no_bracket  </p></blockquote><p><strong>Thinking</strong><br>紫书例四，一个链表的做法，看的答案用了数组模拟链表。再次惊叹刘大爷的代码妙不可言（很难看的懂）<br>我就只能勉强解释一下cur变量的作用。这个变量老是变来变去的贼奇怪，也特别难理解。这里主要是用cur指向链表接下来该插入的位置（不一定是最后）这个链表由于借助数组所以寻址的过程也比较抽象（巨抽象）。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;nodetable[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> next[<span class="number">100010</span>] = &#123;<span class="number">0</span>&#125;,cur = <span class="number">0</span>,end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*将屏幕上要出现的最终的字符串理解为一个链表生成的过程</span></span><br><span class="line"><span class="comment">          cur链表指针，也可以理解为光标</span></span><br><span class="line"><span class="comment">          end记录链表尾部。</span></span><br><span class="line"><span class="comment">          next[0]必须等于0，初始化首部指针指向NULL*/</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">                cur = <span class="number">0</span>;<span class="comment">//回到首部</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">']'</span>)&#123;</span><br><span class="line">                cur = end;<span class="comment">//回到链表尾部</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                next[i] = next[cur];</span><br><span class="line">                next[cur] = i;<span class="comment">//无论如何光标指向的一定是当前枚举到的i.</span></span><br><span class="line">                <span class="keyword">if</span> (cur == end)<span class="comment">//当光标指向尾部的时候才更新链表尾部地址</span></span><br><span class="line">                    end = i;</span><br><span class="line">                cur = next[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>,cur,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = next[<span class="number">0</span>];i != <span class="number">0</span>; i=next[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%c"</span>,str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-11988&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UVA-11988 Broken Keyboard&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;WJL同学的键盘出现了奇妙的故障，所有键都会正常的工作，但是键盘上的Home以及End键有时候会莫名其妙的自己按下。但是盲打很熟练的他一般习惯关闭显示器打字，因为这样很酷。&lt;br&gt;现在他正在打一段文本，假设你已经知道这段文本以及Home和End键会什么时候出现故障自行按下。请你编写一个程序，求出他最后打出的文本。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-442 Matrix Chain Multiplication(表达式值)</title>
    <link href="https://amannix.github.io/2018/10/26/UVA-442/"/>
    <id>https://amannix.github.io/2018/10/26/UVA-442/</id>
    <published>2018-10-26T07:44:52.000Z</published>
    <updated>2018-10-26T07:57:19.089Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-442" target="_blank" rel="noopener">Matrix Chain Multiplication</a><br><strong>Description</strong><br><div class="note default"><p>Suppose you have to evaluate an expression like ABCDE where A,B,C,D and E are matrices.<br>Since matrix multiplication is associative, the order in which multiplications are performed is arbitrary.<br>However, the number of elementary multiplications needed strongly depends on the evaluation order<br>you choose.<br>For example, let A be a 5010 matrix, B a 1020 matrix and C a 205 matrix. There are two different strategies to compute ABC, namely (AB)C and A(B*C).<br>The first one takes 15000 elementary multiplications, but the second one only 3500.<br>Your job is to write a program that determines the number of elementary multiplications needed<br>for a given evaluation strategy.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>Input consists of two parts: a list of matrices and a list of expressions.<br>The first line of the input file contains one integer n (1 ≤ n ≤ 26), representing the number of<br>matrices in the first part. The next n lines each contain one capital letter, specifying the name of the<br>matrix, and two integers, specifying the number of rows and columns of the matrix.<br>The second part of the input file strictly adheres to the following syntax (given in EBNF):<br>SecondPart = Line { Line }<br>Line = Expression<br>Expression = Matrix | “(“ Expression Expression “)”<br>Matrix = “A” | “B” | “C” | … | “X” | “Y” | “Z”</p></div><br><strong>Output</strong><br><div class="note default"><p>For each expression found in the second part of the input file, print one line containing the word ‘error’<br>if evaluation of the expression leads to an error due to non-matching matrices. Otherwise print one<br>line containing the number of elementary multiplications needed to evaluate the expression in the way<br>specified by the parentheses.</p></div><br><strong>Sample Input</strong></p><blockquote><p>9<br>A 50 10<br>B 10 20<br>C 20 5<br>D 30 35<br>E 35 15<br>F 15 5<br>G 5 10<br>H 10 20<br>I 20 25<br>A<br>B<br>C<br>(AA)<br>(AB)<br>(AC)<br>(A(BC))<br>((AB)C)<br>(((((DE)F)G)H)I)<br>(D(E(F(G(HI)))))<br>((D(EF))((GH)I))</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0<br>0<br>0<br>error<br>10000<br>error<br>3500<br>15000<br>40500<br>47500<br>15125</p></blockquote><p><strong>Thinking</strong><br>紫书第六章例三，经典的堆栈模拟求表达式。很早就知道解法，但是一直没真正做过。输入n个矩阵的维度和一些矩阵链乘表达式，输出乘法次数。如果乘法无法进行则输出error。假定A是m<em>n的矩阵，B是n</em>p的矩阵，那么A<em>B等于m</em>p，且乘法次数等于n<em>m</em>p，如果A的列不等于B的行，则乘法无法进行。先将字符串遍历，遇到’(‘跳过遇到’)’就将栈中取出两个元素做乘法，并且计算乘法次数。然后将新的矩阵再次入栈，知道最后栈为空。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">&#125;buf[<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;node&gt; sta;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    getchar ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; ++i)&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%c "</span>,&amp;ch);</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;buf[ch-<span class="string">'A'</span>].a,&amp;buf[ch-<span class="string">'A'</span>].b);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="comment">//printf ("%d %d\n",buf[ch-'A'].a,buf[ch-'A'].b);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100100</span>];</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str+<span class="number">1</span>),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> error = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!sta.empty())    sta.pop();<span class="comment">//清空栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'('</span>)    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                node a,b;</span><br><span class="line">                a = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                <span class="keyword">if</span> (sta.empty())&#123;<span class="comment">//取第二个元素应该确保栈不为空并且栈中取出的元素应该交换位置</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                <span class="comment">//printf ("%d %d %d %d\n",a.a,a.b,b.a,b.b);</span></span><br><span class="line">                <span class="keyword">if</span> (a.a != b.b)&#123;<span class="comment">//不满足矩阵相乘条件</span></span><br><span class="line">                    error = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += (a.a*a.b*b.a);</span><br><span class="line">                    b.b = a.b;</span><br><span class="line">                    sta.push(b);<span class="comment">//将新矩阵入栈</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sta.push(buf[str[i]-<span class="string">'A'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (error)    <span class="built_in">printf</span> (<span class="string">"error\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-442&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Matrix Chain Multiplication&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Suppose you have to evaluate an expression like ABCDE where A,B,C,D and E are matrices.&lt;br&gt;Since matrix multiplication is associative, the order in which multiplications are performed is arbitrary.&lt;br&gt;However, the number of elementary multiplications needed strongly depends on the evaluation order&lt;br&gt;you choose.&lt;br&gt;For example, let A be a 5010 matrix, B a 1020 matrix and C a 205 matrix. There are two different strategies to compute ABC, namely (AB)C and A(B*C).&lt;br&gt;The first one takes 15000 elementary multiplications, but the second one only 3500.&lt;br&gt;Your job is to write a program that determines the number of elementary multiplications needed&lt;br&gt;for a given evaluation strategy.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 53 D-Berland Fair(模拟)</title>
    <link href="https://amannix.github.io/2018/10/26/Berland%20Fair/"/>
    <id>https://amannix.github.io/2018/10/26/Berland Fair/</id>
    <published>2018-10-26T07:14:28.000Z</published>
    <updated>2018-10-26T07:58:46.964Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1073/problem/D" target="_blank" rel="noopener">D.Berland Fair</a><br><strong>Description</strong><br><div class="note default"><p>XXI Berland Annual Fair is coming really soon! Traditionally fair consists of n booths, arranged in a circle. The booths are numbered 1 through n clockwise with n being adjacent to 1. The i-th booths sells some candies for the price of ai burles per item. Each booth has an unlimited supply of candies.<br>Polycarp has decided to spend at most T burles at the fair. However, he has some plan in mind for his path across the booths:</p><ol><li>at first, he visits booth number 1;</li><li>f he has enough burles to buy exactly one candy from the current booth, then he buys it immediately;</li><li>then he proceeds to the next booth in the clockwise order (regardless of if he bought a candy or not).<br>Polycarp’s money is finite, thus the process will end once he can no longer buy candy at any booth.<br>Calculate the number of candies Polycarp will buy.</li></ol></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains two integers n and T(1&lt;=n&lt;=2*10^5,1&lt;=T&lt;=10^18) — the number of booths at the fair and the initial amount of burles Polycarp has.<br>The second line contains n integers a1,a2…an (1&lt;ai&lt;10^9) — the price of the single candy at booth number i.</p></div><br><strong>Output</strong><br><div class="note default"><p>Print a single integer — the total number of candies Polycarp will buy.</p></div><br><strong>Sample Input</strong></p><blockquote><p>3 38<br>5 2 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>10</p></blockquote><p><strong>Thinking</strong><br>就是说一个循环链表，在链表中有N个摊位，每个摊位出售价格为ai的糖果。现在XXI手上有T元钱，从起点开始循环遍历，每遇到一个摊位如果钱足够的话就买下一颗糖，不够就去下一个摊位，重复循环知道他再也买不到糖为止。求这时买了多少颗糖。简单的循环模拟肯定T，因此可以先求出手上的钱单次循环足够买多少颗糖果。记录糖果数量X和花费Y，然后直接取余取整计算在一次遍历需要花费Y的情况下最多能遍历几次，即：T/Y*X就是还能买这么多次糖果，而剩余的钱就是T%Y。但是注意假设剩余M块钱，这里M块钱肯定不够一次遍历要花费Y元，必须重新计算在余钱M的情况下，单次遍历所花费的钱以及买的糖果数。因此要外加一个大循环，控制条件为剩余的钱一颗糖都买不起为止。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll buf[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,sum = <span class="number">0</span>,cand_sum = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        sum = cand_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + buf[i] &lt;= m)&#123;</span><br><span class="line">                sum += buf[i];<span class="comment">//记录一次遍历的花费</span></span><br><span class="line">                ++cand_sum;<span class="comment">//记录一次遍历买的糖果数量</span></span><br><span class="line">                flag = <span class="literal">false</span>;<span class="comment">//记录是否再也买不了了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        ans += m/sum*cand_sum;<span class="comment">//直接计算出N次遍历最多可以买多少糖果</span></span><br><span class="line">        m = m%sum;<span class="comment">//计算出N次遍历还剩多少钱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1073/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;D.Berland Fair&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;XXI Berland Annual Fair is coming really soon! Traditionally fair consists of n booths, arranged in a circle. The booths are numbered 1 through n clockwise with n being adjacent to 1. The i-th booths sells some candies for the price of ai burles per item. Each booth has an unlimited supply of candies.&lt;br&gt;Polycarp has decided to spend at most T burles at the fair. However, he has some plan in mind for his path across the booths:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;at first, he visits booth number 1;&lt;/li&gt;
&lt;li&gt;f he has enough burles to buy exactly one candy from the current booth, then he buys it immediately;&lt;/li&gt;
&lt;li&gt;then he proceeds to the next booth in the clockwise order (regardless of if he bought a candy or not).&lt;br&gt;Polycarp’s money is finite, thus the process will end once he can no longer buy candy at any booth.&lt;br&gt;Calculate the number of candies Polycarp will buy.&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="模拟" scheme="https://amannix.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 53 B-Vasya and Books(栈)</title>
    <link href="https://amannix.github.io/2018/10/26/Vasya%20and%20Books/"/>
    <id>https://amannix.github.io/2018/10/26/Vasya and Books/</id>
    <published>2018-10-26T06:52:14.000Z</published>
    <updated>2018-10-26T07:58:45.904Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1073/problem/B" target="_blank" rel="noopener">B. Vasya and Books</a><br><strong>Description</strong><br><div class="note default"><p>Vasya has got nn books, numbered from 11 to nn, arranged in a stack. The topmost book has number a1a1, the next one — a2a2, and so on. The book at the bottom of the stack has number anan. All numbers are distinct.</p><p>Vasya wants to move all the books to his backpack in nn steps. During ii-th step he wants to move the book number bibi into his backpack. If the book with number bibi is in the stack, he takes this book and all the books above the book bibi, and puts them into the backpack; otherwise he does nothing and begins the next step. For example, if books are arranged in the order [1,2,3][1,2,3] (book 11 is the topmost), and Vasya moves the books in the order [2,1,3][2,1,3], then during the first step he will move two books (11 and 22), during the second step he will do nothing (since book 11 is already in the backpack), and during the third step — one book (the book number 33). Note that b1,b2,…,bnb1,b2,…,bn are distinct.</p><p>Help Vasya! Tell him the number of books he will put into his backpack during each step.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains one integer n (1≤n≤2⋅105)n (1≤n≤2⋅105) — the number of books in the stack.<br>The second line contains nn integers a1,a2,…,an (1≤ai≤n)a1,a2,…,an (1≤ai≤n) denoting the stack of books.<br>The third line contains nn integers b1,b2,…,bn (1≤bi≤n)b1,b2,…,bn (1≤bi≤n) denoting the steps Vasya is going to perform.<br>All numbers a1…ana1…an are distinct, the same goes for b1…bnb1…bn.</p></div><br><strong>Output</strong><br><div class="note default"><p>Print nn integers. The ii-th of them should be equal to the number of books Vasya moves to his backpack during the ii-th step.</p></div><br><strong>Sample Input</strong></p><blockquote><p>3<br>1 2 3<br>2 1 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2 0 1</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>5<br>3 1 4 2 5<br>4 5 1 3 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>3 2 0 0 0</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>6<br>6 5 4 3 2 1<br>6 5 3 4 2 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 1 2 0 1 1</p></blockquote><p><strong>Thinking</strong><br>题意是说有一堆书，给出这堆书的编号。然后按照某种顺序取书，假定取n号书，那么此时是将这个堆中n号及n号以前的所有书全部拿走。如果当前要取的书以及被拿走了，那么就什么都不做，现在问，每次拿书的操作一次会被拿走多少本书。所以我们可以按照给定的顺序用一个队列存放书的编号，为了快速查找对应编号所在队列位置可以建立哈希表以实现快速查找。接下来便是依次读取取书顺序，并且找到这本书在队列中的第几位，假设为K，然后直接K减去队首位置+1便是当前一次取到的书的本数。然后依次出队直到队首指针指向K为止。然后就继续读取操作。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,top = <span class="number">1</span>,t;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        hash[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="comment">//printf ("%d %d\n",top,hash[k]);</span></span><br><span class="line">        <span class="keyword">if</span> (hash[k]-top &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,hash[k]-top+<span class="number">1</span>,i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">            top = hash[k]+<span class="number">1</span>;<span class="comment">//改变队首指针的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,<span class="number">0</span>,i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);<span class="comment">//一本书也不取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1073/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B. Vasya and Books&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Vasya has got nn books, numbered from 11 to nn, arranged in a stack. The topmost book has number a1a1, the next one — a2a2, and so on. The book at the bottom of the stack has number anan. All numbers are distinct.&lt;/p&gt;
&lt;p&gt;Vasya wants to move all the books to his backpack in nn steps. During ii-th step he wants to move the book number bibi into his backpack. If the book with number bibi is in the stack, he takes this book and all the books above the book bibi, and puts them into the backpack; otherwise he does nothing and begins the next step. For example, if books are arranged in the order [1,2,3][1,2,3] (book 11 is the topmost), and Vasya moves the books in the order [2,1,3][2,1,3], then during the first step he will move two books (11 and 22), during the second step he will do nothing (since book 11 is already in the backpack), and during the third step — one book (the book number 33). Note that b1,b2,…,bnb1,b2,…,bn are distinct.&lt;/p&gt;
&lt;p&gt;Help Vasya! Tell him the number of books he will put into his backpack during each step.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-514 Rails (栈)</title>
    <link href="https://amannix.github.io/2018/10/26/UVA-514/"/>
    <id>https://amannix.github.io/2018/10/26/UVA-514/</id>
    <published>2018-10-26T06:02:38.000Z</published>
    <updated>2018-10-26T07:57:52.147Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-514" target="_blank" rel="noopener">UVA-514 Rails</a></p><p><strong>Description</strong><br><div class="note default"><p>PopPush城市有一座著名的火车站。这个国家到处都是丘陵。而这个火车站是建于上一个世纪。不幸的是，那时的资金有限。所以只能建立起一条路面铁轨。而且，这导致这个火车站在同一个时刻只能一个轨道投入使用，因为它缺少空间，两列火车将无路可走。具体看下图。<br><img src="http://images.cppblog.com/cppblog_com/sixleaves/uva514.png" alt=""><br>当地的惯例是每一列火车从A方向驶向B方向时候，会用某种方式将车厢重组。假设火车将要到达A方向，拥有N个车厢(N&lt;=1000),这些车厢按照递增顺序标记为1到N。负责从组车厢的领导,必须知道是否能从组车厢让它驶出B，而这个重组的序列就是a1\a2\a3…aN.帮组他并且写一个程序来判断是否可能按照所要求的车厢顺序。你可以假设，单个的车厢可以从列车上分离出来，在他们进入站台之前。并且他们可以自由移动，知道它们上了B轨道。你也可以假设在任意时候站台可以放下无数的车厢。但是只要一个车厢进入站台，它就不能返回A轨道，同时如果它离开了站台驶向B轨道，它就不能返回站台。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>这个输入文件由多个行块组成。每一个块描述的是多个要求的重组车厢的序列。在这每个块中的第一行是一个整数N，被用来说明上面每行的车厢个数。这个快的最后一行仅仅是一个数字0要来标记该快的结束<br>最后一个块仅仅是一个0独占一行。</p></div><br><strong>Output</strong><br><div class="note default"><p>这个输出文件包含多行，这些行和排列车厢的行数一一对应。日过该排列可行，则输出Yes，否则输出No。另外存在一个空行在每个相对应的块后面。输出文件中不存在于最后一个什么数据都没有的响应输出。</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>1 2 3 4 5<br>5 4 1 2 3<br>0<br>6<br>6 5 4 3 2 1<br>0<br>0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Yes<br>No<br>Yes  </p></blockquote><p><strong>Thinking</strong><br>紫书上第六章的例二。一个关于栈的模拟，光看的话感觉挺简单，但是一做起来还是不少麻烦。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sta_clear</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span>* top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!sta.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (num[*top] != sta.top())&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sta.pop();</span><br><span class="line">            ++*top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t) &amp;&amp; t != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> num[<span class="number">10000</span>] = &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">while</span> (!sta.empty())    sta.pop();<span class="comment">//清空栈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;num[<span class="number">1</span>]!=<span class="number">0</span> &amp;&amp; i &lt;= t; ++i)&#123;</span><br><span class="line">                <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num[i]);<span class="comment">//读取出站队列</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[<span class="number">1</span>] == <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num[top] == i)&#123;<span class="comment">//当进入站点的火车与出站队列首部相等时，出队</span></span><br><span class="line">                    ++top;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sta.size() &amp;&amp; num[top] == sta.top())&#123;</span><br><span class="line">                    sta_clear(num,&amp;top);<span class="comment">//当队首和栈顶元素相等时，必须得从栈顶开始向下遍历弹出</span></span><br><span class="line">                    sta.push(i);<span class="comment">//必须等遍历弹出结束之后再入栈。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    sta.push(i);<span class="comment">//队首元素无法匹配</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sta_clear(num,&amp;top);<span class="comment">//再次从栈顶出发向下匹配</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%s\n"</span>,sta.empty() ? <span class="string">"Yes"</span>:<span class="string">"No"</span>);<span class="comment">//栈为空则完全匹配成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-514&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UVA-514 Rails&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;PopPush城市有一座著名的火车站。这个国家到处都是丘陵。而这个火车站是建于上一个世纪。不幸的是，那时的资金有限。所以只能建立起一条路面铁轨。而且，这导致这个火车站在同一个时刻只能一个轨道投入使用，因为它缺少空间，两列火车将无路可走。具体看下图。&lt;br&gt;&lt;img src=&quot;http://images.cppblog.com/cppblog_com/sixleaves/uva514.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;当地的惯例是每一列火车从A方向驶向B方向时候，会用某种方式将车厢重组。假设火车将要到达A方向，拥有N个车厢(N&amp;lt;=1000),这些车厢按照递增顺序标记为1到N。负责从组车厢的领导,必须知道是否能从组车厢让它驶出B，而这个重组的序列就是a1\a2\a3…aN.帮组他并且写一个程序来判断是否可能按照所要求的车厢顺序。你可以假设，单个的车厢可以从列车上分离出来，在他们进入站台之前。并且他们可以自由移动，知道它们上了B轨道。你也可以假设在任意时候站台可以放下无数的车厢。但是只要一个车厢进入站台，它就不能返回A轨道，同时如果它离开了站台驶向B轨道，它就不能返回站台。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>牛客国庆集训派对Day1-L New Game! (几何建图+最短路径)</title>
    <link href="https://amannix.github.io/2018/10/24/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day1-L/"/>
    <id>https://amannix.github.io/2018/10/24/牛客国庆集训派对Day1-L/</id>
    <published>2018-10-23T16:02:05.000Z</published>
    <updated>2018-10-23T16:12:16.383Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.nowcoder.com/acm/contest/201/L" target="_blank" rel="noopener">牛客国庆集训派对Day1-L New Game!</a><br><strong>Description</strong><br><div class="note default"><p>Eagle Jump公司正在开发一款新的游戏。Hifumi Takimoto作为其中的员工，获得了提前试玩的机会。现在她正在试图通过一个迷宫。<br>这个迷宫有一些特点。为了方便描述，我们对这个迷宫建立平面直角坐标系。迷宫中有两条平行直线 L1:Ax+By+C1=0, L2:Ax+By+C2=0，还有 n 个圆 。角色在直线上、圆上、园内行走不消耗体力。在其他位置上由S点走到T点消耗的体力为S和T的欧几里得距离。<br>Hifumi Takimoto想从 L1 出发，走到 L2 。请计算最少需要多少体力。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>第一行五个正整数 n,A,B,C1,C2 (1≤ n ≤ 1000, -10000 ≤ A,B,C1,C2 ≤ 10000)，其中 A,B 不同时为 0。<br>接下来 n 行每行三个整数 x,y,r(-10000 ≤ x,y ≤ 10000, 1≤ r ≤ 10000) 表示一个圆心为 (x,y)，半径为 r 的圆。</p></div><br><strong>Output</strong><br><div class="note default"><p>仅一行一个实数表示答案。与正确结果的绝对误差或者相对误差不超过 10^-4 即算正确。</p></div><br><strong>Sample Input</strong></p><blockquote><p>2 0 1 0 -4<br>0 1 1<br>1 3 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0.236068</p></blockquote><p><strong>Thinking</strong><br>相当有趣的图论题，乍一看以为是集合题，瞎想了好久。发现是图论，但是最后建图还是有错。正解建图应该是把所有的圆和直线都看做点，这样就是n+2个点直接两两枚举求出欧式距离即可。只是需要特判到底是求圆与圆之间的距离还是线到圆的距离而已，反正这样建图之后就是裸的最短路算法。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> maxn = <span class="number">0xffffffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> A,B,C;</span><br><span class="line">&#125;a,b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y,r,dis;</span><br><span class="line">&#125;coor[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Line_dis,ans = maxn;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node a,Node b)</span><span class="comment">//计算两圆之间的最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp_dis = <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)) - a.r - b.r;</span><br><span class="line"><span class="keyword">return</span> temp_dis &gt; <span class="number">0</span> ? temp_dis : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ans_dis</span><span class="params">(Node a,Line b)</span><span class="comment">//计算圆到直线的最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp_dis = <span class="built_in">fabs</span>(a.x*b.A+a.y*b.B+b.C)/<span class="built_in">sqrt</span>(b.A*b.A+b.B*b.B) - a.r;</span><br><span class="line"><span class="keyword">return</span> temp_dis &gt; <span class="number">0</span> ? temp_dis : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> book[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> _dis[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">2</span>; ++i)&#123;</span><br><span class="line">_dis[i] = coor[n+<span class="number">1</span>][i].dis;</span><br><span class="line">&#125;</span><br><span class="line">_dis[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">book[n+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n+<span class="number">2</span>; i++)&#123;</span><br><span class="line"><span class="keyword">double</span> min = maxn;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; _dis[j] &amp;&amp; !book[j])&#123;</span><br><span class="line">min = _dis[j];</span><br><span class="line">total = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[total] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span> ;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!book[j] &amp;&amp; _dis[j] &gt; coor[total][j].dis + _dis[total])&#123;</span><br><span class="line">_dis[j] = coor[total][j].dis + _dis[total];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _dis[n+<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">2</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span>; ++j)&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lf "</span>,coor[i][j].dis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//读取数据并且建立无向图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%lf%lf%lf%lf"</span>,&amp;n,&amp;a.A,&amp;a.B,&amp;a.C,&amp;b.C);</span><br><span class="line">b.A = a.A;</span><br><span class="line">b.B = a.B;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">2</span>; ++i)&#123;<span class="comment">//Init</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span>; ++j)&#123;</span><br><span class="line">coor[i][j].dis = coor[j][i].dis = maxn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line_dis = <span class="built_in">fabs</span>(a.C-b.C)/<span class="built_in">sqrt</span>(a.A*a.A+a.B*a.B);</span><br><span class="line">coor[n+<span class="number">2</span>][n+<span class="number">1</span>].dis = coor[n+<span class="number">1</span>][n+<span class="number">2</span>].dis = Line_dis;<span class="comment">//把两条直线放在最后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf%lf%lf"</span>,&amp;coor[i][i].x,&amp;coor[i][i].y,&amp;coor[i][i].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;<span class="comment">//先循环枚举求圆之间的距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= n; ++j)&#123;<span class="comment">//我他妈枚举变量写错了</span></span><br><span class="line">coor[j][i].dis = coor[i][j].dis = dis(coor[i][i],coor[j][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;<span class="comment">//枚举求两直线到所有圆之间的距离。</span></span><br><span class="line">coor[i][n+<span class="number">1</span>].dis = coor[n+<span class="number">1</span>][i].dis = ans_dis(coor[i][i],a);</span><br><span class="line">coor[i][n+<span class="number">2</span>].dis = coor[n+<span class="number">2</span>][i].dis = ans_dis(coor[i][i],b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init();</span><br><span class="line">ans = Dijkstra();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lf\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">work();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/201/L&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客国庆集训派对Day1-L New Game!&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Eagle Jump公司正在开发一款新的游戏。Hifumi Takimoto作为其中的员工，获得了提前试玩的机会。现在她正在试图通过一个迷宫。&lt;br&gt;这个迷宫有一些特点。为了方便描述，我们对这个迷宫建立平面直角坐标系。迷宫中有两条平行直线 L1:Ax+By+C1=0, L2:Ax+By+C2=0，还有 n 个圆 。角色在直线上、圆上、园内行走不消耗体力。在其他位置上由S点走到T点消耗的体力为S和T的欧几里得距离。&lt;br&gt;Hifumi Takimoto想从 L1 出发，走到 L2 。请计算最少需要多少体力。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="https://amannix.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>牛客国庆集训派对Day1-J(栈的操作)</title>
    <link href="https://amannix.github.io/2018/10/23/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day1-J/"/>
    <id>https://amannix.github.io/2018/10/23/牛客国庆集训派对Day1-J/</id>
    <published>2018-10-23T15:42:53.000Z</published>
    <updated>2018-10-23T16:01:40.230Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.nowcoder.com/acm/contest/201/J" target="_blank" rel="noopener">牛客国庆集训派对Day1-J Princess Principal</a><br><strong>Description</strong><br><div class="note default"><p>阿尔比恩王国（the Albion Kingdom）潜伏着一群代号“白鸽队（Team White Pigeon）”的间谍。在没有任务的时候，她们会进行各种各样的训练，比如快速判断一个文档有没有语法错误，这有助于她们鉴别写文档的人受教育程度。<br>这次用于训练的是一个含有n个括号的文档。括号一共有m种，每种括号都有左括号和右括号两种形式。我们定义用如下的方式定义一个合法的文档:<br>1.一个空的字符串是一个合法的文档。<br>2.如果A,B都是合法的文档，那么AB也是合法的文档。<br>3.如果S是合法的文档，那么aSb也是合法的文档，其中a,b是同一种括号，并且a是左括号，b是右括号。<br>现在给出q个询问，每次询问只考虑文档第l至r个字符的情况下，文档是不是合法的。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>第一行两个整数n,m,q(1 ≤ n,m,q ≤ 10^6)。<br>第二行有n个空格隔开的整数x，第i个整数xi(0 ≤ xi &lt; m*2)代表文档中的第i个字符是第x/2种括号。另外，如果xi是偶数，它代表一个左括号，否则它代表一个右括号。<br>接下来q行，每行两个空格隔开的整数l,r(1 ≤ l ≤ r ≤ n)，代表询问第l至r个字符构成的字符串是否是一个合法的文档。</p></div><br><strong>Output</strong><br><div class="note default"><p>输出共q行，如果询问的字符串是一个合法的文档，输出”Yes”,否则输出”No”。</p></div><br><strong>Sample Input</strong></p><blockquote><p>6 4 3<br>0 2 3 1 4 7<br>1 4<br>1 5<br>5 6</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Yes<br>No<br>No</p></blockquote><p><strong>Thinking</strong><br>十分经典的合法字符串判定的题目了，就是遍历字符串，然后对于每一个字符，如果栈空就入栈，否则判断当前字符和栈顶元素是否匹配，匹配则出栈，否则入栈。在次期间，每判断一次就要vis[]记录第i个位置的栈顶数据。栈中的数据同样也是字符串下标。最后判断的时候查表，vis[l] == vis[r]. 但是有个问题就是由于当a[j]和栈顶两个元素相等的时候，直接是出栈操作，所以vis[j]是直接等于与a[j]匹配的栈顶元素的后一个元素。因此这里比较的应该是vis[l-1] == vis[r]才对。不清楚的也可以在预处理结束的时候打印vis数组看看每次记录的栈顶元素是什么。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000010</span>],vis[<span class="number">1000010</span>],sta[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q,end = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (end == <span class="number">0</span>)&#123;</span><br><span class="line">sta[++end] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[sta[end]]/<span class="number">2</span> == a[i]/<span class="number">2</span> &amp;&amp; a[sta[end]]+<span class="number">1</span> == a[i])&#123;</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">sta[++end] = i;</span><br><span class="line">&#125;</span><br><span class="line">vis[i] = sta[end];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*for (int i = 1;i &lt;= n; ++i)&#123;//debug</span></span><br><span class="line"><span class="comment">printf ("%d ",vis[i]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf ("\n");*/</span></span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span> (vis[l<span class="number">-1</span>] == vis[r])&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Yes\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/201/J&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客国庆集训派对Day1-J Princess Principal&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;阿尔比恩王国（the Albion Kingdom）潜伏着一群代号“白鸽队（Team White Pigeon）”的间谍。在没有任务的时候，她们会进行各种各样的训练，比如快速判断一个文档有没有语法错误，这有助于她们鉴别写文档的人受教育程度。&lt;br&gt;这次用于训练的是一个含有n个括号的文档。括号一共有m种，每种括号都有左括号和右括号两种形式。我们定义用如下的方式定义一个合法的文档:&lt;br&gt;1.一个空的字符串是一个合法的文档。&lt;br&gt;2.如果A,B都是合法的文档，那么AB也是合法的文档。&lt;br&gt;3.如果S是合法的文档，那么aSb也是合法的文档，其中a,b是同一种括号，并且a是左括号，b是右括号。&lt;br&gt;现在给出q个询问，每次询问只考虑文档第l至r个字符的情况下，文档是不是合法的。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>牛客国庆集训派对Day1-C Utawarerumono（思维、枚举）</title>
    <link href="https://amannix.github.io/2018/10/23/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day1-C/"/>
    <id>https://amannix.github.io/2018/10/23/牛客国庆集训派对Day1-C/</id>
    <published>2018-10-23T08:07:31.000Z</published>
    <updated>2018-10-23T15:37:00.877Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.nowcoder.com/acm/contest/201/C" target="_blank" rel="noopener">牛客国庆集训派对Day1-C Utawarerumono</a><br><strong>Description</strong><br><div class="note default"><p>算术是为数不多的会让Kuon感到棘手的事情。通常她会找Haku帮忙，但是Haku已经被她派去买东西了。于是她向你寻求帮助。<br>给出一个关于变量x,y的不定方程ax+by=c，显然这个方程可能有多个整数解。Kuon想知道如果有解，使得p2<em>x^2+p1</em>x+q2<em>y^2+q1</em>y最小的一组整数解是什么。为了方便，你只需要输出p2<em>x^2+p1</em>x+q2<em>y^2+q1</em>y的最小值。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>第一行三个空格隔开的整数a,b,c(0 ≤ a,b,c≤ 10^5)。<br>第二行两个空格隔开的整数p1,p2(1 ≤ p1,p2 ≤ 10^5)。<br>第三行两个空格隔开的整数q1,q2(1 ≤ q1,q2 ≤ 10^5)。</p></div><br><strong>Output</strong><br><div class="note default"><p>如果方程无整数解，输出“Kuon”。<br>如果有整数解，输出p2<em>x^2+p1</em>x+q2<em>y^2+q1</em>y的最小值。</p></div><br><strong>Sample Input</strong></p><blockquote><p>2 2 1<br>1 1<br>1 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Kuon</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>1 2 3<br>1 1<br>1 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>4</p></blockquote><p><strong>Thinking</strong><br>这道题咋一看是数学题，但是其实由于x和y之间存在约束关系，所以只需要枚举x的状态然后直接算出y的值就可以了。然后将枚举得到的值代入表达式，然后枚举求最大值即可</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL Max = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3fffffffffffff</span>;<span class="comment">//这个值必须足够大</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL a,b,c,p1,p2,q1,q2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%lld%lld%lld%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;p1,&amp;p2,&amp;q1,&amp;q2))&#123;</span><br><span class="line">LL ans = INF;</span><br><span class="line"><span class="keyword">for</span> (LL x = <span class="number">-2</span>*Max; x &lt;= <span class="number">2</span>*Max; ++x)&#123;</span><br><span class="line">LL y = (c-a*x)/b;</span><br><span class="line"><span class="keyword">if</span> (a*x+b*y == c)&#123;</span><br><span class="line">ans = min(p2*x*x+p1*x+q2*y*y+q1*y,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans == INF)&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Kuon\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/201/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客国庆集训派对Day1-C Utawarerumono&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;算术是为数不多的会让Kuon感到棘手的事情。通常她会找Haku帮忙，但是Haku已经被她派去买东西了。于是她向你寻求帮助。&lt;br&gt;给出一个关于变量x,y的不定方程ax+by=c，显然这个方程可能有多个整数解。Kuon想知道如果有解，使得p2&lt;em&gt;x^2+p1&lt;/em&gt;x+q2&lt;em&gt;y^2+q1&lt;/em&gt;y最小的一组整数解是什么。为了方便，你只需要输出p2&lt;em&gt;x^2+p1&lt;/em&gt;x+q2&lt;em&gt;y^2+q1&lt;/em&gt;y的最小值。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="枚举" scheme="https://amannix.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>POJ-3253 Fence Repair(哈夫曼树)</title>
    <link href="https://amannix.github.io/2018/10/18/POJ-3253/"/>
    <id>https://amannix.github.io/2018/10/18/POJ-3253/</id>
    <published>2018-10-18T11:19:31.000Z</published>
    <updated>2018-10-19T03:47:45.309Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=3253" target="_blank" rel="noopener">POJ-3253 Fence Repair</a><br><strong>Description</strong><br><div class="note default"><p>Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.</p><p>FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.</p><p>Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.</p><p>Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>Line 1: One integer N, the number of planks<br>Lines 2..N+1: Each line contains a single integer describing the length of a needed plank</p></div><br><strong>Output</strong><br><div class="note default"><p>Line 1: One integer: the minimum amount of money he must spend to make N-1 cuts</p></div><br><strong>Sample Input</strong></p><blockquote><p>3<br>8<br>5<br>8</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>34</p></blockquote><p><strong>Thinking</strong><br>题意是说要每把两个小木板合并成一个大木板，那么就需要消耗掉同等两个小木板长度的价值。现在要求最少花费多少价值可以把所有木板合并成一个大木板。比较简单的哈夫曼树的应用，但是哈夫曼树建树的过程需要不断排序，因此必须使用优先队列每次选出最短的两个木板，合成一个之后再放回队列，重复此过程直到队列只剩一为止。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;ll,<span class="built_in">vector</span>&lt;ll&gt;,greater&lt;ll&gt; &gt; que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;n))&#123;</span><br><span class="line">        ll i,j,len = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">            ll a;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;a);</span><br><span class="line">            len += a;</span><br><span class="line">            que.push(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.empty())&#123;</span><br><span class="line">            ll a = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (que.empty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ll b = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            ans += a+b;</span><br><span class="line">            que.push(a+b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=3253&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-3253 Fence Repair&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.&lt;/p&gt;
&lt;p&gt;FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.&lt;/p&gt;
&lt;p&gt;Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.&lt;/p&gt;
&lt;p&gt;Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>POJ-1840 Eqs(数学推导，简单哈希)</title>
    <link href="https://amannix.github.io/2018/10/17/POJ-1840/"/>
    <id>https://amannix.github.io/2018/10/17/POJ-1840/</id>
    <published>2018-10-17T10:46:03.000Z</published>
    <updated>2018-10-23T08:09:24.747Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=1840" target="_blank" rel="noopener">POJ-1840 Eqs</a><br><strong>Description</strong><br><div class="note default"><p>Consider equations having the following form:<br>a1<em>x1^3+ a2</em>x2^3+ a3<em>x3^3+ a4</em>x4^3+ a5*x5^3=0<br>The coefficients are given integers from the interval [-50,50].<br>It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}.</p><p>Determine how many solutions satisfy the given equation.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The only line of input contains the 5 coefficients a1, a2, a3, a4, a5, separated by blanks.</p></div><br><strong>Output</strong><br><div class="note default"><p>The output will contain on the first line the number of the solutions for the given equation.</p></div><br><strong>Sample Input</strong></p><blockquote><p>37 29 41 43 47</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>654</p></blockquote><p><strong>Thinking</strong><br>观察式子a1<em>x1^3+ a2</em>x2^3+ a3<em>x3^3+ a4</em>x4^3+ a5<em>x5^3=0。给出五个系数，然后求满足式子的五个变量解的组数。正常做法就是枚举五个变量，数据范围从-50到50.那么就是100^5.听说1ms最多执行1000条语句，1000ms就是100W按照题目给的时间必定T成狗。稍微把式子变换一下，变成 </em>-(a1<em>x1^3+ a2</em>x2^3)=a3<em>x3^3+ a4</em>x4^3+ a5<em>x5^3</em> 这样先对x1和x2暴力枚举打表。然后再枚举右边的式子，这样复杂度骤降为O(100^2+100^3)。打表的时候左边的式子有可能产生多个组合对应一个结果，所以每次离散化的时候应该是让++hash[key]，而不是生成简单的映射关系。左边式子枚举情况是50^3+50^3。这是对于正数的情况，长度12500000。那么对于负数来说使其加上25000000.映射到12500000-25000000的区间即可。对于左右两边式子的枚举到同一个键值，那么两边数量应该是乘积的关系。但是有一个坑点是：25000000的区间来说，必须对左边的式子打表，右边的式子产生的键值必须与左边相同，如果超过正负12500000的话，直接continue，因为超过左边的极限范围根本不可能产生相同的键值，处理不当反而产生冲突，本题数据非常之水，没有判断右边区间居然也能过，还有一种就是我个人认为五个变量的值只能有一次相同，在AC代码中必定会使重复的组合重复出现，比如x1=n，x2=n，那么这个组合会重复出现两次。因此我觉得还得加一次去重判断才对。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sum[<span class="number">25000001</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d,e;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span> sum);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-50</span>;i &lt;= <span class="number">50</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-50</span>;j &lt;= <span class="number">50</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> temp = (a*i*i*i + b*j*j*j)*<span class="number">-1</span>;<span class="comment">//对于25000000的hash范围来说必须是左边为负</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    temp += <span class="number">25000000</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++sum[temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-50</span>;i &lt;= <span class="number">50</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-50</span>;j &lt;= <span class="number">50</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">-50</span>;k &lt;= <span class="number">50</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (k==<span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> temp = c*i*i*i + d*j*j*j + e*k*k*k;</span><br><span class="line">                    <span class="keyword">if</span> (temp &lt; <span class="number">-12500000</span> || temp &gt; <span class="number">12500000</span>)<span class="comment">//左边的式子枚举出的范围不可能超过这个区间</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        temp += <span class="number">25000000</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (sum[temp])&#123;</span><br><span class="line">                        ans += sum[temp];<span class="comment">//组合数，每有一次右边式子对应的hash那么便是乘的关系</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%ld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=1840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-1840 Eqs&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Consider equations having the following form:&lt;br&gt;a1&lt;em&gt;x1^3+ a2&lt;/em&gt;x2^3+ a3&lt;em&gt;x3^3+ a4&lt;/em&gt;x4^3+ a5*x5^3=0&lt;br&gt;The coefficients are given integers from the interval [-50,50].&lt;br&gt;It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}.&lt;/p&gt;
&lt;p&gt;Determine how many solutions satisfy the given equation.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="哈希" scheme="https://amannix.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>POJ-3274 Gold Balanced Lineup</title>
    <link href="https://amannix.github.io/2018/10/16/POJ-3274/"/>
    <id>https://amannix.github.io/2018/10/16/POJ-3274/</id>
    <published>2018-10-16T10:49:00.000Z</published>
    <updated>2018-10-17T07:42:49.352Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=3274" target="_blank" rel="noopener">POJ-3274 Gold Balanced Lineup</a></p><p><strong>Description</strong><br><div class="note default"><p>Farmer John’s N cows (1 ≤ N ≤ 100,000) share many similarities. In fact, FJ has been able to narrow down the list of features shared by his cows to a list of only K different features (1 ≤ K ≤ 30). For example, cows exhibiting feature #1 might have spots, cows exhibiting feature #2 might prefer C to Pascal, and so on.</p><p>FJ has even devised a concise way to describe each cow in terms of its “feature ID”, a single K-bit integer whose binary representation tells us the set of features exhibited by the cow. As an example, suppose a cow has feature ID = 13. Since 13 written in binary is 1101, this means our cow exhibits features 1, 3, and 4 (reading right to left), but not feature 2. More generally, we find a 1 in the 2^(i-1) place if a cow exhibits feature i.</p><p>Always the sensitive fellow, FJ lined up cows 1..N in a long row and noticed that certain ranges of cows are somewhat “balanced” in terms of the features the exhibit. A contiguous range of cows i..j is balanced if each of the K possible features is exhibited by the same number of cows in the range. FJ is curious as to the size of the largest balanced range of cows. See if you can determine it.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>Line 1: Two space-separated integers, N and K.<br>Lines 2..N+1: Line i+1 contains a single K-bit integer specifying the features present in cow i. The least-significant bit of this integer is 1 if the cow exhibits feature #1, and the most-significant bit is 1 if the cow exhibits feature #K.</p></div><br><strong>Output</strong><br><div class="note default"><p>Line 1: A single integer giving the size of the largest contiguous balanced group of cows.</p></div><br><strong>Sample Input</strong></p><blockquote><p>7 3<br>7<br>6<br>7<br>2<br>1<br>4<br>2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>4</p></blockquote><p><strong>Think</strong><br>说农夫有N头牛和K种特点，每头牛的特点用一个数字m表示，用这个数字m的二进制表示它所具有的特点，例如二进制1011，此时说明这头牛具有第1、3、4种特性。现在给出N头牛的特性的十进制表示。要求出从第i头牛到第j头牛这个区间之内，每一种特性出现次数是相同的。求这个区间的最大值。做法是先简单的将十进制转化成二进制。此时就出现N个二进制数列，求一个区间内出现次数相等很自然想到前缀和。以每一列为单位，从上到下求前缀和，用sum[][]记录。此时只要求sum[j][0]-sum[i][0]=sum[j][1]-sum[i][1]…=sum[j][k]-sum[i][k].将上式变换得到<br>sum[i][1]-sum[i][0]=sum[j][1]-sum[j][0]<br>sum[i][2]-sum[i][0]=sum[j][2]-sum[j][0]<br>…<br>sum[i][k]-sum[i][k]=sum[j][k]-sum[j][0]<br>因此，前缀和数组sum求每一行的每一个元素减去第一个元素即可，用c[][]保存。<br>例如样例中，可以先分解成：</p><blockquote><p>111<br>110<br>111<br>010<br>001<br>100<br>010  </p></blockquote><p>综上答案是从3-6之间才是合理的最大区间，每次特性都出现了两次。求前缀和之后sum数组如下</p><blockquote><p>111<br>221<br>332<br>342<br>343<br>443<br>453  </p></blockquote><p>现在纵向求前缀和之后很明显的sum[6]-sum[2]得到数列222。即是合理条件，答案就是j-i即是4。至于为什么区间从3-6变成了2-6，这个是前缀和的特性很好理解。忘了再处理一下变成数组c[][]：</p><blockquote><p>000<br>00-1<br>00-1<br>01-1<br>010<br>00-1<br>01-1  </p></blockquote><p>根据上面的推导可知。现在只需要找到两行相距最远的i和j使得c[i] == c[j]，然后答案就是j-i。再接下来就是正常的整型数组离散化找最大区间。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 99997</span></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">100010</span>][<span class="number">40</span>];<span class="comment">//保存二进制属性</span></span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">100100</span>][<span class="number">40</span>];<span class="comment">//保存二进制前缀和</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">100010</span>][<span class="number">40</span>];<span class="comment">//保存sum中每一列减去第一列的数据</span></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> Max_ans;<span class="comment">//最大区间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span> <span class="title">HASH</span>&#123;</span><span class="comment">//使用连地址法时利用new对象来动态分配空间比手动申请链表好的多。</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="keyword">int</span> i;<span class="comment">//保存C数组中的下标i</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">HASH</span>* <span class="title">next</span>;</span></span><br><span class="line">        HASH()</span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="number">0</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;HashTable;</span><br><span class="line">HashTable* Hash[<span class="number">100010</span>];<span class="comment">//链地址的头部</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//不知道为啥我编译器自带的绝对值函数丢失</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span> ? n : -n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span><span class="comment">//判断重复数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;i &lt; n; ++i,++j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c[p1][i]!= c[p2][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//其实就是key键值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        sum += c[p][i];</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="built_in">abs</span> (sum)%mod;<span class="comment">//被哈希的数组中有可能产生负值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Hash[sum] == <span class="number">0</span>)&#123;</span><br><span class="line">        HashTable* in = <span class="keyword">new</span> HashTable;</span><br><span class="line">        Hash[sum] = in;</span><br><span class="line">        in-&gt;i = p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//处理散列冲突，相同键值的数组有可能是重复的。</span></span><br><span class="line">        HashTable* in = Hash[sum];<span class="comment">//先将头部地址取出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp(p,in-&gt;i))&#123;<span class="comment">//如果两数组重复，那么尝试更新答案最大值</span></span><br><span class="line">                <span class="keyword">int</span> dis = p - in-&gt;i;</span><br><span class="line">                <span class="keyword">if</span> (Max_ans &lt; dis)&#123;</span><br><span class="line">                    Max_ans = dis;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ;<span class="comment">/*假设这次进入的是p，它和以前某次i相等了。</span></span><br><span class="line"><span class="comment">                那么根本不需要把这次p加入哈希表，因为如果后面又有一个j和这次p相等</span></span><br><span class="line"><span class="comment">                那么j也一定和i相等，并且由于i是比p更早出现的所以j-i一定大于j-p，</span></span><br><span class="line"><span class="comment">                因此对于相同数列每次只需要保存最先出现的那个即可*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in-&gt;next == <span class="number">0</span>)&#123;<span class="comment">//到头了把c[p]加入哈希表</span></span><br><span class="line">                HashTable* temp = <span class="keyword">new</span> HashTable;</span><br><span class="line">                temp-&gt;i = p;</span><br><span class="line">                in-&gt;next = temp;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            in = in-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> index)</span><span class="comment">//二进制转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        buf[index][i] = k%<span class="number">2</span>;</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;m,&amp;n))&#123;</span><br><span class="line">        Max_ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(Hash,<span class="number">0</span>,<span class="keyword">sizeof</span> Hash);</span><br><span class="line">        hash(<span class="number">0</span>);<span class="comment">//不知道为啥一定要先把0放入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;<span class="comment">//转化成二进制</span></span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">            change(k,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++j)&#123;<span class="comment">//求纵向前缀和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">                buf[i][j] += buf[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;<span class="comment">//求每列减去第一列的值。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++j)&#123;</span><br><span class="line">                c[i][j] = buf[i][j] - buf[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">            hash(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,Max_ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=3274&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-3274 Gold Balanced Lineup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Farmer John’s N cows (1 ≤ N ≤ 100,000) share many similarities. In fact, FJ has been able to narrow down the list of features shared by his cows to a list of only K different features (1 ≤ K ≤ 30). For example, cows exhibiting feature #1 might have spots, cows exhibiting feature #2 might prefer C to Pascal, and so on.&lt;/p&gt;
&lt;p&gt;FJ has even devised a concise way to describe each cow in terms of its “feature ID”, a single K-bit integer whose binary representation tells us the set of features exhibited by the cow. As an example, suppose a cow has feature ID = 13. Since 13 written in binary is 1101, this means our cow exhibits features 1, 3, and 4 (reading right to left), but not feature 2. More generally, we find a 1 in the 2^(i-1) place if a cow exhibits feature i.&lt;/p&gt;
&lt;p&gt;Always the sensitive fellow, FJ lined up cows 1..N in a long row and noticed that certain ranges of cows are somewhat “balanced” in terms of the features the exhibit. A contiguous range of cows i..j is balanced if each of the K possible features is exhibited by the same number of cows in the range. FJ is curious as to the size of the largest balanced range of cows. See if you can determine it.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="哈希" scheme="https://amannix.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>POJ-3349 Snowflake Snow Snowflakes(除留取余法，链地址法)</title>
    <link href="https://amannix.github.io/2018/10/11/POJ-3349/"/>
    <id>https://amannix.github.io/2018/10/11/POJ-3349/</id>
    <published>2018-10-11T04:03:11.000Z</published>
    <updated>2018-10-11T04:48:22.273Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=3349" target="_blank" rel="noopener">POJ-3349 Snowflake Snow Snowflakes</a></p><p><strong>Description</strong><br><div class="note default"><p>You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line of input will contain a single integer n, 0 &lt; n ≤ 100000, the number of snowflakes to follow. This will be followed by n lines, each describing a snowflake. Each snowflake will be described by a line containing six integers (each integer is at least 0 and less than 10000000), the lengths of the arms of the snow ake. The lengths of the arms will be given in order around the snowflake (either clockwise or counterclockwise), but they may begin with any of the six arms. For example, the same snowflake could be described as 1 2 3 4 5 6 or 4 3 2 1 6 5.</p></div><br><strong>Output</strong><br><div class="note default"><p>If all of the snowflakes are distinct, your program should print the message:<br>No two snowflakes are alike.<br>If there is a pair of possibly identical snow akes, your program should print the message:<br>Twin snowflakes found.</p></div><br><strong>Sample Input</strong></p><blockquote><p>2<br>1 2 3 4 5 6<br>4 3 2 1 6 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Twin snowflakes found.</p></blockquote><p><strong>Think</strong><br>emmm，一题灰常棒的哈希题，给出N组数列，每组数列六个数字。对于两组相同数列的定义为：将数列拼接成环之后两个环可以完全契合，即两环顺序相同。</p><blockquote><p>《算法精解：C语言描述》上提到的一种简单的将键值k映射到m槽位的方法：hash(k)=k mod m。而该书上写了一段话：“通常情况下，要避免m取2的幂，因为假设m=2^p，则h(k)是k的二进制数的低p位……，通常选择m会是一个素数，而且不那么靠近2的幂……”。这段话理由是：从概率的角度，出现相同的概率比较高，而通常我们希望 h(k) 的值依赖于 k 的所有位而不是最低 p 位，因为这样才会使得散列表看起来更均匀。当m不是素数时在散列分布时也会增加分布不均匀的机会，总的来说哈希函数的设计尽量使键值均匀、随机地分布在表中，其他方法可以参考《算法导论》。</p></blockquote><p>我们可以利用除留取余法，将数列中所有的值都对m取余。得到结果再取余。或者直接全部相加再取余得到键值。但是这样会产生一个致命的问题就是可能产生相同键值的散列，这时便应该使用链地址法处理散列冲突。之后我们可以发现只有键值相同的数列才有可能相等，所以在线输入的时候便可以在处理冲突的时候顺便把所有键值相同的数列比较一遍。<br>之所以不采用线性探测法是因为数据范围过大，所需哈希空间也大，设计不好的话很可能爆范围。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 14997</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">6</span>];</span><br><span class="line">&#125;code[<span class="number">15000</span>][<span class="number">100</span>];<span class="comment">//一维数组代表key值映射，二维存储相应的key值的冲突数列</span></span><br><span class="line"><span class="keyword">int</span> code_index[<span class="number">15000</span>];<span class="comment">//记录对应key值的冲突数量</span></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">15000</span>][<span class="number">100</span>];<span class="comment">//vis标记哈希表是否被占用，</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> buf[])</span><span class="comment">//hash函数求整型数组的键值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">        num += buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> m[],<span class="keyword">int</span> n[])</span><span class="comment">//比较函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>;s &lt; <span class="number">6</span>; ++s)&#123;<span class="comment">//正序环形比较</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = s; i &lt; <span class="number">6</span>; ++i,j = (j+<span class="number">1</span>)%<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="comment">//printf ("%d %d\n",i,j);</span></span><br><span class="line">            <span class="keyword">if</span> (m[i] != n[j])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>;s &lt; <span class="number">6</span>; ++s)&#123;<span class="comment">//逆序环形比较</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = s;i &lt; <span class="number">6</span>; ++i,j = (j+<span class="number">5</span>)%<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="comment">//printf ("%d %d\n",i,j);</span></span><br><span class="line">            <span class="keyword">if</span> (m[i] != n[j])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line">    Node temp;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">while</span> (--n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;temp.a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> num = hash(temp.a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis[num][<span class="number">0</span>] == <span class="literal">true</span>)&#123;<span class="comment">//处理散列冲突</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; code_index[num]; ++i)&#123;<span class="comment">//只有key值相同的数列才有可能相同，</span></span><br><span class="line">                <span class="comment">//然后在对应的冲突集合中一一比较</span></span><br><span class="line">                <span class="keyword">if</span> (cmp(code[num][i].a,temp.a) == <span class="literal">true</span>)&#123;<span class="comment">//一旦有某次相同，则直接输出.</span></span><br><span class="line">                    <span class="built_in">printf</span> (<span class="string">"Twin snowflakes found.\n"</span>);</span><br><span class="line">                    <span class="comment">//return 0;</span></span><br><span class="line">                    ans = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[num][code_index[num]] = <span class="literal">true</span>;</span><br><span class="line">            code[num][code_index[num]++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//非冲突情况</span></span><br><span class="line">            vis[num][code_index[num]] = <span class="literal">true</span>;</span><br><span class="line">            code[num][code_index[num]++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"No two snowflakes are alike.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=3349&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-3349 Snowflake Snow Snowflakes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="哈希" scheme="https://amannix.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
</feed>
