<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiong&#39;blog</title>
  
  <subtitle>渡得八千风沙起，揽下九天明月心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-15T16:33:24.009Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>熊梦彪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>POJ-1679 Unique MST(判断最小生成树是否唯一)</title>
    <link href="http://yoursite.com/2018/08/16/POJ-1679%20Unique%20MST/"/>
    <id>http://yoursite.com/2018/08/16/POJ-1679 Unique MST/</id>
    <published>2018-08-15T17:28:21.000Z</published>
    <updated>2018-08-15T16:33:24.009Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://poj.org/problem?id=1679" target="_blank" rel="noopener">POJ-1679 Unique MST</a>  </p><p><strong>Description</strong></p><p>Given a connected undirected graph, tell if its minimum spanning tree is unique. </p><p>Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: </p><ol><li>V’ = V. </li><li>T is connected and acyclic. </li></ol><p>Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’.<br><a id="more"></a><br><strong>Input</strong></p><p>The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. Each case represents a graph. It begins with a line containing two integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the following m lines contains a triple (xi, yi, wi), indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them.<br><strong>Output</strong></p><p>For each input, if the MST is unique, print the total cost of it, or otherwise print the string ‘Not Unique!’.<br><strong>Sample Input</strong></p><p>2<br>3 3<br>1 2 1<br>2 3 2<br>3 1 3<br>4 4<br>1 2 2<br>2 3 2<br>3 4 2<br>4 1 2<br><strong>Sample Output</strong></p><p>3<br>Not Unique!</p><p><strong>思路</strong><br>选择邻接矩阵存图，读取边的时候先判断是否存在两条相同的边，如果存在则MST不唯一。再做出最小生成树，将所有已经使用过的边，依次从邻接矩阵中删除，再求最小生成树<br>如果两次答案一致，则MST不唯一。不要忘记删除过的边要再放回去。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,e,v;</span><br><span class="line">&#125;edg[<span class="number">205</span>];<span class="comment">//记录最小生成树所包含的边的信息</span></span><br><span class="line"><span class="keyword">int</span> ma[<span class="number">205</span>][<span class="number">205</span>],cnt;<span class="comment">//cnt记录最小生成树的边的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">bool</span> bug)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v &gt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> cnt,<span class="keyword">int</span> n,<span class="keyword">int</span> ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(edg,edg+cnt,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cnt; ++i)&#123;</span><br><span class="line">        <span class="comment">/*将每条使用过的边都从邻接矩阵中删除，再求一次最小生成树，</span></span><br><span class="line"><span class="comment">        如果与之前相同，则MST不唯一*/</span></span><br><span class="line">        ma[edg[i].s][edg[i].e] = Inf;</span><br><span class="line">        ma[edg[i].e][edg[i].s] = Inf;</span><br><span class="line">        <span class="keyword">if</span> (prime(n,<span class="literal">false</span>) == ans)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不要忘了删掉的边要再添加回去</span></span><br><span class="line">        ma[edg[i].s][edg[i].e] = edg[i].v;</span><br><span class="line">        ma[edg[i].e][edg[i].s] = edg[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">bool</span> bug)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">205</span>] = &#123;<span class="number">0</span>&#125;,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bug)&#123;<span class="comment">//bug变量标记在judge函数中调用不需要对edg做修改</span></span><br><span class="line">        <span class="built_in">memset</span>(edg,<span class="number">0</span>,<span class="keyword">sizeof</span> edg);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node temp[<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        temp[i].v = ma[<span class="number">1</span>][i];</span><br><span class="line">        temp[i].s = <span class="number">1</span>;</span><br><span class="line">        temp[i].e  = i;</span><br><span class="line">        <span class="comment">//printf ("%d\n",temp[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>,Min = Inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (Min &gt; temp[j].v &amp;&amp; !vis[j])&#123;</span><br><span class="line">                Min = temp[j].v;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bug)</span><br><span class="line">            edg[cnt++] = temp[index];</span><br><span class="line">        vis[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//printf ("%d\n",index);</span></span><br><span class="line">        ans += temp[index].v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[j].v &gt; ma[index][j])&#123;</span><br><span class="line">                temp[j].v = ma[index][j];</span><br><span class="line">                temp[j].s = index;</span><br><span class="line">                temp[j].e = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,m,n,a,b,c,ans;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ma,Inf,<span class="keyword">sizeof</span> ma);</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="keyword">if</span> (c == ma[a][b])&#123;<span class="comment">//判断是否存在两条相同的边。</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ma[a][b] = min(ma[a][b],c);<span class="comment">//每条边只取最小值</span></span><br><span class="line">            ma[b][a] = min(ma[b][a],c);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = prime(n,<span class="literal">true</span>);</span><br><span class="line">        judge(cnt,n,ans);</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"Not Unique!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://poj.org/problem?id=1679&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ-1679 Unique MST&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a connected undirected graph, tell if its minimum spanning tree is unique. &lt;/p&gt;
&lt;p&gt;Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;V’ = V. &lt;/li&gt;
&lt;li&gt;T is connected and acyclic. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’.&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="http://yoursite.com/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小生成树" scheme="http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PID算法小结</title>
    <link href="http://yoursite.com/2018/08/15/PID%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/15/PID算法小结/</id>
    <published>2018-08-15T08:25:21.000Z</published>
    <updated>2018-08-15T14:02:05.742Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在控制算法系统中，先设定一个目标值假设为S，再由传感器定时采样。假设读取的值为依次为X1，X2，X3……Xk。</p><a id="more"></a><h3 id="P-比例-控制"><a href="#P-比例-控制" class="headerlink" title="P(比例)控制:"></a>P(比例)控制:</h3><p>&emsp;&emsp;假设对每次采样的结果Xk，使<strong>Pk = S - Xk</strong>。其产生三种结果</p><blockquote><p>Pk &gt; 0  当前值未达标<br>Pk == 0  当前值已达标<br>Pk &lt; 0  当前值超标</p></blockquote><p>&emsp;&emsp;则在P控制中，<strong>TOUT = Kp * Pk</strong>，其中Kp为常数，起到一个等比例放大或缩小的作用<br>Pk实际意义便是与目标的差值，P控制的输出量由这个差值等比例放大决定。</p><h3 id="I-积分-控制"><a href="#I-积分-控制" class="headerlink" title="I(积分)控制"></a>I(积分)控制</h3><p>&emsp;&emsp;假设<strong>Sk = ∑Pn （n ∈[1,k]）</strong>。同样的，由于Pk的值有正有负。因此Sk的值也分为三种情况</p><blockquote><p>Sk &gt; 0  在过去的时间内，系统总体上是不达标的<br>Sk == 0   在过去的时间内，系统总体上是达标的<br>Sk &lt; 0   在过去的时间内，系统总体上是超标的</p></blockquote><p>&emsp;&emsp;此时<strong>TOUT = Kp * Sk</strong> 对应的是积分操作，由过去历史总体情况作出预测。缺点是较长时间之前的<br>数据也会对现在的预测产生影响。</p><h3 id="D-微分-控制"><a href="#D-微分-控制" class="headerlink" title="D(微分)控制"></a>D(微分)控制</h3><p>&emsp;&emsp;由于之前已经取得了每个采集样本的Pk值，即采集值与目标值的偏移量，使<strong>Dk = Pk - P(k-1)</strong><br>则Dk描述了此偏移量的变化的快慢。同样分为三种结果</p><blockquote><p>Dk &gt; 0<br>Dk == 0<br>Dk &lt; 0  </p></blockquote><p>&emsp;&emsp;此时的TOUT = Kp * Dk，显而易见这时的输出量由变化率决定。变化率越大，则输出值越大</p><h3 id="PID的数学模型"><a href="#PID的数学模型" class="headerlink" title="PID的数学模型"></a>PID的数学模型</h3><p>&emsp;&emsp;基于上式，最后输出值<strong>TOUT = Pout + Iout + Dout</strong><br>代入合并之后 <strong>Tout = (Kp <em> Pk) + (Kp </em> Sk) + (Kp * Dk)</strong></p><p>(关于Sk Dk的处理下次在写叭)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在控制算法系统中，先设定一个目标值假设为S，再由传感器定时采样。假设读取的值为依次为X1，X2，X3……Xk。&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式算法" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PID" scheme="http://yoursite.com/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>牛客网练习赛24-B凤凰</title>
    <link href="http://yoursite.com/2018/08/12/%E7%BB%83%E4%B9%A0%E8%B5%9B24-B%E5%87%A4%E5%87%B0/"/>
    <id>http://yoursite.com/2018/08/12/练习赛24-B凤凰/</id>
    <published>2018-08-11T17:28:21.000Z</published>
    <updated>2018-08-15T16:33:02.279Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.nowcoder.com/acm/contest/157/B" target="_blank" rel="noopener">牛客网练习赛24-B凤凰</a></p><p><strong>Describe</strong></p><blockquote><p>凤凰于飞，翙翙其羽，亦集爰止。<br>《诗经·卷阿》<br>传说，凤凰是百鸟之王。有一天，凤凰要召开百鸟大会，百鸟国是一个由n个节点组成的树，每个节点有一只鸟，开会的节点定在1号节点。每只鸟可以花费1s通过一条边，由于每根树枝(边)的载重有限，只允许一只鸟同时通过。作为会议的策划师，HtBest想知道百鸟国的所有鸟在1点集合最少需要多少秒。  </p></blockquote><a id="more"></a><p><strong>Input</strong></p><blockquote><p>第一行有一个正整数n，表示百鸟国节点个数。<br>接下来n-1行，第i行两个正整数ai,bi用空格隔开，表示树上节点ai,bi之间有一条边。</p></blockquote><p><strong>Output</strong></p><blockquote><p>第一行一个整数，表示集合最少需要的时间。</p></blockquote><p><strong>Example1</strong></p><blockquote><p>Input<br>3<br>1 2<br>2 3<br>Output<br>2</p></blockquote><p><strong>Example2</strong></p><blockquote><p>Input<br>3<br>1 2<br>1 3<br>Output<br>1</p></blockquote><p><strong>Example3</strong></p><blockquote><p>Input<br>4<br>1 2<br>2 3<br>2 4<br>Output<br>3</p></blockquote><p><strong>Remark</strong></p><blockquote><p>对于100%的测试数据：<br>1 ≤ n ≤ 1000000<br>数据量较大，注意使用更快的输入输出方式。</p></blockquote><p>&emsp;&emsp;首先明确每一个节点上都存在一只鸟，假设存在n条通往根节点（1）的路径。因此可以得到有n颗子树挂载在根节点上，不难发现所有子树上如果有m只鸟那么想要全部到达根节点必定要花费m秒。<br>&emsp;&emsp;由于每一个节点必定存在一只鸟，因此不难证明不存在子树上有某只鸟还没通过靠近根节点路径，但是其他鸟已经全部抵达的情况。还有就是题目明确指出是树形结构，所以也不存在一颗子树存在两条通往根节点的路径的情况，否则便是图形结构。<br>&emsp;&emsp;因此题目转化为求最大子树的节点数。两种思路可广搜遍历子树求得节点数，更为便捷的方式是并查集求解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ll F[maxn],sum[maxn];</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == F[u] ? u : F[u] = find(F[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_union</span><span class="params">(ll u,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x = find(u),y = find(v);</span><br><span class="line">    <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">        F[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cnt;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;cnt);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= cnt; ++i)&#123;</span><br><span class="line">        F[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt; cnt; ++i)&#123;</span><br><span class="line">        ll a,b;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%lld%lld"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">1</span> &amp;&amp; b != <span class="number">1</span>)<span class="comment">//由于题目给出的是整颗数，所以要排除根节点以外求子树</span></span><br><span class="line">            fun_union(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= cnt; ++i)&#123;</span><br><span class="line">        ++sum[F[find(i)]];<span class="comment">//求不同子树的节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,*max_element(sum+<span class="number">1</span>,sum+cnt+<span class="number">1</span>));<span class="comment">//该函数求区间内最大值，返回一个指针。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/157/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网练习赛24-B凤凰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Describe&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;凤凰于飞，翙翙其羽，亦集爰止。&lt;br&gt;《诗经·卷阿》&lt;br&gt;传说，凤凰是百鸟之王。有一天，凤凰要召开百鸟大会，百鸟国是一个由n个节点组成的树，每个节点有一只鸟，开会的节点定在1号节点。每只鸟可以花费1s通过一条边，由于每根树枝(边)的载重有限，只允许一只鸟同时通过。作为会议的策划师，HtBest想知道百鸟国的所有鸟在1点集合最少需要多少秒。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="http://yoursite.com/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
