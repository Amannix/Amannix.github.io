<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiong&#39;blog</title>
  
  <subtitle>渡得八千风沙起，揽下九天明月心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://amannix.github.io/"/>
  <updated>2018-11-17T11:30:57.465Z</updated>
  <id>https://amannix.github.io/</id>
  
  <author>
    <name>熊梦彪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Good Array(思维)</title>
    <link href="https://amannix.github.io/2018/11/17/Good%20Array/"/>
    <id>https://amannix.github.io/2018/11/17/Good Array/</id>
    <published>2018-11-17T11:01:56.000Z</published>
    <updated>2018-11-17T11:30:57.465Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：[<a href="http://codeforces.com/contest/1077/problem/C" target="_blank" rel="noopener">Codeforces Round #521(Div.3) Good Array</a><br><strong>Description</strong><br><div class="note default"><p>Let’s call an array good if there is an element in the array that equals to the sum of all other elements. For example, the array a=[1,3,3,7] is good because there is the element a4=7 which equals to the sum 1+3+3.</p><p>You are given an array aa consisting of n integers. Your task is to print all indices jj of this array such that after removing the j-th element from the array it will be good (let’s call such indices nice).</p><p>For example, if a=[8,3,5,2], the nice indices are 1 and 4:</p><blockquote><p>if you remove a1a1, the array will look like [3,5,2] and it is good;<br>if you remove a4a4, the array will look like [8,3,5] and it is good.</p></blockquote><p>You have to consider all removals independently, i. e. remove the element, check if the resulting array is good, and return the element into the array.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line of the input contains one integer nn (2≤n≤2⋅10^5) — the number of elements in the array a.</p><p>The second line of the input contains nn integers a1,a2,…,an (1≤ai≤10^6) — elements of the array a.</p></div><br><strong>Output</strong><br><div class="note default"><p>In the first line print one integer k — the number of indices j of the array aa such that after removing the j-th element from the array it will be good (i.e. print the number of the nice indices).</p><p>In the second line print k distinct integers j1,j2,…,jk in any order — nice indices of the array a.</p><p>If there are no such indices in the array a, just print 0 in the first line and leave the second line empty or do not print it at all.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>2 5 1 2 2  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>3<br>4 1 5  </p></blockquote><p><strong>Thinking</strong><br>首先定义一个序列，如果该序列满足有任意某个元素等于其他元素之和，那么称该序列good，现在给出一个序列，问能否删除某一个元素，使得剩下的元素组成的序列是good。要求输出删除的元素是哪些。<br>先预处理序列总和，然后枚举序列的每一个元素，假设删除这个元素，那么用总的长度减去这个元素就是剩下的元素总和，不难得到一个good序列一定满足其和sum是一个偶数，并且sum/2一定在序列中出现。现在判断删除该元素以后剩下的数字总和是否是偶数并且sum/2在剩下的序列中出现过，在输入的时候用一个桶计数即可。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> buf[<span class="number">200010</span>],pre_sum[<span class="number">200010</span>],ans[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; buf[i];</span><br><span class="line">        ++tong[buf[i]];</span><br><span class="line">        pre_sum[i] = pre_sum[i<span class="number">-1</span>] + buf[i];<span class="comment">//这里一开始做的时候记录了前缀和，但是实际上只需要求总和就行了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp_sum = (pre_sum[i<span class="number">-1</span>] - pre_sum[<span class="number">0</span>] + pre_sum[t] - pre_sum[i]);</span><br><span class="line">        <span class="keyword">if</span> (temp_sum/<span class="number">2</span> &gt; <span class="number">1e6</span>) <span class="keyword">continue</span>;<span class="comment">/*这里一个坑RE了两发，由于使用桶计数判断数字出现次数，</span></span><br><span class="line"><span class="comment">        但是temp_sum/2的值有可能会非常大，代入数组中就会引发非法内存引用*/</span></span><br><span class="line">        <span class="comment">//判断temp_sum/2在剩余序列中出现过</span></span><br><span class="line">        <span class="keyword">if</span> (temp_sum%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; tong[temp_sum/<span class="number">2</span>] &gt; <span class="number">0</span> &amp;&amp; (temp_sum/<span class="number">2</span> != buf[i] || tong[temp_sum/<span class="number">2</span>] &gt; <span class="number">1</span>))&#123;</span><br><span class="line">            ans[p++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p; ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：[&lt;a href=&quot;http://codeforces.com/contest/1077/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round #521(Div.3) Good Array&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Let’s call an array good if there is an element in the array that equals to the sum of all other elements. For example, the array a=[1,3,3,7] is good because there is the element a4=7 which equals to the sum 1+3+3.&lt;/p&gt;
&lt;p&gt;You are given an array aa consisting of n integers. Your task is to print all indices jj of this array such that after removing the j-th element from the array it will be good (let’s call such indices nice).&lt;/p&gt;
&lt;p&gt;For example, if a=[8,3,5,2], the nice indices are 1 and 4:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;if you remove a1a1, the array will look like [3,5,2] and it is good;&lt;br&gt;if you remove a4a4, the array will look like [8,3,5] and it is good.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You have to consider all removals independently, i. e. remove the element, check if the resulting array is good, and return the element into the array.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="杂题" scheme="https://amannix.github.io/tags/%E6%9D%82%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Disturbed People(队列)</title>
    <link href="https://amannix.github.io/2018/11/17/Disturbed%20People/"/>
    <id>https://amannix.github.io/2018/11/17/Disturbed People/</id>
    <published>2018-11-17T10:44:01.000Z</published>
    <updated>2018-11-17T11:31:16.792Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1077/problem/B" target="_blank" rel="noopener">Codeforces Round #521(Div.3) Disturbed People</a><br><strong>Description</strong><br><div class="note default"><p>There is a house with nn flats situated on the main street of Berlatov. Vova is watching this house every night. The house can be represented as an array of nn integer numbers a1,a2,…,an where ai=1 if in the i-th flat the light is on and ai=0ai=0 otherwise.</p><p>Vova thinks that people in the i-th flats are disturbed and cannot sleep if and only if 1&lt;i&lt;n and ai−1=ai+1=1 and ai=0.</p><p>Vova is concerned by the following question: what is the minimum number k such that if people from exactly kk pairwise distinct flats will turn off the lights then nobody will be disturbed? Your task is to find this number k.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line of the input contains one integer nn (3≤n≤100) — the number of flats in the house.</p><p>The second line of the input contains nn integers a1,a2,…,an (ai∈{0,1}), where aiai is the state of light in the ii-th flat.</p></div><br><strong>Output</strong><br><div class="note default"><p>Print only one integer — the minimum number k such that if people from exactly kk pairwise distinct flats will turn off the light then nobody will be disturbed.</p></div><br><strong>Sample Input</strong></p><blockquote><p>10<br>1 1 0 1 1 0 1 0 1 0  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>5<br>1 1 0 0 0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0</p></blockquote><p><strong>Thinking</strong><br>给出一个由0 1 组成的序列，1代表开着灯，0代表关了灯。定义如果一个位置ai=0，但是其左右位置为1，那么说这个位置被干扰了。现在可以使某些灯关闭，使得整个序列都没有人被干扰，求最少需要关闭多少灯。<br>可以知道假设有N个人被干扰，那么最多就需要关闭N盏灯。我们可以先遍历一遍序列，找到所有被干扰的位置加入一个队列，然后每次取出队首和次队首元素。判断这两个元素是否相邻（两个被干扰的位置相邻就意味着其本身位置相差2），如果相邻则弹出两个元素，否则弹出一个元素。接下来记录循环的次数即是答案。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> t,buf[<span class="number">1000</span>],ans = INF;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把所有被干扰的位置加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= t; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[j] == <span class="number">0</span> &amp;&amp; buf[j+<span class="number">1</span>] == buf[j<span class="number">-1</span>] &amp;&amp; buf[j<span class="number">-1</span>] == <span class="number">1</span> &amp;&amp; j<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; j+<span class="number">1</span> &lt;= t)&#123;</span><br><span class="line">            que.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())&#123;<span class="comment">//出队判断</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">        a = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (!que.empty())&#123;</span><br><span class="line">            b = que.front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a+<span class="number">1</span> == b<span class="number">-1</span>)&#123;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ++sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1077/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round #521(Div.3) Disturbed People&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;There is a house with nn flats situated on the main street of Berlatov. Vova is watching this house every night. The house can be represented as an array of nn integer numbers a1,a2,…,an where ai=1 if in the i-th flat the light is on and ai=0ai=0 otherwise.&lt;/p&gt;
&lt;p&gt;Vova thinks that people in the i-th flats are disturbed and cannot sleep if and only if 1&amp;lt;i&amp;lt;n and ai−1=ai+1=1 and ai=0.&lt;/p&gt;
&lt;p&gt;Vova is concerned by the following question: what is the minimum number k such that if people from exactly kk pairwise distinct flats will turn off the lights then nobody will be disturbed? Your task is to find this number k.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-839 Not so Mobile (二叉树的DFS)</title>
    <link href="https://amannix.github.io/2018/11/17/UVA-839/"/>
    <id>https://amannix.github.io/2018/11/17/UVA-839/</id>
    <published>2018-11-17T10:27:25.000Z</published>
    <updated>2018-11-17T11:31:33.693Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-839" target="_blank" rel="noopener">Not so Mobile</a><br><strong>Description</strong><br><div class="note default"><p>Each year, fall in the North Central region is accompanied by the brilliant colors of the leaves on the trees, followed quickly by the falling leaves accumulating under the trees. If the same thing happened to binary trees, how large would the piles of leaves become?<br>We assume each node in a binary tree ”drops” a number of leaves equal to the integer value stored in that node. We also assume that these leaves drop vertically to the ground (thankfully, there’s no wind to blow them around). Finally, we assume that the nodes are positioned horizontally in such a manner that the left and right children of a node are exactly one unit to the left and one unit to the right, respectively, of their parent.<br>The nodes containing 5 and 6 have the same horizontal position (with different vertical positions, of course). The node containing 7 is one unit to the left of those containing 5 and 6, and the node containing 3 is one unit to their right. When the ”leaves” drop from these nodes, three piles are created: the leftmost one contains 7 leaves (from the leftmost node), the next contains 11 (from the nodes containing 5 and 6), and the rightmost pile contains 3. (While it is true that only leaf nodes in a tree would logically have leaves, we ignore that in this problem.)</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The input contains multiple test cases, each describing a single tree. A tree is specified by giving the value in the root node, followed by the description of the left subtree, and then the description of the right subtree. If a subtree is empty, the value ‘-1’ is supplied. Thus the tree shown above is specified as ‘5 7 -1 6 -1 -1 3 -1 -1’. Each actual tree node contains a positive, non-zero value. The last test case is followed by a single ‘-1’ (which would otherwise represent an empty tree).</p></div><br><strong>Output</strong><br><div class="note default"><p>For each test case, display the case number (they are numbered sequentially, starting with 1) on a line by itself. On the next line display the number of “leaves” in each pile, from left to right, with a single space separating each value. This display must start in column 1, and will not exceed the width of an 80-character line. Follow the output for each case by a blank line. This format is illustrated in the examples below.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5 7 -1 6 -1 -1 3 -1 -1<br>8 2 9 -1 -1 6 5 -1 -1 12 -1<br>-1 3 7 -1 -1 -1<br>-1  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Case 1:<br>7 11 3<br>Case 2:<br>9 7 21 15</p></blockquote><p><strong>Thinking</strong><br>题目给出二叉树的前序遍历，如果序列中为-1则代表没有该节点，然后求从左往右有多少列节点，求每一列节点的和。这题主要是在建树的时候比较巧妙，直接前序递归，在递归程序中输入数据，当输入-1的时候return即可，形参的位置代表这颗树的列数，特别地，定义根节点的列的位置为maxn/2，manx为数的最大列数。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span><span class="comment">//前序dfs</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    sum[root] += v;<span class="comment">//root代表当前这一列的位置</span></span><br><span class="line">    dfs(root<span class="number">-1</span>);</span><br><span class="line">    dfs(root+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span><span class="comment">//输入判断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = maxn/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span> sum);</span><br><span class="line">    sum[root] += v;</span><br><span class="line">    dfs(root<span class="number">-1</span>);</span><br><span class="line">    dfs(root+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,ca = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (init())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ca++ &lt;&lt; <span class="string">":\n"</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!sum[++p]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum[p++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p;sum[i]; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; sum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-839&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Not so Mobile&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Each year, fall in the North Central region is accompanied by the brilliant colors of the leaves on the trees, followed quickly by the falling leaves accumulating under the trees. If the same thing happened to binary trees, how large would the piles of leaves become?&lt;br&gt;We assume each node in a binary tree ”drops” a number of leaves equal to the integer value stored in that node. We also assume that these leaves drop vertically to the ground (thankfully, there’s no wind to blow them around). Finally, we assume that the nodes are positioned horizontally in such a manner that the left and right children of a node are exactly one unit to the left and one unit to the right, respectively, of their parent.&lt;br&gt;The nodes containing 5 and 6 have the same horizontal position (with different vertical positions, of course). The node containing 7 is one unit to the left of those containing 5 and 6, and the node containing 3 is one unit to their right. When the ”leaves” drop from these nodes, three piles are created: the leftmost one contains 7 leaves (from the leftmost node), the next contains 11 (from the nodes containing 5 and 6), and the rightmost pile contains 3. (While it is true that only leaf nodes in a tree would logically have leaves, we ignore that in this problem.)&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-548 Tree (从中序和后续恢复二叉树)</title>
    <link href="https://amannix.github.io/2018/11/17/UVA-548/"/>
    <id>https://amannix.github.io/2018/11/17/UVA-548/</id>
    <published>2018-11-17T08:03:35.000Z</published>
    <updated>2018-11-17T11:31:53.392Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-548" target="_blank" rel="noopener">Tree</a><br><strong>Description</strong><br><div class="note default"><p>You are to determine the value of the leaf node in a given binary tree that is the terminal node of a path of least value from the root of the binary tree to any leaf. The value of a path is the sum of values of nodes along that path.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The input file will contain a description of the binary tree given as the inorder and postorder traversal sequences of that tree. Your program will read two line (until end of file) from the input file. The first line will contain the sequence of values associated with an inorder traversal of the tree and the second line will contain the sequence of values associated with a postorder traversal of the tree. All values will be different, greater than zero and less than 10000. You may assume that no binary tree will have more than 10000 nodes or less than 1 node.</p></div><br><strong>Output</strong><br><div class="note default"><p>For each tree description you should output the value of the leaf node of a path of least value. In the case of multiple paths of least value you should pick the one with the least value on the terminal node.</p></div><br><strong>Sample Input</strong></p><blockquote><p>3 2 1 4 5 7 6<br>3 1 2 5 6 7 4<br>7 8 11 3 5 16 12 18<br>8 3 11 7 16 18 12 5<br>255<br>255</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1<br>3<br>255</p></blockquote><p><strong>Thinking</strong><br>给出二叉树的中序和后序遍历求根节点到叶子节点的最短路径，权值在节点上。输入格式有点问题，所以参照刘大爷的紫书。然后递归建树这个比较厉害一点，详见代码。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> in_order[Max],post_order[Max];</span><br><span class="line"><span class="keyword">int</span> lchild[Max],rchild[Max];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max_ans,best;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_list</span><span class="params">(<span class="keyword">int</span> *a)</span><span class="comment">//参照刘大爷的紫书</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">if</span>(!getline(<span class="built_in">cin</span>, line))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(ss &gt;&gt; x)&#123;</span><br><span class="line">        a[n++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span></span>&#123;<span class="comment">//四个参数分别代表左右子树对应的中序和后序的区间</span></span><br><span class="line">    <span class="keyword">if</span>(L1 &gt; R1) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> root = post_order[R2];<span class="comment">//该子树的根节点一定是后序遍历的最后一个</span></span><br><span class="line">    <span class="keyword">int</span> p = L1;</span><br><span class="line">    <span class="keyword">while</span>(in_order[p] != root) ++p;<span class="comment">//找到根节点在中序遍历的位置</span></span><br><span class="line">    <span class="keyword">int</span> cnt = p - L1;</span><br><span class="line">    <span class="comment">//下面理解一下左右子树递归时区间的选取规则</span></span><br><span class="line">    lchild[root] = build(L1, p - <span class="number">1</span>, L2, L2 + cnt - <span class="number">1</span>);</span><br><span class="line">    rchild[root] = build(p + <span class="number">1</span>, R1, L2 + cnt, R2 - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum += root;</span><br><span class="line">    <span class="keyword">if</span> (lchild[root] == <span class="number">-1</span> &amp;&amp; rchild[root] == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (max_ans &gt; sum || (max_ans == sum &amp;&amp; best &gt; root))&#123;</span><br><span class="line">            max_ans = sum;</span><br><span class="line">            best = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lchild[root])    DFS(lchild[root],sum);</span><br><span class="line">    <span class="keyword">if</span> (rchild[root])    DFS(rchild[root],sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (read_list(in_order))&#123;</span><br><span class="line">        read_list(post_order);</span><br><span class="line">        build(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        max_ans = INF;</span><br><span class="line">        best = INF;</span><br><span class="line">        DFS(post_order[n<span class="number">-1</span>],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; best &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-548&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tree&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;You are to determine the value of the leaf node in a given binary tree that is the terminal node of a path of least value from the root of the binary tree to any leaf. The value of a path is the sum of values of nodes along that path.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-679 Dropping Balls(完全二叉树编号)</title>
    <link href="https://amannix.github.io/2018/11/17/UVA%20-%20679%20Dropping%20Balls/"/>
    <id>https://amannix.github.io/2018/11/17/UVA - 679 Dropping Balls/</id>
    <published>2018-11-17T07:07:35.000Z</published>
    <updated>2018-11-17T11:32:09.492Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong><br>传送门：[UVA-679 Dropping Balls]{<a href="https://vjudge.net/problem/UVA-679}" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-679}</a><br><div class="note default"><p>A number of K balls are dropped one by one from the root of a fully binary tree structure FBT. Each time the ball being dropped first visits a non-terminal node. It then keeps moving down, either follows the path of the left subtree, or follows the path of the right subtree, until it stops at one of the leaf nodes of FBT. To determine a ball’s moving direction a flag is set up in every non-terminal node with two values, either false or true. Initially, all of the flags are false. When visiting a non-terminal node if the flag’s current value at this node is false, then the ball will first switch this flag’s value, i.e., from the false to the true, and then follow the left subtree of this node to keep moving down. Otherwise, it will also switch this flag’s value, i.e., from the true to the false, but will follow the right subtree of this node to keep moving down. Furthermore, all nodes of FBT are sequentially numbered, starting at 1 with nodes on depth 1, and then those on depth 2, and so on. Nodes on any depth are numbered from left to right.<br>For example, Fig. 1 represents a fully binary tree of maximum depth 4 with the node numbers 1, 2, 3, …, 15. Since all of the flags are initially set to be false, the first ball being dropped will switch flag’s values at node 1, node 2, and node 4 before it finally stops at position 8. The second ball being dropped will switch flag’s values at node 1, node 3, and node 6, and stop at position 12. Obviously, the third ball being dropped will switch flag’s values at node 1, node 2, and node 5 before it stops at position 10.<br><img src="https://github.com/Amannix/Amannix.github.io/tree/master/images/UVA-679.png" alt=""></p><p><center>Fig. 1: An example of FBT with the maximum depth 4 and sequential node numbers.</center><br>Now consider a number of test cases where two values will be given for each test. The first value is D, the maximum depth of FBT, and the second one is I, the I-th ball being dropped. You may assume the value of I will not exceed the total number of leaf nodes for the given FBT. Please write a program to determine the stop position P for each test case.<br>For each test cases the range of two parameters D and I is as below:</p><enter>2 ≤ D ≤ 20, and 1 ≤ I ≤ 524288.</enter></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>Contains l + 2 lines.<br>Line 1 l the number of test cases<br>Line 2 D1 I1 test case #1, two decimal numbers that are separated by one blank<br>…<br>Line k + 1 Dk Ik test case #k<br>Line l + 1 Dl Il test case #l<br>Line l + 2 -1 a constant ‘-1’ representing the end of the input file</p></div><br><strong>Output</strong><br><div class="note default"><p>Contains l lines.<br>Line 1 the stop position P for the test case #1<br>…<br>Line k the stop position P for the test case #k<br>…<br>Line l the stop position P for the test case #l</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>4 2<br>3 4<br>10 1<br>2 2<br>8 128<br>-1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>12<br>7<br>512<br>3<br>255</p></blockquote><p><strong>Thinking</strong><br>给出一颗满二叉树的深度，一个球从顶点下落，每个点有一个状态，true时小球右转，false小球左转，每次小球经过节点的时候会转换状态。每给出一组数据，根据奇偶性判断转向。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a,b;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (b % <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                    b = (b + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans = ans &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">                    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;传送门：[UVA-679 Dropping Balls]{&lt;a href=&quot;https://vjudge.net/problem/UVA-679}&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://vjudge.net/problem/UVA-679}&lt;/a&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;A number of K balls are dropped one by one from the root of a fully binary tree structure FBT. Each time the ball being dropped first visits a non-terminal node. It then keeps moving down, either follows the path of the left subtree, or follows the path of the right subtree, until it stops at one of the leaf nodes of FBT. To determine a ball’s moving direction a flag is set up in every non-terminal node with two values, either false or true. Initially, all of the flags are false. When visiting a non-terminal node if the flag’s current value at this node is false, then the ball will first switch this flag’s value, i.e., from the false to the true, and then follow the left subtree of this node to keep moving down. Otherwise, it will also switch this flag’s value, i.e., from the true to the false, but will follow the right subtree of this node to keep moving down. Furthermore, all nodes of FBT are sequentially numbered, starting at 1 with nodes on depth 1, and then those on depth 2, and so on. Nodes on any depth are numbered from left to right.&lt;br&gt;For example, Fig. 1 represents a fully binary tree of maximum depth 4 with the node numbers 1, 2, 3, …, 15. Since all of the flags are initially set to be false, the first ball being dropped will switch flag’s values at node 1, node 2, and node 4 before it finally stops at position 8. The second ball being dropped will switch flag’s values at node 1, node 3, and node 6, and stop at position 12. Obviously, the third ball being dropped will switch flag’s values at node 1, node 2, and node 5 before it stops at position 10.&lt;br&gt;&lt;img src=&quot;https://github.com/Amannix/Amannix.github.io/tree/master/images/UVA-679.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;Fig. 1: An example of FBT with the maximum depth 4 and sequential node numbers.&lt;/center&gt;&lt;br&gt;Now consider a number of test cases where two values will be given for each test. The first value is D, the maximum depth of FBT, and the second one is I, the I-th ball being dropped. You may assume the value of I will not exceed the total number of leaf nodes for the given FBT. Please write a program to determine the stop position P for each test case.&lt;br&gt;For each test cases the range of two parameters D and I is as below:&lt;/p&gt;
&lt;enter&gt;2 ≤ D ≤ 20, and 1 ≤ I ≤ 524288.&lt;/enter&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-12657 Boxes in a Line(双向链表)</title>
    <link href="https://amannix.github.io/2018/11/17/UVA%20-%2012657/"/>
    <id>https://amannix.github.io/2018/11/17/UVA - 12657/</id>
    <published>2018-11-17T06:23:27.000Z</published>
    <updated>2018-11-17T07:07:11.491Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-12657" target="_blank" rel="noopener">UVA-12657 Boxes in a Line</a><br><strong>Description</strong><br><div class="note default"><p>You have n boxes in a line on the table numbered 1 . . . n from left to right. Your task is to simulate 4<br>kinds of commands:<br>• 1 X Y : move box X to the left to Y (ignore this if X is already the left of Y )<br>• 2 X Y : move box X to the right to Y (ignore this if X is already the right of Y )<br>• 3 X Y : swap box X and Y<br>• 4: reverse the whole line.<br>Commands are guaranteed to be valid, i.e. X will be not equal to Y. For example, if n = 6, after executing 1 1 4, the line becomes 2 3 1 4 5 6. Then after executing 2 3 5, the line becomes 2 1 4 5 3 6. Then after executing 3 1 6, the line becomes 2 6 4 5 3 1. Then after executing 4, then line becomes 1 3 5 4 6 2.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>There will be at most 10 test cases. Each test case begins with a line containing 2 integers n, m (1 ≤ n, m ≤ 100, 000). Each of the following m lines contain a command.</p></div><br><strong>Output</strong><br><div class="note default"><p>For each test case, print the sum of numbers at odd-indexed positions. Positions are numbered 1 to n from left to right.</p></div><br><strong>Sample Input</strong></p><blockquote><p>6 4<br>1 1 4<br>2 3 5<br>3 1 6<br>4<br>6 3<br>1 1 4<br>2 3 5<br>3 1 6<br>100000 1<br>4<br><strong>Sample Output</strong><br>Case 1: 12<br>Case 2: 9<br>Case 3: 2500050000</p></blockquote><p><strong>Thinking</strong><br>用数组模拟双向链表，要注意当X、Y相邻的时候的处理</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">100010</span>],next[<span class="number">100010</span>],head,last;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"></span><br><span class="line">next[i] = i+<span class="number">1</span>;</span><br><span class="line">pre[i] = i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre[n+<span class="number">1</span>] = n;</span><br><span class="line">head = <span class="number">0</span>;</span><br><span class="line">last = n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> com,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = a,y = b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (com == <span class="number">1</span>)&#123;</span><br><span class="line">next[pre[x]] = next[x];</span><br><span class="line">pre[next[x]] = pre[x];</span><br><span class="line">next[x] = y;</span><br><span class="line">pre[x] = pre[y];</span><br><span class="line">next[pre[y]] = x;</span><br><span class="line">pre[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (com == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> p = pre[x],n = next[x];</span><br><span class="line"><span class="keyword">if</span> (p == y)&#123;</span><br><span class="line">pre[next[x]] = y;</span><br><span class="line">next[y] = next[x];</span><br><span class="line">next[x] = y;</span><br><span class="line">next[pre[y]] = x;</span><br><span class="line">pre[x] = pre[y];</span><br><span class="line">pre[y] = x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == y)&#123;</span><br><span class="line">pre[next[y]] = x;</span><br><span class="line">next[x] = next[y];</span><br><span class="line">next[y] = x;</span><br><span class="line">next[pre[x]] = y;</span><br><span class="line">pre[y] = pre[x];</span><br><span class="line">pre[x] = y;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">next[pre[x]] = y;</span><br><span class="line">pre[next[x]] = y;</span><br><span class="line">pre[next[y]] = x;</span><br><span class="line">next[pre[y]] = x;</span><br><span class="line">next[x] = next[y];</span><br><span class="line">pre[x] = pre[y];</span><br><span class="line">next[y] = n;</span><br><span class="line">pre[y] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (com == <span class="number">2</span>)&#123;</span><br><span class="line">next[pre[x]] = next[x];</span><br><span class="line">pre[next[x]] = pre[x];</span><br><span class="line">next[x] = next[y];</span><br><span class="line">pre[x] = y;</span><br><span class="line">pre[next[y]] = x;</span><br><span class="line">next[y] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">bool</span> com,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (com == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> inter = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">inter = next[inter];</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">1</span>)ans += inter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> inter = last;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">inter = pre[inter];</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">1</span>)ans += inter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n,cut = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line"><span class="keyword">int</span> mod,a,b,cnt = <span class="number">0</span>;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;mod);</span><br><span class="line"><span class="keyword">if</span> (mod == <span class="number">4</span>)&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span> (cnt%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (mod == <span class="number">1</span>) mod = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mod == <span class="number">2</span>) mod = <span class="number">1</span>;</span><br><span class="line">move(a,b,mod,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> move(a,b,mod,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Case %d: "</span>,cut++);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,get_ans((cnt+<span class="number">1</span>)%<span class="number">2</span>,n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-12657&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UVA-12657 Boxes in a Line&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;You have n boxes in a line on the table numbered 1 . . . n from left to right. Your task is to simulate 4&lt;br&gt;kinds of commands:&lt;br&gt;• 1 X Y : move box X to the left to Y (ignore this if X is already the left of Y )&lt;br&gt;• 2 X Y : move box X to the right to Y (ignore this if X is already the right of Y )&lt;br&gt;• 3 X Y : swap box X and Y&lt;br&gt;• 4: reverse the whole line.&lt;br&gt;Commands are guaranteed to be valid, i.e. X will be not equal to Y. For example, if n = 6, after executing 1 1 4, the line becomes 2 3 1 4 5 6. Then after executing 2 3 5, the line becomes 2 1 4 5 3 6. Then after executing 3 1 6, the line becomes 2 6 4 5 3 1. Then after executing 4, then line becomes 1 3 5 4 6 2.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Curiosity Has No Limits(搜索)</title>
    <link href="https://amannix.github.io/2018/11/11/Curiosity%20Has%20No%20Limits/"/>
    <id>https://amannix.github.io/2018/11/11/Curiosity Has No Limits/</id>
    <published>2018-11-11T02:36:45.000Z</published>
    <updated>2018-11-17T11:32:26.428Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1031/problem/B" target="_blank" rel="noopener">Technocup 2019 - Elimination Round 2 B.Curiosity Has No Limits</a><br><strong>Description</strong><br><div class="note default"><p>When Masha came to math classes today, she saw two integer sequences of length n−1n−1 on the blackboard. Let’s denote the elements of the first sequence as ai (0≤ai≤3), and the elements of the second sequence as bi (0≤bi≤3).</p><p>Masha became interested if or not there is an integer sequence of length nn, which elements we will denote as ti (0≤ti≤3), so that for every i (1≤i≤n−1) the following is true:</p><blockquote><p>ai=ti|t(i+1) and bi=ti&amp;t(i+1)</p></blockquote><p>The question appeared to be too difficult for Masha, so now she asked you to check whether such a sequence ti of length n exists. If it exists,find such a sequence. If there are multiple such sequences, find any of them.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains a single integer n (2≤n≤10^5) — the length of the sequence ti.<br>The second line contains n−1n−1 integers a1,a2,…,an−1a1,a2,…,an−1 (0≤ai≤3) — the first sequence on the blackboard.<br>The third line contains n−1n−1 integers b1,b2,…,bn−1b1,b2,…,bn−1 (0≤bi≤3) — the second sequence on the blackboard.  </p></div><br><strong>Output</strong><br><div class="note default"><p>In the first line print “YES” (without quotes), if there is a sequence ti that satisfies the conditions from the statements, and “NO” (without quotes), if there is no such sequence.<br>If there is such a sequence, on the second line print nn integers t1,t2,…,tn (0≤ti≤3) — the sequence that satisfies the statements conditions.<br>If there are multiple answers, print any of them.  </p></div><br><strong>Sample Input</strong></p><blockquote><p>4<br>3 3 2<br>1 2 0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>YES<br>1 3 2 0</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>3<br>1 3<br>3 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>NO</p></blockquote><p><strong>Thinking</strong><br>给出两个数列，每个元素只由0 1 2 3组成。要求构造第三个数列t，使得满足ai=ti|t(i+1) and bi=ti&amp;t(i+1)。答案给的是找规律的解法，但是有一种解法是深搜剪枝可解。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">100010</span>],a[<span class="number">100010</span>],b[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; buf[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)    <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (((k|i) == a[pos]) &amp;&amp; ((k&amp;i) == b[pos]))&#123;</span><br><span class="line">            buf[pos+<span class="number">1</span>] = i;</span><br><span class="line">            bfs(pos+<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>; ++i)&#123;</span><br><span class="line">        buf[<span class="number">1</span>] = i;</span><br><span class="line">        bfs(<span class="number">1</span>,i);</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"NO\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1031/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Technocup 2019 - Elimination Round 2 B.Curiosity Has No Limits&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;When Masha came to math classes today, she saw two integer sequences of length n−1n−1 on the blackboard. Let’s denote the elements of the first sequence as ai (0≤ai≤3), and the elements of the second sequence as bi (0≤bi≤3).&lt;/p&gt;
&lt;p&gt;Masha became interested if or not there is an integer sequence of length nn, which elements we will denote as ti (0≤ti≤3), so that for every i (1≤i≤n−1) the following is true:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ai=ti|t(i+1) and bi=ti&amp;amp;t(i+1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The question appeared to be too difficult for Masha, so now she asked you to check whether such a sequence ti of length n exists. If it exists,find such a sequence. If there are multiple such sequences, find any of them.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="搜索" scheme="https://amannix.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LCM (分解定理求约数的个数)</title>
    <link href="https://amannix.github.io/2018/11/11/LCM/"/>
    <id>https://amannix.github.io/2018/11/11/LCM/</id>
    <published>2018-11-11T02:01:32.000Z</published>
    <updated>2018-11-11T02:35:54.810Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1068/problem/B" target="_blank" rel="noopener">Codeforces Round 518 (Div. 2) B.LCM</a><br><strong>Description</strong><br><div class="note default"><p>Ivan has number b. He is sorting through the numbers aa from 1 to 10^18, and for every aa writes [a,b]/a on blackboard. Here [a,b] stands for least common multiple of aa and bb. Ivan is very lazy, that’s why this task bored him soon. But he is interested in how many different numbers he would write on the board if he would finish the task. Help him to find the quantity of different numbers he would write on the board.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The only line contains one integer — b (1≤b≤10^10).</p></div><br><strong>Output</strong><br><div class="note default"><p>Print one number — answer for the problem.</p></div><br><strong>Sample Input</strong></p><blockquote><p>1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2</p></blockquote><p><strong>Thinking</strong><br>给出一个数字b，然后求[a,b]/a，的不同取值有多少种，[a,b]值最小公倍数。这里有(a*b)/gcd(a,b) == [a,b]。原式转化为b/gcd(a,b)。当分母gcd(a,b)&gt;b的时候，取值唯一变成0，实际上也永远不可能大于b。因此答案就变成了求b的约数的个数。可以线性遍历求出约数个数，复杂度为O(sqrt(b))。但这里利用唯一分解定理。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> isprime[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100000</span>; ++i)&#123;</span><br><span class="line">isprime[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i*i &lt;= <span class="number">100000</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i*i;j &lt;= <span class="number">100000</span>; j += i)&#123;</span><br><span class="line">isprime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100000</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i])&#123;</span><br><span class="line">prime[index++] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">get_prime();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> total;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;total);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[i] &gt; total)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (total % prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span> (total%prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">++num;</span><br><span class="line">total /= prime[i];</span><br><span class="line">&#125;</span><br><span class="line">ans *= (num + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (total &gt; <span class="number">1</span>)&#123;<span class="comment">//这判断最后一次除法是否将其整除</span></span><br><span class="line">ans *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1068/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round 518 (Div. 2) B.LCM&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Ivan has number b. He is sorting through the numbers aa from 1 to 10^18, and for every aa writes [a,b]/a on blackboard. Here [a,b] stands for least common multiple of aa and bb. Ivan is very lazy, that’s why this task bored him soon. But he is interested in how many different numbers he would write on the board if he would finish the task. Help him to find the quantity of different numbers he would write on the board.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="https://amannix.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>HDU-3085 Nightmare Ⅱ(双向搜索)</title>
    <link href="https://amannix.github.io/2018/11/11/HDU-3085%20Nightmare%20%E2%85%A1/"/>
    <id>https://amannix.github.io/2018/11/11/HDU-3085 Nightmare Ⅱ/</id>
    <published>2018-11-11T01:43:50.000Z</published>
    <updated>2018-11-11T02:01:25.261Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3085" target="_blank" rel="noopener">HDU-3085 Nightmare Ⅱ</a><br><strong>Description</strong><br><div class="note default"><p>Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.<br>You may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.<br>Note: the new ghosts also can devide as the original ghost.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The input starts with an integer T, means the number of test cases.<br>Each test case starts with a line contains two integers n and m, means the size of the maze. (1&lt;n, m&lt;800)<br>The next n lines describe the maze. Each line contains m characters. The characters may be:<br>‘.’ denotes an empty place, all can walk on.<br>‘X’ denotes a wall, only people can’t walk on.<br>‘M’ denotes little erriyue<br>‘G’ denotes the girl friend.<br>‘Z’ denotes the ghosts.<br>It is guaranteed that will contain exactly one letter M, one letter G and two letters Z.</p></div><br><strong>Output</strong><br><div class="note default"><p>Output a single integer S in one line, denotes erriyue and his girlfriend will meet in the minimum time S if they can meet successfully, or output -1 denotes they failed to meet.</p></div><br><strong>Sample Input</strong><br><div class="note default"><p>3<br>5 6<br>XXXXXX<br>XZ..ZX<br>XXXXXX<br>M.G…<br>……<br>5 6<br>XXXXXX<br>XZZ..X<br>XXXXXX<br>M…..<br>..G…</p><p>10 10<br>……….<br>..X…….<br>..M.X…X.<br>X………<br>.X..X.X.X.<br>………X<br>..XX….X.<br>X….G…X<br>…ZX.X…<br>…Z..X..X</p></div><br><strong>Sample Output</strong><br><div class="note default"><p>1<br>1<br>-1</p></div></p><p><strong>Thinking</strong><br>在一个迷宫上面两只鬼，以及erriyue和他女朋友，每轮鬼先分裂出两个填充其他格子，然后erriyue走三步，他女朋友走一步。鬼分裂出的鬼又可以再分裂，直到填充所有空间，判断M是否能够找到他女朋友。<br>双向搜索，从M和G两边开始，由于M可以走三步，在走的过程中还需要一次判断是否路径合法，并且这三步有多种可走的方法，所以只能把三步分成三次搜索。与鬼的判断只需要判断走的回合数乘以2是否大于角色与鬼初始位置的哈曼顿距离。将M，G的路径标记，如果出现重合即两人到达。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">880</span>][<span class="number">880</span>];</span><br><span class="line"><span class="keyword">int</span> t, n, m, step;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;gg, mm, zz[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;q[<span class="number">2</span>], qt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isok</span><span class="params">(node t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t.x&lt;<span class="number">1</span> || t.x&gt;n || t.y&lt;<span class="number">1</span> || t.y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断越界可以先填充0</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(t.x-zz[i].x)+<span class="built_in">abs</span>(t.y-zz[i].y)&lt;=<span class="number">2</span>*step || str[t.x][t.y]==<span class="string">'X'</span> || str[t.x][t.y]==<span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> mark, <span class="keyword">int</span> num, <span class="keyword">char</span> start, <span class="keyword">char</span> endd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node a, b;</span><br><span class="line">    qt=q[mark];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">    &#123;<span class="comment">/*主要是这里，用了一个中间队列，限制了搜索起点的范围这样就确保了只搜索num步*/</span></span><br><span class="line">        <span class="keyword">while</span>(!qt.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            a=qt.front(), qt.pop(), q[mark].pop();<span class="comment">//很坑的就是M不一定就是只能走三步，而是小于等于三步</span></span><br><span class="line">            <span class="keyword">if</span>(!isok(a)) <span class="keyword">continue</span>;<span class="comment">//鬼先走，每增加一步，先判断鬼能不能把人吃掉</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                b = a;</span><br><span class="line">                b.x+=f[i][<span class="number">0</span>], b.y+=f[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(!isok(b)||str[b.x][b.y]==start) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(str[b.x][b.y]==endd) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//其中一个人到达了另一个人曾经到达的地方，两人相遇了</span></span><br><span class="line">                str[b.x][b.y]=start;<span class="comment">//标记已经走过的地方</span></span><br><span class="line">                q[mark].push(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        qt=q[mark];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">0</span>].empty()) q[<span class="number">0</span>].pop();</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">1</span>].empty()) q[<span class="number">1</span>].pop();</span><br><span class="line">    <span class="keyword">while</span>(!qt.empty()) qt.pop();</span><br><span class="line">    q[<span class="number">0</span>].push(mm), q[<span class="number">1</span>].push(gg);</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">0</span>].empty() &amp;&amp; !q[<span class="number">1</span>].empty())<span class="comment">//用了两个队列维护一步之内走的范围，</span></span><br><span class="line">    &#123;</span><br><span class="line">        step++;<span class="comment">//枚举走的步数，</span></span><br><span class="line">        <span class="keyword">bool</span> flag1 = bfs(<span class="number">0</span>,<span class="number">3</span>,<span class="string">'M'</span>,<span class="string">'G'</span>);<span class="comment">//每次bfs只仅仅走一步</span></span><br><span class="line">        <span class="keyword">bool</span> flag2 = bfs(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'G'</span>,<span class="string">'M'</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag1||flag2) <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">memset</span>(str,<span class="string">'X'</span>,<span class="keyword">sizeof</span>(str));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>,i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i][j]==<span class="string">'M'</span>) mm.x=i, mm.y=j;</span><br><span class="line">                <span class="keyword">if</span>(str[i][j]==<span class="string">'G'</span>) gg.x=i, gg.y=j;</span><br><span class="line">                <span class="keyword">if</span>(str[i][j]==<span class="string">'Z'</span>) zz[k].x=i, zz[k].y=j, k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3085&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU-3085 Nightmare Ⅱ&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.&lt;br&gt;You may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.&lt;br&gt;Note: the new ghosts also can devide as the original ghost.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="搜索" scheme="https://amannix.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>DNA sequence(IDA*)</title>
    <link href="https://amannix.github.io/2018/11/11/HDU-1560%20DNA%20sequence/"/>
    <id>https://amannix.github.io/2018/11/11/HDU-1560 DNA sequence/</id>
    <published>2018-11-11T01:30:55.000Z</published>
    <updated>2018-11-11T01:45:09.357Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1560" target="_blank" rel="noopener">HDU - 1560 DNA sequence</a><br><strong>Description</strong><br><div class="note default"><p>The twenty-first century is a biology-technology developing century. We know that a gene is made of DNA. The nucleotide bases from which DNA is built are A(adenine), C(cytosine), G(guanine), and T(thymine). Finding the longest common subsequence between DNA/Protein sequences is one of the basic problems in modern computational molecular biology. But this problem is a little different. Given several DNA sequences, you are asked to make a shortest sequence from them so that each of the given sequence is the subsequence of it.</p><p>For example, given “ACGT”,”ATGC”,”CGTT” and “CAGT”, you can make a sequence in the following way. It is the shortest but may be not the only one.<br><img src="https://vj.e949.cn/484ac84a1e7eb5b60c2d9f0ac6e356c7?v=1541632888" alt=""></p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line is the test case number t. Then t test cases follow. In each case, the first line is an integer n ( 1&lt;=n&lt;=8 ) represents number of the DNA sequences. The following k lines contain the k sequences, one per line. Assuming that the length of any sequence is between 1 and 5.</p></div><br><strong>Output</strong><br><div class="note default"><p>For each test case, print a line containing the length of the shortest sequence that can be made from these sequences.</p></div><br><strong>Sample Input</strong></p><blockquote><p>1<br>4<br>ACGT<br>ATGC<br>CGTT<br>CAGT  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>8</p></blockquote><p><strong>Thinking</strong><br>给出N组DNA的序列，求构造一个序列使得每组DNA序列都能够按照原来的顺序在新序列中匹配，注意并不是子串的关系。<br>IDA*搜索构造新串，先枚举搜索深度，按照这个搜索深度，只要超出该深度则回溯。并且每次计算最少还需搜索的长度加上当前搜索的长度超过了预计长度也回溯。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IDA*</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,deep,ans;</span><br><span class="line"><span class="keyword">int</span> size[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> dna[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">4</span>] = &#123;<span class="string">'A'</span>,<span class="string">'C'</span>,<span class="string">'G'</span>,<span class="string">'T'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> len[])</span><span class="comment">//len也是当前匹配到的位置，但是通过两个数组交替使回溯的值可保持原样</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k &gt; deep)<span class="keyword">return</span> ;<span class="comment">//深度大于预期深度则回溯</span></span><br><span class="line"><span class="keyword">int</span> maxx = <span class="number">0</span>;<span class="comment">//找出当前还需匹配的最少数目</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (size[i]-len[i] &gt; maxx)&#123;</span><br><span class="line"><span class="keyword">if</span> (maxx &lt; size[i]-len[i])</span><br><span class="line">maxx = size[i]-len[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxx == <span class="number">0</span>)&#123;<span class="comment">//如果当前没有需要匹配的则得到答案</span></span><br><span class="line">ans = k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k + maxx &gt; deep)&#123;<span class="comment">//最少匹配数加上当前深度大于预期深度则回溯</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//记录当前字符串已经匹配到的位置</span></span><br><span class="line"><span class="keyword">if</span> (ans != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;<span class="comment">//与每一个字符串进行匹配</span></span><br><span class="line"><span class="keyword">if</span> (dna[j][len[j]] == ch[i])&#123;</span><br><span class="line">pos[j] = len[j] + <span class="number">1</span>;<span class="comment">//改变当前已匹配的位置</span></span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pos[j] = len[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;<span class="comment">//必须发生过一个匹配才继续深搜</span></span><br><span class="line">dfs(k+<span class="number">1</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T,maxn = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)&#123;</span><br><span class="line">maxn = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">getchar ();</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%s"</span>,dna[i]);</span><br><span class="line">size[i] = <span class="built_in">strlen</span>(dna[i]);</span><br><span class="line"><span class="keyword">if</span> (size[i] &gt; maxn)maxn = size[i];</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">-1</span>;</span><br><span class="line">deep = maxn;<span class="comment">//迭代加深的起点</span></span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">dfs(<span class="number">0</span>,pos);</span><br><span class="line"><span class="keyword">if</span> (ans != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">deep++;<span class="comment">//迭代加深</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU - 1560 DNA sequence&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;The twenty-first century is a biology-technology developing century. We know that a gene is made of DNA. The nucleotide bases from which DNA is built are A(adenine), C(cytosine), G(guanine), and T(thymine). Finding the longest common subsequence between DNA/Protein sequences is one of the basic problems in modern computational molecular biology. But this problem is a little different. Given several DNA sequences, you are asked to make a shortest sequence from them so that each of the given sequence is the subsequence of it.&lt;/p&gt;
&lt;p&gt;For example, given “ACGT”,”ATGC”,”CGTT” and “CAGT”, you can make a sequence in the following way. It is the shortest but may be not the only one.&lt;br&gt;&lt;img src=&quot;https://vj.e949.cn/484ac84a1e7eb5b60c2d9f0ac6e356c7?v=1541632888&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="搜索" scheme="https://amannix.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Vasya and Robot(二分)</title>
    <link href="https://amannix.github.io/2018/11/07/Vasya%20and%20Robot/"/>
    <id>https://amannix.github.io/2018/11/07/Vasya and Robot/</id>
    <published>2018-11-07T15:57:29.000Z</published>
    <updated>2018-11-08T04:09:27.317Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1073/problem/C" target="_blank" rel="noopener">Educational Codeforces Round 53</a><br><strong>Description</strong><br><div class="note default"><p>Vasya has got a robot which is situated on an infinite Cartesian plane, initially in the cell (0,0). Robot can perform the following four kinds of operations:</p><blockquote><p>U — move from (x,y)(x,y) to (x,y+1)(x,y+1);<br>D — move from (x,y)(x,y) to (x,y−1)(x,y−1);<br>L — move from (x,y)(x,y) to (x−1,y)(x−1,y);<br>R — move from (x,y)(x,y) to (x+1,y)(x+1,y).</p></blockquote><p>Vasya also has got a sequence of n operations. Vasya wants to modify this sequence so after performing it the robot will end up in (x,y)<br>Vasya wants to change the sequence so the length of changed subsegment is minimum possible. This length can be calculated as follows: maxID−minID+1, where maxID is the maximum index of a changed operation, and minID is the minimum index of a changed operation. For example, if Vasya changes RRRRRRR to RLRRLRL, then the operations with indices 2, 5 and 7 are changed, so the length of changed subsegment is 7−2+1=6. Another example: if Vasya changes DDDD to DDRD, then the length of changed subsegment is 1.</p><p>If there are no changes, then the length of changed subsegment is 0. Changing an operation means replacing it with some operation (possibly the same); Vasya can’t insert new operations into the sequence or remove them.</p><p>Help Vasya! Tell him the minimum length of subsegment that he needs to change so that the robot will go from (0,0) to (x,y), or tell him that it’s impossible.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains one integer number n (1≤n≤2⋅105) — the number of operations.</p><p>The second line contains the sequence of operations — a string of n characters. Each character is either U, D, L or R.</p><p>The third line contains two integers x,y (−109≤x,y≤109) — the coordinates of the cell where the robot should end its path.</p></div><br><strong>Output</strong><br><div class="note default"><p>Print one integer — the minimum possible length of subsegment that can be changed so the resulting sequence of operations moves the robot from (0,0) to (x,y). If this change is impossible, print −1.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>RURUU<br>-2 3  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>3</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>4<br>RULR<br>1 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0</p></blockquote><p><strong>Thinking</strong><br>给出一个字符串，只由UDLR组成，代表了从(0,0)开始的移动轨迹，再给出一个坐标，求在这个移动操作的字符串中，能否更改一段区间，使得通过这个新操作可以到达目的地，求最小改变区间。首先一个结论就是看这个操作次数，操作次数一定要等于目标点到原点的哈曼顿距离，在大于的情况下，可以两两抵消使得操作数变少最后等于目标点到原点的哈曼顿距离，因此必须先特判操作次数需与哈曼顿距离的奇偶性相同。接着就是求最小改变区间。可以根据哈曼顿距离的奇偶性来暴力枚举区间长度。但是也会TLE，由于其改变的区间长度最大必定是整个操作数，最小为0.所以只需要在0到n之间找到一个最佳枚举区间，因此可以二分区间长度，如果mid是一个合理的区间就向下搜索，如果不合理就向上搜索。每二分到一个区间长度，就从1开始遍历区间位置逐一判断，此时需要先将每一个操作对应的坐标偏移量求出前缀和，然后将每一个对应的长度的区间所做的偏移全部删去，更新终点位置，最后计算终点位置与目标位置的哈曼顿距离，然后根据上面的同样的方法，用操作次数和奇偶性来判断是否更改的区间合理。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> x,y;</span><br><span class="line">&#125;buf[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">long</span> l,r,mid;</span><br><span class="line"><span class="keyword">long</span> dis;</span><br><span class="line"><span class="keyword">long</span> x,y;</span><br><span class="line"><span class="keyword">long</span> n,ans = <span class="number">99999</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>;i &lt;= n-mid; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> a = buf[i+mid].x-buf[i].x,b = buf[i+mid].y-buf[i].y;</span><br><span class="line">        <span class="comment">//计算mid区间内偏移量是多少</span></span><br><span class="line">        <span class="keyword">long</span> temp_x = buf[n].x - a,temp_y = buf[n].y - b;</span><br><span class="line">        <span class="comment">//最后总的长度减去偏移量，重新计算终点坐标</span></span><br><span class="line">        <span class="keyword">long</span> cut = mid,temp_dis = <span class="built_in">abs</span>(x-temp_x) + <span class="built_in">abs</span>(y-temp_y);</span><br><span class="line">        <span class="comment">//计算终点到目标点的哈曼顿距离。</span></span><br><span class="line">        <span class="keyword">if</span> (cut - temp_dis &gt;= <span class="number">0</span> &amp;&amp; cut%<span class="number">2</span> == temp_dis%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//同样的方法判断是否能够到达目标</span></span><br><span class="line">            ans = min(ans,cut);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%ld"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%s"</span>,str);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%ld%ld"</span>,&amp;x,&amp;y);</span><br><span class="line">    dis = <span class="built_in">abs</span>(x)+<span class="built_in">abs</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; n || n%<span class="number">2</span> != dis%<span class="number">2</span>)&#123;<span class="comment">/*如果总步数都无法走到就直接输出-1</span></span><br><span class="line"><span class="comment">            但是所有能走到的前提都是总步数和距离的长度的奇偶性的相同*/</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;<span class="comment">//求偏移值量前缀和</span></span><br><span class="line">        <span class="keyword">switch</span> (str[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>:buf[i+<span class="number">1</span>].y = buf[i].y+<span class="number">1</span>;buf[i+<span class="number">1</span>].x = buf[i].x;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:buf[i+<span class="number">1</span>].y = buf[i].y<span class="number">-1</span>;buf[i+<span class="number">1</span>].x = buf[i].x;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:buf[i+<span class="number">1</span>].x = buf[i].x<span class="number">-1</span>;buf[i+<span class="number">1</span>].y = buf[i].y;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'R'</span>:buf[i+<span class="number">1</span>].x = buf[i].x+<span class="number">1</span>;buf[i+<span class="number">1</span>].y = buf[i].y;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = n;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = n<span class="number">-1</span>;</span><br><span class="line">    mid =(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;<span class="comment">//二分搜索区间</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid))&#123;<span class="comment">//如果mid是一个符合的区间就小的方向搜索</span></span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%ld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1073/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Educational Codeforces Round 53&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Vasya has got a robot which is situated on an infinite Cartesian plane, initially in the cell (0,0). Robot can perform the following four kinds of operations:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;U — move from (x,y)(x,y) to (x,y+1)(x,y+1);&lt;br&gt;D — move from (x,y)(x,y) to (x,y−1)(x,y−1);&lt;br&gt;L — move from (x,y)(x,y) to (x−1,y)(x−1,y);&lt;br&gt;R — move from (x,y)(x,y) to (x+1,y)(x+1,y).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vasya also has got a sequence of n operations. Vasya wants to modify this sequence so after performing it the robot will end up in (x,y)&lt;br&gt;Vasya wants to change the sequence so the length of changed subsegment is minimum possible. This length can be calculated as follows: maxID−minID+1, where maxID is the maximum index of a changed operation, and minID is the minimum index of a changed operation. For example, if Vasya changes RRRRRRR to RLRRLRL, then the operations with indices 2, 5 and 7 are changed, so the length of changed subsegment is 7−2+1=6. Another example: if Vasya changes DDDD to DDRD, then the length of changed subsegment is 1.&lt;/p&gt;
&lt;p&gt;If there are no changes, then the length of changed subsegment is 0. Changing an operation means replacing it with some operation (possibly the same); Vasya can’t insert new operations into the sequence or remove them.&lt;/p&gt;
&lt;p&gt;Help Vasya! Tell him the minimum length of subsegment that he needs to change so that the robot will go from (0,0) to (x,y), or tell him that it’s impossible.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="二分" scheme="https://amannix.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysterious Crime(子区间匹配)</title>
    <link href="https://amannix.github.io/2018/11/07/Mysterious%20Crime/"/>
    <id>https://amannix.github.io/2018/11/07/Mysterious Crime/</id>
    <published>2018-11-07T11:52:37.000Z</published>
    <updated>2018-11-07T12:30:54.645Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1043/problem/D" target="_blank" rel="noopener">Codeforces Round #519</a><br><strong>Description</strong><br><div class="note default"><p>Acingel is a small town. There was only one doctor here — Miss Ada. She was very friendly and nobody has ever said something bad about her, so who could’ve expected that Ada will be found dead in her house? Mr Gawry, world-famous detective, is appointed to find the criminal. He asked m neighbours of Ada about clients who have visited her in that unlucky day. Let’s number the clients from 1 to n. Each neighbour’s testimony is a permutation of these numbers, which describes the order in which clients have been seen by the asked neighbour.</p><p>However, some facts are very suspicious – how it is that, according to some of given permutations, some client has been seen in the morning, while in others he has been seen in the evening? “In the morning some of neighbours must have been sleeping!” — thinks Gawry — “and in the evening there’s been too dark to see somebody’s face…”. Now he wants to delete some prefix and some suffix (both prefix and suffix can be empty) in each permutation, so that they’ll be non-empty and equal to each other after that — some of the potential criminals may disappear, but the testimony won’t stand in contradiction to each other.</p><p>In how many ways he can do it? Two ways are called different if the remaining common part is different.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains two integers n and m (1≤n≤100000, 1≤m≤10) — the number of suspects and the number of asked neighbors.</p><p>Each of the next m lines contains nn integers a1,a2,…,an (1≤ai≤n). It is guaranteed that these integers form a correct permutation (that is, each number from 1 to n appears exactly once).</p></div><br><strong>Output</strong><br><div class="note default"><p>Output a single integer denoting the number of ways to delete some prefix and some suffix of each permutation (possibly empty), such that the remaining parts will be equal and non-empty.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5 6<br>1 2 3 4 5<br>2 3 1 4 5<br>3 4 5 1 2<br>3 5 4 2 1<br>2 3 5 4 1<br>1 2 3 4 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>5</p></blockquote><p><strong>Thinking</strong><br>灰常有意思的一道区间匹配问题，给出一行1到N的全排列，总共有M行。求这M行中的公共子区间是多少，例如：12543和43512.首先每个单独的数字就是他们最小的一个子区间，然后12也是他们的公共子区间，这道题就是要求出所有的公共子区间有多少。首先暴力肯定是不能暴力的了，由于每个数字在一行上只会出现一次。所以可以桶哈希记录每个数字出现的位置，方便查找。接下来就是匹配子区间了，以第一行为基准枚举，从第一个数字开始纵向匹配，去匹配最长的公共子区间如果找到一个子区间，那么枚举变量跳转到区间左边（最小的区间一定是单个数字）那么对于横向枚举来说一定是线性时间，由于要纵向对比，所以总的时间复杂度是O(N*M)。现在如果匹配到了一个子区间长度为K，那么对于这段子区间来说它的所有的子区间都一定是公共子区间，所以它包含的公共子区间一定是1+2+3…+K。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">15</span>][<span class="number">200010</span>],hash[<span class="number">15</span>][<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//直接求出第一组第s个数据开始向后最多可以匹配到多长的公共子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="comment">/*由于这个匹配是默认从第二组开始的所以无法判断只有一组数据的情况</span></span><br><span class="line"><span class="comment">             *理论上改成i = 1可解决。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> k = hash[i][buf[<span class="number">1</span>][s]] + cnt;</span><br><span class="line">            <span class="keyword">if</span> (buf[<span class="number">1</span>][s+cnt] != buf[i][k] || s+cnt &gt; n || k &gt; n)&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">fact</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//注意这个前k项和的数据范围</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k; ++i)&#123;</span><br><span class="line">        ans += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;buf[i][j]);</span><br><span class="line">            hash[i][buf[i][j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)&#123;<span class="comment">//需要特判一下只有一组数据的情况</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,fact(n));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = judge(i);</span><br><span class="line">        ans += fact(temp);<span class="comment">//这段公共子串的组合数等于其长度的1+2+3……+temp。</span></span><br><span class="line">        i += temp;<span class="comment">//跳过这段公共子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1043/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round #519&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Acingel is a small town. There was only one doctor here — Miss Ada. She was very friendly and nobody has ever said something bad about her, so who could’ve expected that Ada will be found dead in her house? Mr Gawry, world-famous detective, is appointed to find the criminal. He asked m neighbours of Ada about clients who have visited her in that unlucky day. Let’s number the clients from 1 to n. Each neighbour’s testimony is a permutation of these numbers, which describes the order in which clients have been seen by the asked neighbour.&lt;/p&gt;
&lt;p&gt;However, some facts are very suspicious – how it is that, according to some of given permutations, some client has been seen in the morning, while in others he has been seen in the evening? “In the morning some of neighbours must have been sleeping!” — thinks Gawry — “and in the evening there’s been too dark to see somebody’s face…”. Now he wants to delete some prefix and some suffix (both prefix and suffix can be empty) in each permutation, so that they’ll be non-empty and equal to each other after that — some of the potential criminals may disappear, but the testimony won’t stand in contradiction to each other.&lt;/p&gt;
&lt;p&gt;In how many ways he can do it? Two ways are called different if the remaining common part is different.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://amannix.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Smallest Word(思维、字符串)</title>
    <link href="https://amannix.github.io/2018/11/07/Smallest%20Word/"/>
    <id>https://amannix.github.io/2018/11/07/Smallest Word/</id>
    <published>2018-11-07T10:21:11.000Z</published>
    <updated>2018-11-07T12:23:14.479Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1043/problem/C" target="_blank" rel="noopener">Codeforces Round 519</a><br><strong>Description</strong><br><div class="note default"><p>IA has so many colorful magnets on her fridge! Exactly one letter is written on each magnet, ‘a’ or ‘b’. She loves to play with them, placing all magnets in a row. However, the girl is quickly bored and usually thinks how to make her entertainment more interesting.</p><p>Today, when IA looked at the fridge, she noticed that the word formed by magnets is really messy. “It would look much better when I’ll swap some of them!” — thought the girl — “but how to do it?”. After a while, she got an idea. IA will look at all prefixes with lengths from 1 to the length of the word and for each prefix she will either reverse this prefix or leave it as it is. She will consider the prefixes in the fixed order: from the shortest to the largest. She wants to get the lexicographically smallest possible word after she considers all prefixes. Can you help her, telling which prefixes should be chosen for reversing?</p><blockquote><p>A string a is lexicographically smaller than a string b if and only if one of the following holds:</p></blockquote><blockquote><p>a is a prefix of b, but a≠b;</p></blockquote><p>in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first and the only line contains a string s (1≤|s|≤1000), describing the initial string formed by magnets. The string s consists only of characters ‘a’ and ‘b’.</p></div><br><strong>Output</strong><br><div class="note default"><p>Output exactly |s| integers. If IA should reverse the i-th prefix (that is, the substring from 1 to i), the ii-th integer should be equal to 1, and it should be equal to 0 otherwise.</p><p>If there are multiple possible sequences leading to the optimal answer, print any of them.</p></div><br><strong>Sample Input</strong></p><blockquote><p>bbab</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0 1 1 0</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>aaaaa</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 0 0 0 1</p></blockquote><p><strong>Thinking</strong><br>给出一个只有a、b组成的字符串，可以在每一个位置选择是否反转前缀，求一个操作序列使得整个字符串的字典序最小。那最好可以把所有的a都反转到开头的位置就最好了，因此可以在遇到一个’a’的时候，将前面的前缀反转，使得首部的’a’反转到遇到的这个’a’然后在把整各反转回去，例如：abbabb，当遇到第二个’a’的时候，需要先反转成bbaabb，然后再反转成aabbbb。但是需要注意当出现abbaabba的时候，按照之前的规则会导致答案为1 0 1 1 1 0 1 1，但是按照这样的答案是错误的。因为当遇到连续的’a’时，必须直接把这串连续的’a’全部一次反转回去，详情见代码。</p><p><strong>Thinking</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'a'</span>)&#123;</span><br><span class="line">            val[i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt;= len; ++j)&#123;<span class="comment">//搜索连续的'a'区间。</span></span><br><span class="line">                <span class="keyword">if</span> (str[j+<span class="number">1</span>] == <span class="string">'b'</span> || j == len)&#123;</span><br><span class="line">                    val[j] = <span class="number">1</span>;</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,val[i],i==len ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1043/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round 519&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;IA has so many colorful magnets on her fridge! Exactly one letter is written on each magnet, ‘a’ or ‘b’. She loves to play with them, placing all magnets in a row. However, the girl is quickly bored and usually thinks how to make her entertainment more interesting.&lt;/p&gt;
&lt;p&gt;Today, when IA looked at the fridge, she noticed that the word formed by magnets is really messy. “It would look much better when I’ll swap some of them!” — thought the girl — “but how to do it?”. After a while, she got an idea. IA will look at all prefixes with lengths from 1 to the length of the word and for each prefix she will either reverse this prefix or leave it as it is. She will consider the prefixes in the fixed order: from the shortest to the largest. She wants to get the lexicographically smallest possible word after she considers all prefixes. Can you help her, telling which prefixes should be chosen for reversing?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A string a is lexicographically smaller than a string b if and only if one of the following holds:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a is a prefix of b, but a≠b;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="https://amannix.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Lost Array(推导)</title>
    <link href="https://amannix.github.io/2018/11/07/Lost%20Array/"/>
    <id>https://amannix.github.io/2018/11/07/Lost Array/</id>
    <published>2018-11-07T09:33:21.000Z</published>
    <updated>2018-11-07T10:22:52.627Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1043/problem/B" target="_blank" rel="noopener">Codeforces Round 519 B.Lost Array</a><br><strong>Description</strong><br><div class="note default"><p>Bajtek, known for his unusual gifts, recently got an integer array x0,x1,…,xk−1.</p><p>Unfortunately, after a huge array-party with his extraordinary friends, he realized that he’d lost it. After hours spent on searching for a new toy, Bajtek found on the arrays producer’s website another array a of length n+1. As a formal description of a says, a0=0 and for all other i (1≤i≤n) ai=x(i−1)modk+ai−1, where p mod q denotes the remainder of division p by q.</p><p>For example, if the x=[1,2,3] and n=5, then:<br>a0=0,<br>a1=x0mod3+a0=x0+0=1,<br>a2=x1mod3+a1=x1+1=3,<br>a3=x2mod3+a2=x2+3=6,<br>a4=x3mod3+a3=x0+6=7,<br>a5=x4mod3+a4=x1+7=9.<br>So, if the x=[1,2,3] and n=5, then a=[0,1,3,6,7,9].</p><p>Now the boy hopes that he will be able to restore x from aa! Knowing that 1≤k≤n, help him and find all possible values of k — possible lengths of the lost array.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>输入数据有多组。<br>The first line contains exactly one integer nn (1≤n≤1000) — the length of the array aa, excluding the element a0.</p><p>The second line contains nn integers a1,a2,…,an (1≤ai≤10^6).</p><p>Note that a0 is always 0 and is not given in the input.</p></div><br><strong>Output</strong><br><div class="note default"><p>The first line of the output should contain one integer ll denoting the number of correct lengths of the lost array.</p><p>The second line of the output should contain ll integers — possible lengths of the lost array in increasing order.</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>1 2 3 4 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>5<br>1 2 3 4 5</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>5<br>1 3 5 6 8</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2<br>3 5</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>3<br>1 5 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1<br>3  </p></blockquote><p><strong>Thinking</strong><br>说的是有一个数列，这个数列a，同时有一个配套的数列x，x的代表了a数列在之间两两之差，求多长的数组x可以满足a[i]=a[i-1]+x[(i-1)%k].求k可能的值，按从小到大输出。先预处理a数列的两项之差，然后枚举k的值，对每一个k。我们去模拟是否是符合条件的。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,buf[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125;,val[<span class="number">10000</span>],ans[<span class="number">1005</span>],t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;buf[i]);</span><br><span class="line">        val[i<span class="number">-1</span>] = buf[i] - buf[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (buf[j]-buf[j<span class="number">-1</span>] != val[index])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            index %= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            ans[t++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,ans[i],i==t ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1043/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Codeforces Round 519 B.Lost Array&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Bajtek, known for his unusual gifts, recently got an integer array x0,x1,…,xk−1.&lt;/p&gt;
&lt;p&gt;Unfortunately, after a huge array-party with his extraordinary friends, he realized that he’d lost it. After hours spent on searching for a new toy, Bajtek found on the arrays producer’s website another array a of length n+1. As a formal description of a says, a0=0 and for all other i (1≤i≤n) ai=x(i−1)modk+ai−1, where p mod q denotes the remainder of division p by q.&lt;/p&gt;
&lt;p&gt;For example, if the x=[1,2,3] and n=5, then:&lt;br&gt;a0=0,&lt;br&gt;a1=x0mod3+a0=x0+0=1,&lt;br&gt;a2=x1mod3+a1=x1+1=3,&lt;br&gt;a3=x2mod3+a2=x2+3=6,&lt;br&gt;a4=x3mod3+a3=x0+6=7,&lt;br&gt;a5=x4mod3+a4=x1+7=9.&lt;br&gt;So, if the x=[1,2,3] and n=5, then a=[0,1,3,6,7,9].&lt;/p&gt;
&lt;p&gt;Now the boy hopes that he will be able to restore x from aa! Knowing that 1≤k≤n, help him and find all possible values of k — possible lengths of the lost array.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="模拟" scheme="https://amannix.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>UVA-11988 Broken Keyboard(数组模拟链表)</title>
    <link href="https://amannix.github.io/2018/10/27/UVA-11988/"/>
    <id>https://amannix.github.io/2018/10/27/UVA-11988/</id>
    <published>2018-10-27T05:35:02.000Z</published>
    <updated>2018-10-27T06:05:49.174Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-11988" target="_blank" rel="noopener">UVA-11988 Broken Keyboard</a><br><strong>Description</strong><br><div class="note default"><p>WJL同学的键盘出现了奇妙的故障，所有键都会正常的工作，但是键盘上的Home以及End键有时候会莫名其妙的自己按下。但是盲打很熟练的他一般习惯关闭显示器打字，因为这样很酷。<br>现在他正在打一段文本，假设你已经知道这段文本以及Home和End键会什么时候出现故障自行按下。请你编写一个程序，求出他最后打出的文本。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>输入数据有多组。<br>每组数据在一行内包含了至多100000个字母、下划线和两个特别的标点’[‘以及’]’，其中’[‘代表输入到此时”Home”键会被按下。而’]’则代表输入到此时”End”键会被按下。<br>输入数据以EOF作为结束，并且我们保证输入数据的大小不超过5MB。</p></div><br><strong>Output</strong><br><div class="note default"><p>对于每组数据，请在一行之内输出最后他打出的文本是怎样的。</p></div><br><strong>Sample Input</strong></p><blockquote><p>This_is_a_[Sample]_text<br>[[]][][]Nihao_I_am_a_Sample_Input<br>This_pr[oblem_has_a_100]0[m]s_time_limit<br>Maybe_theres_no_bracket  </p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>SampleThis_is_a__text<br>Nihao_I_am_a_Sample_Input<br>moblem_has_a_100This_pr0s_time_limit<br>Maybe_theres_no_bracket  </p></blockquote><p><strong>Thinking</strong><br>紫书例四，一个链表的做法，看的答案用了数组模拟链表。再次惊叹刘大爷的代码妙不可言（很难看的懂）<br>我就只能勉强解释一下cur变量的作用。这个变量老是变来变去的贼奇怪，也特别难理解。这里主要是用cur指向链表接下来该插入的位置（不一定是最后）这个链表由于借助数组所以寻址的过程也比较抽象（巨抽象）。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;nodetable[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> next[<span class="number">100010</span>] = &#123;<span class="number">0</span>&#125;,cur = <span class="number">0</span>,end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*将屏幕上要出现的最终的字符串理解为一个链表生成的过程</span></span><br><span class="line"><span class="comment">          cur链表指针，也可以理解为光标</span></span><br><span class="line"><span class="comment">          end记录链表尾部。</span></span><br><span class="line"><span class="comment">          next[0]必须等于0，初始化首部指针指向NULL*/</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">                cur = <span class="number">0</span>;<span class="comment">//回到首部</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">']'</span>)&#123;</span><br><span class="line">                cur = end;<span class="comment">//回到链表尾部</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                next[i] = next[cur];</span><br><span class="line">                next[cur] = i;<span class="comment">//无论如何光标指向的一定是当前枚举到的i.</span></span><br><span class="line">                <span class="keyword">if</span> (cur == end)<span class="comment">//当光标指向尾部的时候才更新链表尾部地址</span></span><br><span class="line">                    end = i;</span><br><span class="line">                cur = next[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>,cur,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = next[<span class="number">0</span>];i != <span class="number">0</span>; i=next[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%c"</span>,str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-11988&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UVA-11988 Broken Keyboard&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;WJL同学的键盘出现了奇妙的故障，所有键都会正常的工作，但是键盘上的Home以及End键有时候会莫名其妙的自己按下。但是盲打很熟练的他一般习惯关闭显示器打字，因为这样很酷。&lt;br&gt;现在他正在打一段文本，假设你已经知道这段文本以及Home和End键会什么时候出现故障自行按下。请你编写一个程序，求出他最后打出的文本。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-442 Matrix Chain Multiplication(表达式值)</title>
    <link href="https://amannix.github.io/2018/10/26/UVA-442/"/>
    <id>https://amannix.github.io/2018/10/26/UVA-442/</id>
    <published>2018-10-26T07:44:52.000Z</published>
    <updated>2018-10-26T07:57:19.089Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-442" target="_blank" rel="noopener">Matrix Chain Multiplication</a><br><strong>Description</strong><br><div class="note default"><p>Suppose you have to evaluate an expression like ABCDE where A,B,C,D and E are matrices.<br>Since matrix multiplication is associative, the order in which multiplications are performed is arbitrary.<br>However, the number of elementary multiplications needed strongly depends on the evaluation order<br>you choose.<br>For example, let A be a 5010 matrix, B a 1020 matrix and C a 205 matrix. There are two different strategies to compute ABC, namely (AB)C and A(B*C).<br>The first one takes 15000 elementary multiplications, but the second one only 3500.<br>Your job is to write a program that determines the number of elementary multiplications needed<br>for a given evaluation strategy.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>Input consists of two parts: a list of matrices and a list of expressions.<br>The first line of the input file contains one integer n (1 ≤ n ≤ 26), representing the number of<br>matrices in the first part. The next n lines each contain one capital letter, specifying the name of the<br>matrix, and two integers, specifying the number of rows and columns of the matrix.<br>The second part of the input file strictly adheres to the following syntax (given in EBNF):<br>SecondPart = Line { Line }<br>Line = Expression<br>Expression = Matrix | “(“ Expression Expression “)”<br>Matrix = “A” | “B” | “C” | … | “X” | “Y” | “Z”</p></div><br><strong>Output</strong><br><div class="note default"><p>For each expression found in the second part of the input file, print one line containing the word ‘error’<br>if evaluation of the expression leads to an error due to non-matching matrices. Otherwise print one<br>line containing the number of elementary multiplications needed to evaluate the expression in the way<br>specified by the parentheses.</p></div><br><strong>Sample Input</strong></p><blockquote><p>9<br>A 50 10<br>B 10 20<br>C 20 5<br>D 30 35<br>E 35 15<br>F 15 5<br>G 5 10<br>H 10 20<br>I 20 25<br>A<br>B<br>C<br>(AA)<br>(AB)<br>(AC)<br>(A(BC))<br>((AB)C)<br>(((((DE)F)G)H)I)<br>(D(E(F(G(HI)))))<br>((D(EF))((GH)I))</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0<br>0<br>0<br>error<br>10000<br>error<br>3500<br>15000<br>40500<br>47500<br>15125</p></blockquote><p><strong>Thinking</strong><br>紫书第六章例三，经典的堆栈模拟求表达式。很早就知道解法，但是一直没真正做过。输入n个矩阵的维度和一些矩阵链乘表达式，输出乘法次数。如果乘法无法进行则输出error。假定A是m<em>n的矩阵，B是n</em>p的矩阵，那么A<em>B等于m</em>p，且乘法次数等于n<em>m</em>p，如果A的列不等于B的行，则乘法无法进行。先将字符串遍历，遇到’(‘跳过遇到’)’就将栈中取出两个元素做乘法，并且计算乘法次数。然后将新的矩阵再次入栈，知道最后栈为空。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">&#125;buf[<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;node&gt; sta;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    getchar ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; ++i)&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%c "</span>,&amp;ch);</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;buf[ch-<span class="string">'A'</span>].a,&amp;buf[ch-<span class="string">'A'</span>].b);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="comment">//printf ("%d %d\n",buf[ch-'A'].a,buf[ch-'A'].b);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100100</span>];</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str+<span class="number">1</span>),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> error = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!sta.empty())    sta.pop();<span class="comment">//清空栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'('</span>)    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                node a,b;</span><br><span class="line">                a = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                <span class="keyword">if</span> (sta.empty())&#123;<span class="comment">//取第二个元素应该确保栈不为空并且栈中取出的元素应该交换位置</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                <span class="comment">//printf ("%d %d %d %d\n",a.a,a.b,b.a,b.b);</span></span><br><span class="line">                <span class="keyword">if</span> (a.a != b.b)&#123;<span class="comment">//不满足矩阵相乘条件</span></span><br><span class="line">                    error = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += (a.a*a.b*b.a);</span><br><span class="line">                    b.b = a.b;</span><br><span class="line">                    sta.push(b);<span class="comment">//将新矩阵入栈</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sta.push(buf[str[i]-<span class="string">'A'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (error)    <span class="built_in">printf</span> (<span class="string">"error\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-442&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Matrix Chain Multiplication&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Suppose you have to evaluate an expression like ABCDE where A,B,C,D and E are matrices.&lt;br&gt;Since matrix multiplication is associative, the order in which multiplications are performed is arbitrary.&lt;br&gt;However, the number of elementary multiplications needed strongly depends on the evaluation order&lt;br&gt;you choose.&lt;br&gt;For example, let A be a 5010 matrix, B a 1020 matrix and C a 205 matrix. There are two different strategies to compute ABC, namely (AB)C and A(B*C).&lt;br&gt;The first one takes 15000 elementary multiplications, but the second one only 3500.&lt;br&gt;Your job is to write a program that determines the number of elementary multiplications needed&lt;br&gt;for a given evaluation strategy.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 53 D-Berland Fair(模拟)</title>
    <link href="https://amannix.github.io/2018/10/26/Berland%20Fair/"/>
    <id>https://amannix.github.io/2018/10/26/Berland Fair/</id>
    <published>2018-10-26T07:14:28.000Z</published>
    <updated>2018-10-26T07:58:46.964Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1073/problem/D" target="_blank" rel="noopener">D.Berland Fair</a><br><strong>Description</strong><br><div class="note default"><p>XXI Berland Annual Fair is coming really soon! Traditionally fair consists of n booths, arranged in a circle. The booths are numbered 1 through n clockwise with n being adjacent to 1. The i-th booths sells some candies for the price of ai burles per item. Each booth has an unlimited supply of candies.<br>Polycarp has decided to spend at most T burles at the fair. However, he has some plan in mind for his path across the booths:</p><ol><li>at first, he visits booth number 1;</li><li>f he has enough burles to buy exactly one candy from the current booth, then he buys it immediately;</li><li>then he proceeds to the next booth in the clockwise order (regardless of if he bought a candy or not).<br>Polycarp’s money is finite, thus the process will end once he can no longer buy candy at any booth.<br>Calculate the number of candies Polycarp will buy.</li></ol></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains two integers n and T(1&lt;=n&lt;=2*10^5,1&lt;=T&lt;=10^18) — the number of booths at the fair and the initial amount of burles Polycarp has.<br>The second line contains n integers a1,a2…an (1&lt;ai&lt;10^9) — the price of the single candy at booth number i.</p></div><br><strong>Output</strong><br><div class="note default"><p>Print a single integer — the total number of candies Polycarp will buy.</p></div><br><strong>Sample Input</strong></p><blockquote><p>3 38<br>5 2 5</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>10</p></blockquote><p><strong>Thinking</strong><br>就是说一个循环链表，在链表中有N个摊位，每个摊位出售价格为ai的糖果。现在XXI手上有T元钱，从起点开始循环遍历，每遇到一个摊位如果钱足够的话就买下一颗糖，不够就去下一个摊位，重复循环知道他再也买不到糖为止。求这时买了多少颗糖。简单的循环模拟肯定T，因此可以先求出手上的钱单次循环足够买多少颗糖果。记录糖果数量X和花费Y，然后直接取余取整计算在一次遍历需要花费Y的情况下最多能遍历几次，即：T/Y*X就是还能买这么多次糖果，而剩余的钱就是T%Y。但是注意假设剩余M块钱，这里M块钱肯定不够一次遍历要花费Y元，必须重新计算在余钱M的情况下，单次遍历所花费的钱以及买的糖果数。因此要外加一个大循环，控制条件为剩余的钱一颗糖都买不起为止。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll buf[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,sum = <span class="number">0</span>,cand_sum = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%lld"</span>,&amp;buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        sum = cand_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + buf[i] &lt;= m)&#123;</span><br><span class="line">                sum += buf[i];<span class="comment">//记录一次遍历的花费</span></span><br><span class="line">                ++cand_sum;<span class="comment">//记录一次遍历买的糖果数量</span></span><br><span class="line">                flag = <span class="literal">false</span>;<span class="comment">//记录是否再也买不了了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        ans += m/sum*cand_sum;<span class="comment">//直接计算出N次遍历最多可以买多少糖果</span></span><br><span class="line">        m = m%sum;<span class="comment">//计算出N次遍历还剩多少钱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1073/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;D.Berland Fair&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;XXI Berland Annual Fair is coming really soon! Traditionally fair consists of n booths, arranged in a circle. The booths are numbered 1 through n clockwise with n being adjacent to 1. The i-th booths sells some candies for the price of ai burles per item. Each booth has an unlimited supply of candies.&lt;br&gt;Polycarp has decided to spend at most T burles at the fair. However, he has some plan in mind for his path across the booths:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;at first, he visits booth number 1;&lt;/li&gt;
&lt;li&gt;f he has enough burles to buy exactly one candy from the current booth, then he buys it immediately;&lt;/li&gt;
&lt;li&gt;then he proceeds to the next booth in the clockwise order (regardless of if he bought a candy or not).&lt;br&gt;Polycarp’s money is finite, thus the process will end once he can no longer buy candy at any booth.&lt;br&gt;Calculate the number of candies Polycarp will buy.&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="模拟" scheme="https://amannix.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 53 B-Vasya and Books(栈)</title>
    <link href="https://amannix.github.io/2018/10/26/Vasya%20and%20Books/"/>
    <id>https://amannix.github.io/2018/10/26/Vasya and Books/</id>
    <published>2018-10-26T06:52:14.000Z</published>
    <updated>2018-10-26T07:58:45.904Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/contest/1073/problem/B" target="_blank" rel="noopener">B. Vasya and Books</a><br><strong>Description</strong><br><div class="note default"><p>Vasya has got nn books, numbered from 11 to nn, arranged in a stack. The topmost book has number a1a1, the next one — a2a2, and so on. The book at the bottom of the stack has number anan. All numbers are distinct.</p><p>Vasya wants to move all the books to his backpack in nn steps. During ii-th step he wants to move the book number bibi into his backpack. If the book with number bibi is in the stack, he takes this book and all the books above the book bibi, and puts them into the backpack; otherwise he does nothing and begins the next step. For example, if books are arranged in the order [1,2,3][1,2,3] (book 11 is the topmost), and Vasya moves the books in the order [2,1,3][2,1,3], then during the first step he will move two books (11 and 22), during the second step he will do nothing (since book 11 is already in the backpack), and during the third step — one book (the book number 33). Note that b1,b2,…,bnb1,b2,…,bn are distinct.</p><p>Help Vasya! Tell him the number of books he will put into his backpack during each step.</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>The first line contains one integer n (1≤n≤2⋅105)n (1≤n≤2⋅105) — the number of books in the stack.<br>The second line contains nn integers a1,a2,…,an (1≤ai≤n)a1,a2,…,an (1≤ai≤n) denoting the stack of books.<br>The third line contains nn integers b1,b2,…,bn (1≤bi≤n)b1,b2,…,bn (1≤bi≤n) denoting the steps Vasya is going to perform.<br>All numbers a1…ana1…an are distinct, the same goes for b1…bnb1…bn.</p></div><br><strong>Output</strong><br><div class="note default"><p>Print nn integers. The ii-th of them should be equal to the number of books Vasya moves to his backpack during the ii-th step.</p></div><br><strong>Sample Input</strong></p><blockquote><p>3<br>1 2 3<br>2 1 3</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>2 0 1</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>5<br>3 1 4 2 5<br>4 5 1 3 2</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>3 2 0 0 0</p></blockquote><p><strong>Sample Input</strong></p><blockquote><p>6<br>6 5 4 3 2 1<br>6 5 3 4 2 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>1 1 2 0 1 1</p></blockquote><p><strong>Thinking</strong><br>题意是说有一堆书，给出这堆书的编号。然后按照某种顺序取书，假定取n号书，那么此时是将这个堆中n号及n号以前的所有书全部拿走。如果当前要取的书以及被拿走了，那么就什么都不做，现在问，每次拿书的操作一次会被拿走多少本书。所以我们可以按照给定的顺序用一个队列存放书的编号，为了快速查找对应编号所在队列位置可以建立哈希表以实现快速查找。接下来便是依次读取取书顺序，并且找到这本书在队列中的第几位，假设为K，然后直接K减去队首位置+1便是当前一次取到的书的本数。然后依次出队直到队首指针指向K为止。然后就继续读取操作。<br><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,top = <span class="number">1</span>,t;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        hash[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="comment">//printf ("%d %d\n",top,hash[k]);</span></span><br><span class="line">        <span class="keyword">if</span> (hash[k]-top &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,hash[k]-top+<span class="number">1</span>,i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">            top = hash[k]+<span class="number">1</span>;<span class="comment">//改变队首指针的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%d%c"</span>,<span class="number">0</span>,i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);<span class="comment">//一本书也不取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://codeforces.com/contest/1073/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B. Vasya and Books&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Vasya has got nn books, numbered from 11 to nn, arranged in a stack. The topmost book has number a1a1, the next one — a2a2, and so on. The book at the bottom of the stack has number anan. All numbers are distinct.&lt;/p&gt;
&lt;p&gt;Vasya wants to move all the books to his backpack in nn steps. During ii-th step he wants to move the book number bibi into his backpack. If the book with number bibi is in the stack, he takes this book and all the books above the book bibi, and puts them into the backpack; otherwise he does nothing and begins the next step. For example, if books are arranged in the order [1,2,3][1,2,3] (book 11 is the topmost), and Vasya moves the books in the order [2,1,3][2,1,3], then during the first step he will move two books (11 and 22), during the second step he will do nothing (since book 11 is already in the backpack), and during the third step — one book (the book number 33). Note that b1,b2,…,bnb1,b2,…,bn are distinct.&lt;/p&gt;
&lt;p&gt;Help Vasya! Tell him the number of books he will put into his backpack during each step.&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>UVA-514 Rails (栈)</title>
    <link href="https://amannix.github.io/2018/10/26/UVA-514/"/>
    <id>https://amannix.github.io/2018/10/26/UVA-514/</id>
    <published>2018-10-26T06:02:38.000Z</published>
    <updated>2018-10-26T07:57:52.147Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://vjudge.net/problem/UVA-514" target="_blank" rel="noopener">UVA-514 Rails</a></p><p><strong>Description</strong><br><div class="note default"><p>PopPush城市有一座著名的火车站。这个国家到处都是丘陵。而这个火车站是建于上一个世纪。不幸的是，那时的资金有限。所以只能建立起一条路面铁轨。而且，这导致这个火车站在同一个时刻只能一个轨道投入使用，因为它缺少空间，两列火车将无路可走。具体看下图。<br><img src="http://images.cppblog.com/cppblog_com/sixleaves/uva514.png" alt=""><br>当地的惯例是每一列火车从A方向驶向B方向时候，会用某种方式将车厢重组。假设火车将要到达A方向，拥有N个车厢(N&lt;=1000),这些车厢按照递增顺序标记为1到N。负责从组车厢的领导,必须知道是否能从组车厢让它驶出B，而这个重组的序列就是a1\a2\a3…aN.帮组他并且写一个程序来判断是否可能按照所要求的车厢顺序。你可以假设，单个的车厢可以从列车上分离出来，在他们进入站台之前。并且他们可以自由移动，知道它们上了B轨道。你也可以假设在任意时候站台可以放下无数的车厢。但是只要一个车厢进入站台，它就不能返回A轨道，同时如果它离开了站台驶向B轨道，它就不能返回站台。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>这个输入文件由多个行块组成。每一个块描述的是多个要求的重组车厢的序列。在这每个块中的第一行是一个整数N，被用来说明上面每行的车厢个数。这个快的最后一行仅仅是一个数字0要来标记该快的结束<br>最后一个块仅仅是一个0独占一行。</p></div><br><strong>Output</strong><br><div class="note default"><p>这个输出文件包含多行，这些行和排列车厢的行数一一对应。日过该排列可行，则输出Yes，否则输出No。另外存在一个空行在每个相对应的块后面。输出文件中不存在于最后一个什么数据都没有的响应输出。</p></div><br><strong>Sample Input</strong></p><blockquote><p>5<br>1 2 3 4 5<br>5 4 1 2 3<br>0<br>6<br>6 5 4 3 2 1<br>0<br>0</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>Yes<br>No<br>Yes  </p></blockquote><p><strong>Thinking</strong><br>紫书上第六章的例二。一个关于栈的模拟，光看的话感觉挺简单，但是一做起来还是不少麻烦。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sta_clear</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span>* top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!sta.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (num[*top] != sta.top())&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sta.pop();</span><br><span class="line">            ++*top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;t) &amp;&amp; t != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> num[<span class="number">10000</span>] = &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">while</span> (!sta.empty())    sta.pop();<span class="comment">//清空栈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;num[<span class="number">1</span>]!=<span class="number">0</span> &amp;&amp; i &lt;= t; ++i)&#123;</span><br><span class="line">                <span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;num[i]);<span class="comment">//读取出站队列</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[<span class="number">1</span>] == <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num[top] == i)&#123;<span class="comment">//当进入站点的火车与出站队列首部相等时，出队</span></span><br><span class="line">                    ++top;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sta.size() &amp;&amp; num[top] == sta.top())&#123;</span><br><span class="line">                    sta_clear(num,&amp;top);<span class="comment">//当队首和栈顶元素相等时，必须得从栈顶开始向下遍历弹出</span></span><br><span class="line">                    sta.push(i);<span class="comment">//必须等遍历弹出结束之后再入栈。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    sta.push(i);<span class="comment">//队首元素无法匹配</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sta_clear(num,&amp;top);<span class="comment">//再次从栈顶出发向下匹配</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%s\n"</span>,sta.empty() ? <span class="string">"Yes"</span>:<span class="string">"No"</span>);<span class="comment">//栈为空则完全匹配成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://vjudge.net/problem/UVA-514&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UVA-514 Rails&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;PopPush城市有一座著名的火车站。这个国家到处都是丘陵。而这个火车站是建于上一个世纪。不幸的是，那时的资金有限。所以只能建立起一条路面铁轨。而且，这导致这个火车站在同一个时刻只能一个轨道投入使用，因为它缺少空间，两列火车将无路可走。具体看下图。&lt;br&gt;&lt;img src=&quot;http://images.cppblog.com/cppblog_com/sixleaves/uva514.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;当地的惯例是每一列火车从A方向驶向B方向时候，会用某种方式将车厢重组。假设火车将要到达A方向，拥有N个车厢(N&amp;lt;=1000),这些车厢按照递增顺序标记为1到N。负责从组车厢的领导,必须知道是否能从组车厢让它驶出B，而这个重组的序列就是a1\a2\a3…aN.帮组他并且写一个程序来判断是否可能按照所要求的车厢顺序。你可以假设，单个的车厢可以从列车上分离出来，在他们进入站台之前。并且他们可以自由移动，知道它们上了B轨道。你也可以假设在任意时候站台可以放下无数的车厢。但是只要一个车厢进入站台，它就不能返回A轨道，同时如果它离开了站台驶向B轨道，它就不能返回站台。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://amannix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>牛客国庆集训派对Day1-L New Game! (几何建图+最短路径)</title>
    <link href="https://amannix.github.io/2018/10/24/%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day1-L/"/>
    <id>https://amannix.github.io/2018/10/24/牛客国庆集训派对Day1-L/</id>
    <published>2018-10-23T16:02:05.000Z</published>
    <updated>2018-10-23T16:12:16.383Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.nowcoder.com/acm/contest/201/L" target="_blank" rel="noopener">牛客国庆集训派对Day1-L New Game!</a><br><strong>Description</strong><br><div class="note default"><p>Eagle Jump公司正在开发一款新的游戏。Hifumi Takimoto作为其中的员工，获得了提前试玩的机会。现在她正在试图通过一个迷宫。<br>这个迷宫有一些特点。为了方便描述，我们对这个迷宫建立平面直角坐标系。迷宫中有两条平行直线 L1:Ax+By+C1=0, L2:Ax+By+C2=0，还有 n 个圆 。角色在直线上、圆上、园内行走不消耗体力。在其他位置上由S点走到T点消耗的体力为S和T的欧几里得距离。<br>Hifumi Takimoto想从 L1 出发，走到 L2 。请计算最少需要多少体力。</p></div><br><a id="more"></a><br><strong>Input</strong><br><div class="note default"><p>第一行五个正整数 n,A,B,C1,C2 (1≤ n ≤ 1000, -10000 ≤ A,B,C1,C2 ≤ 10000)，其中 A,B 不同时为 0。<br>接下来 n 行每行三个整数 x,y,r(-10000 ≤ x,y ≤ 10000, 1≤ r ≤ 10000) 表示一个圆心为 (x,y)，半径为 r 的圆。</p></div><br><strong>Output</strong><br><div class="note default"><p>仅一行一个实数表示答案。与正确结果的绝对误差或者相对误差不超过 10^-4 即算正确。</p></div><br><strong>Sample Input</strong></p><blockquote><p>2 0 1 0 -4<br>0 1 1<br>1 3 1</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0.236068</p></blockquote><p><strong>Thinking</strong><br>相当有趣的图论题，乍一看以为是集合题，瞎想了好久。发现是图论，但是最后建图还是有错。正解建图应该是把所有的圆和直线都看做点，这样就是n+2个点直接两两枚举求出欧式距离即可。只是需要特判到底是求圆与圆之间的距离还是线到圆的距离而已，反正这样建图之后就是裸的最短路算法。</p><p><strong>Code</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> maxn = <span class="number">0xffffffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> A,B,C;</span><br><span class="line">&#125;a,b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y,r,dis;</span><br><span class="line">&#125;coor[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Line_dis,ans = maxn;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node a,Node b)</span><span class="comment">//计算两圆之间的最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp_dis = <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)) - a.r - b.r;</span><br><span class="line"><span class="keyword">return</span> temp_dis &gt; <span class="number">0</span> ? temp_dis : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ans_dis</span><span class="params">(Node a,Line b)</span><span class="comment">//计算圆到直线的最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp_dis = <span class="built_in">fabs</span>(a.x*b.A+a.y*b.B+b.C)/<span class="built_in">sqrt</span>(b.A*b.A+b.B*b.B) - a.r;</span><br><span class="line"><span class="keyword">return</span> temp_dis &gt; <span class="number">0</span> ? temp_dis : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> book[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> _dis[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">2</span>; ++i)&#123;</span><br><span class="line">_dis[i] = coor[n+<span class="number">1</span>][i].dis;</span><br><span class="line">&#125;</span><br><span class="line">_dis[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">book[n+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n+<span class="number">2</span>; i++)&#123;</span><br><span class="line"><span class="keyword">double</span> min = maxn;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; _dis[j] &amp;&amp; !book[j])&#123;</span><br><span class="line">min = _dis[j];</span><br><span class="line">total = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">book[total] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span> ;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!book[j] &amp;&amp; _dis[j] &gt; coor[total][j].dis + _dis[total])&#123;</span><br><span class="line">_dis[j] = coor[total][j].dis + _dis[total];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _dis[n+<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">2</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span>; ++j)&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lf "</span>,coor[i][j].dis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//读取数据并且建立无向图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d%lf%lf%lf%lf"</span>,&amp;n,&amp;a.A,&amp;a.B,&amp;a.C,&amp;b.C);</span><br><span class="line">b.A = a.A;</span><br><span class="line">b.B = a.B;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">2</span>; ++i)&#123;<span class="comment">//Init</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">2</span>; ++j)&#123;</span><br><span class="line">coor[i][j].dis = coor[j][i].dis = maxn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line_dis = <span class="built_in">fabs</span>(a.C-b.C)/<span class="built_in">sqrt</span>(a.A*a.A+a.B*a.B);</span><br><span class="line">coor[n+<span class="number">2</span>][n+<span class="number">1</span>].dis = coor[n+<span class="number">1</span>][n+<span class="number">2</span>].dis = Line_dis;<span class="comment">//把两条直线放在最后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf%lf%lf"</span>,&amp;coor[i][i].x,&amp;coor[i][i].y,&amp;coor[i][i].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;<span class="comment">//先循环枚举求圆之间的距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= n; ++j)&#123;<span class="comment">//我他妈枚举变量写错了</span></span><br><span class="line">coor[j][i].dis = coor[i][j].dis = dis(coor[i][i],coor[j][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;<span class="comment">//枚举求两直线到所有圆之间的距离。</span></span><br><span class="line">coor[i][n+<span class="number">1</span>].dis = coor[n+<span class="number">1</span>][i].dis = ans_dis(coor[i][i],a);</span><br><span class="line">coor[i][n+<span class="number">2</span>].dis = coor[n+<span class="number">2</span>][i].dis = ans_dis(coor[i][i],b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init();</span><br><span class="line">ans = Dijkstra();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lf\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">work();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.nowcoder.com/acm/contest/201/L&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客国庆集训派对Day1-L New Game!&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;br&gt;&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;Eagle Jump公司正在开发一款新的游戏。Hifumi Takimoto作为其中的员工，获得了提前试玩的机会。现在她正在试图通过一个迷宫。&lt;br&gt;这个迷宫有一些特点。为了方便描述，我们对这个迷宫建立平面直角坐标系。迷宫中有两条平行直线 L1:Ax+By+C1=0, L2:Ax+By+C2=0，还有 n 个圆 。角色在直线上、圆上、园内行走不消耗体力。在其他位置上由S点走到T点消耗的体力为S和T的欧几里得距离。&lt;br&gt;Hifumi Takimoto想从 L1 出发，走到 L2 。请计算最少需要多少体力。&lt;/p&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ACM题解" scheme="https://amannix.github.io/categories/ACM%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="https://amannix.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
</feed>
