<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Weakened Common Divisor]]></title>
    <url>%2F2018%2F09%2F01%2FWeakened%20Common%20Divisor%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #505 Weakened Common Divisor Description During the research on properties of the greatest common divisor (GCD) of a set of numbers, Ildar, a famous mathematician, introduced a brand new concept of the weakened common divisor (WCD) of a list of pairs of integers. For a given list of pairs of integers (a1,b1)(a1,b1), (a2,b2)(a2,b2), …, (an,bn)(an,bn) their WCD is arbitrary integer greater than 11, such that it divides at least one element in each pair. WCD may not exist for some lists. For example, if the list looks like [(12,15),(25,18),(10,24)], then their WCD can be equal to 22, 33, 55 or 66 (each of these numbers is strictly greater than 11 and divides at least one number in each pair). You’re currently pursuing your PhD degree under Ildar’s mentorship, and that’s why this problem was delegated to you. Your task is to calculate WCD efficiently. Input The first line contains a single integer nn (1≤n≤150000) — the number of pairs. Each of the next nn lines contains two integer values aiai, bibi (2≤ai,bi≤2⋅10^9). Output Print a single integer — the WCD of the set of pairs. If there are multiple possible answers, output any; if there is no answer, print −1−1. input 317 1815 2412 15 output 6 input 210 167 17 output -1 input 590 10845 10575 40165 17533 30 output 5 题意大意是说给出n组数，每组两个数字。从每组数中取出一个数，求n组数的质因数。不存在则输出-1。 思路假设给出一组数a b，a或b的质因数必然也是a*b的质因数。之后再枚举第一组数据的质因数即可。 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll gcd(ll a,ll b)&#123; return b == 0?a:gcd(b,a%b);&#125;ll get_ans(ll n)//为了防止最初的答案大于题目给出的数据&#123; for (int i = 2;i * i &lt;= n; ++i)&#123; if (n % i == 0) return i; &#125; return n;&#125;int main ()&#123; ll a,b,n,A,B; scanf("%lld%lld%lld",&amp;n,&amp;a,&amp;b); while (--n)&#123; scanf ("%lld%lld",&amp;A,&amp;B); a = gcd(A*B,a); b = gcd(A*B,b); &#125; if (a != 1)&#123; printf ("%lld\n",get_ans(a)); &#125; else if (b != 1)&#123; printf ("%lld\n",get_ans(b)); &#125; else&#123; printf ("-1\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces Round 49-Minimum Value Rectangle]]></title>
    <url>%2F2018%2F08%2F20%2FMinimum%20Value%20Rectangle%2F</url>
    <content type="text"><![CDATA[传送门：C. Minimum Value Rectangle Problem Description You have n sticks of the given lengths. Your task is to choose exactly four of them in such a way that they can form a rectangle. No sticks can be cut to pieces, each side of the rectangle must be formed by a single stick. No stick can be chosen multiple times. It is guaranteed that it is always possible to choose such sticks. Let S be the area of the rectangle and P be the perimeter of the rectangle. The chosen rectangle should have the value P^2/S minimal possible. The value is taken without any rounding. If there are multiple answers, print any of them. Each testcase contains several lists of sticks, for each of them you are required to solve the problem separately.Example Input347 2 2 782 8 1 4 8 2 1 555 5 5 5 5 Output2 7 7 22 2 1 15 5 5 5 大意就是说有T次查询，每次给出n条边，选出四条边组成一个矩形。然后P是其周长，S是面积现在求出P^2/S最小时，边长的组合。答案不唯一。每条边的边长不超过10^4。在所有的T次查询中，所有边的数量之和不会超过10^6。 思路:由于矩形的定义就是四个角都是直角。所以可以假设边长为a，b。代入P^2/S中得 4*(a/b + b/a + 2) 其中 a/b + b/a 可以令 t = a/b 转化成 (t + 1/t) .这个这里可以得出当a == b时式子最小等于2。于是可以得出原式 &gt;=16 。并且我们可以看出去最小时a，b之间的关系是a和b尽可能的相等。于是这道题只需要排序之后把大于2的边拿出来。答案一定是排序之后两条长度相邻的边。 然后从小到大两两进行比较，找出最优解。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;using namespace std;int edg[1000005];int temp[1000005];int main ()&#123; int t,n; scanf ("%d",&amp;t); ++t; while (--t)&#123; scanf ("%d",&amp;n); for (int i = 0;i &lt; n; ++i)&#123; scanf ("%d",&amp;edg[i]); &#125; sort (edg,edg+n); int cnt = -1; for (int i = 1;i &lt; n; ++i)&#123; if (edg[i] == edg[i-1])&#123;//如果有两条相等的边，就把它放入temp数组 temp[++cnt] = edg[i]; edg[i] = edg[i-1] = -1;/*这一步是必须的，否则会误判边的数量 如果edg有1 1 1.三个数，那么根据规律会有两个1被选入temp 接下来的处理中就会使用两条边为 1和1来组成矩形。可实际上并没有四条长度为1的边。*/ &#125; &#125; int s = -1; double Min = 999989.0; double t; for (int i = 1;i &lt;= cnt; ++i)&#123; //枚举两条相邻的边找出最优解 t = 4 * (double)(temp[i-1]+temp[i]) * (double)(temp[i-1]+temp[i]) / (double)(temp[i-1]*temp[i]); //printf ("%d %d %lf\n",temp[i],temp[i-1],t); if (Min &gt; t)&#123; Min = t; s = i; &#125; &#125; printf ("%d %d %d %d\n",temp[s],temp[s],temp[s-1],temp[s-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-4081 Qin Shi Huang's National Road System(次小生成树)]]></title>
    <url>%2F2018%2F08%2F17%2Fhdu-4081%2F</url>
    <content type="text"><![CDATA[传送门：Qin Shi Huang’s National Road SystemProblem Description During the Warring States Period of ancient China(476 BC to 221 BC), there were seven kingdoms in China —- they were Qi, Chu, Yan, Han, Zhao, Wei and Qin. Ying Zheng was the king of the kingdom Qin. Through 9 years of wars, he finally conquered all six other kingdoms and became the first emperor of a unified China in 221 BC. That was Qin dynasty —- the first imperial dynasty of China(not to be confused with the Qing Dynasty, the last dynasty of China). So Ying Zheng named himself “Qin Shi Huang” because “Shi Huang” means “the first emperor” in Chinese.Qin Shi Huang undertook gigantic projects, including the first version of the Great Wall of China, the now famous city-sized mausoleum guarded by a life-sized Terracotta Army, and a massive national road system. There is a story about the road system:There were n cities in China and Qin Shi Huang wanted them all be connected by n-1 roads, in order that he could go to every city from the capital city Xianyang.Although Qin Shi Huang was a tyrant, he wanted the total length of all roads to be minimum,so that the road system may not cost too many people’s life. A daoshi (some kind of monk) named Xu Fu told Qin Shi Huang that he could build a road by magic and that magic road would cost no money and no labor. But Xu Fu could only build ONE magic road for Qin Shi Huang. So Qin Shi Huang had to decide where to build the magic road. Qin Shi Huang wanted the total length of all none magic roads to be as small as possible, but Xu Fu wanted the magic road to benefit as many people as possible —- So Qin Shi Huang decided that the value of A/B (the ratio of A to B) must be the maximum, which A is the total population of the two cites connected by the magic road, and B is the total length of none magic roads.Would you help Qin Shi Huang?A city can be considered as a point, and a road can be considered as a line segment connecting two points. Input The first line contains an integer t meaning that there are t test cases(t &lt;= 10).For each test case:The first line is an integer n meaning that there are n cities(2 &lt; n &lt;= 1000).Then n lines follow. Each line contains three integers X, Y and P ( 0 &lt;= X, Y &lt;= 1000, 0 &lt; P &lt; 100000). (X, Y) is the coordinate of a city and P is the population of that city.It is guaranteed that each city has a distinct location.Output For each test case, print a line indicating the above mentioned maximum ratio A/B. The result should be rounded to 2 digits after decimal point. Sample Input 241 1 201 2 30200 2 80200 1 10031 1 201 2 302 2 40 Sample Output 65.0070.00 &emsp;&emsp;题意：给出一堆城市，现在要在每个城市修建公路。要求在公路总长度尽可能的短，并且连接所有的城市。然后这个城市都有一定的人口，现在有一个道士可以使得某条道路不花费任何资源直接变出来。现在要求是，假设这条变出来的道路所连接城市的人口是A ，总的道路长度减去变出来那条路的长度为B。求A/B的最大值，保证A/B最大的同时其他道路总长要求尽可能的短 &emsp;&emsp;思路：先求最小生成树，然后在题目给的无向图里面枚举每一条边，如果这条边没在生成树里面的话就暂时把它加进去，但是加进去的话生成树就会形成一个环。这时就要找出这个环里面的最大的边把它删掉，求出次小生成树。然后把最小生成树的总权值减去之后删掉的边就是B，那条加入的边连接的两点人数之和就是A。重复枚举边做这个过程找出最大的A/B。&emsp;&emsp;这里关于prim算法有一个以前没注意到的细节，那就是prim算法每次确定下一条边的时候，这个确定的顺序一定是按照从根节点开始向下延伸的。&emsp;&emsp;所以关于建树，用一个数组记录每次使用的边的前驱即可。假设low数组中求得的最小值位置为index，那么low[index]代表的是一条边，并且这个index代表的节点一定是这条边上更加远离根节点的。所以在下一步对生成树进行优化的时候。对于可被优化的low[p];应令pre[p] = index;去记录前驱。&emsp;&emsp;感觉这题最难的地方是由于新加入的边必定会连接A-B两个点。那么便要DP找出最小生成树上A-B两点之间的最大边以便将其删除。其状态转移方程如下： vis[j][index] = vis[index][j] = max(vis[j][pre[index]],low[index]); &emsp;&emsp;在这个式子中，vis保存任意两点之间的最大边，pre是前驱。那么对于某一个节点j，当j是prim算法使用过的节点。那么，j到其他已经被确定的点之间的最大边必定是处理过的。又由于生成树的过程是从根节点开始延伸，所以只需要每次确定出index的时候遍历出v[j]，如果j被使用过，就比较index的前驱（这里pre[index]由于生成树的过程是从根节点开始延伸，所以与j之间的最长边必定被处理过）与index到pre[index]这条边就可以了。这里low[index]就是index-pre[index]这条边。这个DP还是比较难以理解的。 &emsp;&emsp;如上图所示，vis所谓的两点之间最长边就是指如果我把7-9这条边加进去，那么3-6-9-7便形成环，所以我就要求出vis[7][9]–7到9之间的在原本还不是环的时候（也就是最小生成树上的）的最大边也就是6-9（权值为4）。这时我要求7-9的最大边，假设我当前index为7且9被使用过。那么比较pre[7]（也就是3）到9的最大边和7到3的边就OK了。再次重申由于最小生成树建树是从根节点开始延伸，所以index的前驱和其他被使用过的节点之间一定被处理过。 &emsp;&emsp;有个坑点是在传统prim算法中，用index去优化low数组时，会加上一个条件是当前被优化的j节点没被使用过，但是这个条件不加上的话对于生成树的最后答案并无影响，可是却会对严重影响DP的过程，因为这个原因WA了好几发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;const int Inf=0x3f3f3f3f;using namespace std;double vis[1005][1005];int book[1005][1005];struct node&#123; int p;//两城市之间人口 double dis;//城市之间距离&#125;ma[1005][1005];struct Point&#123; int x,y; int v;//城市的人口&#125;point[1005];double Dis(Point a,Point b)&#123; return sqrt((double)(a.x-b.x)*(a.x-b.x)+(double)(a.y-b.y)*(a.y-b.y));&#125;double prim(int n)&#123; int v[1005] = &#123;0&#125;,pre[1005]; double dis[1005],ans = 0; v[1] = 1; for (int i = 1;i &lt;= n; ++i)&#123; dis[i] = ma[1][i].dis;//1为根节点 pre[i] = 1;//节点的前驱 &#125; for (int i = 1;i &lt; n; ++i)&#123; int index = 0; for (int j = 1;j &lt;= n; ++j)&#123; if ((index == 0 || dis[index] &gt; dis[j]) &amp;&amp; !v[j])&#123; index = j; &#125; &#125; v[index] = 1; ans += dis[index]; book[index][pre[index]] = book[pre[index]][index] = 1;//记录被使用过的边 for (int j = 1;j &lt;= n; ++j)&#123; if (v[j] &amp;&amp; j != index)&#123; //这里一个DP找出生成树上任意两点间的最大边 vis[j][index] = vis[index][j] = max(vis[j][pre[index]],dis[index]); &#125; if (!v[j] &amp;&amp; dis[j] &gt; ma[index][j].dis)&#123;//这里优化的时候!v[j]这个条件必须加上！！！！ dis[j] = ma[index][j].dis; pre[j] = index; &#125; &#125; &#125; return ans;&#125;void create(int n)&#123; for (int i = 1;i &lt;= n; ++i)&#123; for (int j = i+1;j &lt;= n; ++j)&#123; if (i == j)&#123; ma[i][j].dis = ma[j][i].dis = Inf*1.0; ma[i][j].p = ma[j][i].p = Inf*1.0; continue; &#125; ma[i][j].dis = ma[j][i].dis = Dis(point[i],point[j]); ma[i][j].p = ma[j][i].p = point[i].v + point[j].v; &#125; &#125;&#125;double DP(int n,double MST)&#123; double ans = 0; for (int i = 1;i &lt;= n; ++i)&#123; for (int j = i+1;j &lt;= n; ++j)&#123; if (i != j)&#123; if (book[i][j])&#123;//如果当前遍历的边就在最小生成树上 ans = max(ans,1.0*(ma[i][j].p)/(MST - ma[i][j].dis)); &#125; else&#123; ans = max(ans,1.0*(ma[i][j].p)/(MST - vis[i][j]));//如果不在 &#125; &#125; &#125; &#125; return ans;&#125;void solve()&#123; int t,n; double MST,ans = 0; scanf ("%d",&amp;t); while (t--)&#123; ans = 0;//又他娘的忘记初始化WA好几发-.-! scanf ("%d",&amp;n); memset(book,0,sizeof book); memset(vis,0,sizeof vis); memset(ma,0,sizeof ma); memset(point,0,sizeof point); for (int i = 1;i &lt;= n; ++i)&#123; scanf ("%d%d%d",&amp;point[i].x,&amp;point[i].y,&amp;point[i].v); &#125; create(n); MST = prim(n); ans = DP(n,MST); printf ("%.2f\n",ans); &#125;&#125;int main ()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1679 Unique MST(判断最小生成树是否唯一)]]></title>
    <url>%2F2018%2F08%2F16%2FPOJ-1679%20Unique%20MST%2F</url>
    <content type="text"><![CDATA[传送门：POJ-1679 Unique MST Description Given a connected undirected graph, tell if its minimum spanning tree is unique. Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: V’ = V. T is connected and acyclic. Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’.Input The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. Each case represents a graph. It begins with a line containing two integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the following m lines contains a triple (xi, yi, wi), indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them.Output For each input, if the MST is unique, print the total cost of it, or otherwise print the string ‘Not Unique!’.Sample Input 23 31 2 12 3 23 1 34 41 2 22 3 23 4 24 1 2Sample Output 3Not Unique! 思路选择邻接矩阵存图，读取边的时候先判断是否存在两条相同的边，如果存在则MST不唯一。再做出最小生成树，将所有已经使用过的边，依次从邻接矩阵中删除，再求最小生成树如果两次答案一致，则MST不唯一。不要忘记删除过的边要再放回去。Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define Inf 0x3f3f3f3fusing namespace std;bool flag;struct node&#123; int s,e,v;&#125;edg[205];//记录最小生成树所包含的边的信息int ma[205][205],cnt;//cnt记录最小生成树的边的数量int prime(int n,bool bug);int cmp(node a,node b)&#123; return a.v &gt; b.v;&#125;void judge(int cnt,int n,int ans)&#123; sort(edg,edg+cnt,cmp); for (int i = 0;i &lt; cnt; ++i)&#123; /*将每条使用过的边都从邻接矩阵中删除，再求一次最小生成树， 如果与之前相同，则MST不唯一*/ ma[edg[i].s][edg[i].e] = Inf; ma[edg[i].e][edg[i].s] = Inf; if (prime(n,false) == ans)&#123; flag = true; return ; &#125; //不要忘了删掉的边要再添加回去 ma[edg[i].s][edg[i].e] = edg[i].v; ma[edg[i].e][edg[i].s] = edg[i].v; &#125; flag = false;&#125;int prime(int n,bool bug)&#123; int vis[205] = &#123;0&#125;,ans = 0; if (bug)&#123;//bug变量标记在judge函数中调用不需要对edg做修改 memset(edg,0,sizeof edg); cnt = 0; &#125; node temp[205]; for (int i = 2;i &lt;= n; i++)&#123; temp[i].v = ma[1][i]; temp[i].s = 1; temp[i].e = i; //printf ("%d\n",temp[i]); &#125; vis[1] = 1; for (int i = 1;i &lt; n; ++i)&#123; int index = -1,Min = Inf; for (int j = 1;j &lt;= n; ++j)&#123; if (Min &gt; temp[j].v &amp;&amp; !vis[j])&#123; Min = temp[j].v; index = j; &#125; &#125; if (bug) edg[cnt++] = temp[index]; vis[index] = 1; //printf ("%d\n",index); ans += temp[index].v; for (int j = 1;j &lt;= n; ++j)&#123; if (temp[j].v &gt; ma[index][j])&#123; temp[j].v = ma[index][j]; temp[j].s = index; temp[j].e = j; &#125; &#125; &#125; return ans;&#125;void solve()&#123; int t,m,n,a,b,c,ans; scanf ("%d",&amp;t); while (t--)&#123; memset(ma,Inf,sizeof ma); scanf ("%d%d",&amp;n,&amp;m); for (int i = 1;i &lt;= m; ++i)&#123; scanf ("%d%d%d",&amp;a,&amp;b,&amp;c); if (c == ma[a][b])&#123;//判断是否存在两条相同的边。 flag = true; &#125; ma[a][b] = min(ma[a][b],c);//每条边只取最小值 ma[b][a] = min(ma[b][a],c); &#125; ans = prime(n,true); judge(cnt,n,ans); if (flag)&#123; printf ("Not Unique!\n"); continue; &#125; else&#123; printf ("%d\n",ans); &#125; &#125;&#125;int main ()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PID算法小结]]></title>
    <url>%2F2018%2F08%2F15%2FPID%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在控制算法系统中，先设定一个目标值假设为S，再由传感器定时采样。假设读取的值为依次为X1，X2，X3……Xk。 P(比例)控制:&emsp;&emsp;假设对每次采样的结果Xk，使Pk = S - Xk。其产生三种结果 Pk &gt; 0 当前值未达标Pk == 0 当前值已达标Pk &lt; 0 当前值超标 &emsp;&emsp;则在P控制中，TOUT = Kp * Pk，其中Kp为常数，起到一个等比例放大或缩小的作用Pk实际意义便是与目标的差值，P控制的输出量由这个差值等比例放大决定。 I(积分)控制&emsp;&emsp;假设Sk = ∑Pn （n ∈[1,k]）。同样的，由于Pk的值有正有负。因此Sk的值也分为三种情况 Sk &gt; 0 在过去的时间内，系统总体上是不达标的Sk == 0 在过去的时间内，系统总体上是达标的Sk &lt; 0 在过去的时间内，系统总体上是超标的 &emsp;&emsp;此时TOUT = Kp * Sk 对应的是积分操作，由过去历史总体情况作出预测。缺点是较长时间之前的数据也会对现在的预测产生影响。 D(微分)控制&emsp;&emsp;由于之前已经取得了每个采集样本的Pk值，即采集值与目标值的偏移量，使Dk = Pk - P(k-1)则Dk描述了此偏移量的变化的快慢。同样分为三种结果 Dk &gt; 0Dk == 0Dk &lt; 0 &emsp;&emsp;此时的TOUT = Kp * Dk，显而易见这时的输出量由变化率决定。变化率越大，则输出值越大 PID的数学模型&emsp;&emsp;基于上式，最后输出值TOUT = Pout + Iout + Dout代入合并之后 Tout = (Kp Pk) + (Kp Sk) + (Kp * Dk) (关于Sk Dk的处理下次在写叭)]]></content>
      <categories>
        <category>嵌入式算法</category>
      </categories>
      <tags>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网练习赛24-B凤凰]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%BB%83%E4%B9%A0%E8%B5%9B24-B%E5%87%A4%E5%87%B0%2F</url>
    <content type="text"><![CDATA[传送门：牛客网练习赛24-B凤凰 Describe 凤凰于飞，翙翙其羽，亦集爰止。《诗经·卷阿》传说，凤凰是百鸟之王。有一天，凤凰要召开百鸟大会，百鸟国是一个由n个节点组成的树，每个节点有一只鸟，开会的节点定在1号节点。每只鸟可以花费1s通过一条边，由于每根树枝(边)的载重有限，只允许一只鸟同时通过。作为会议的策划师，HtBest想知道百鸟国的所有鸟在1点集合最少需要多少秒。 Input 第一行有一个正整数n，表示百鸟国节点个数。接下来n-1行，第i行两个正整数ai,bi用空格隔开，表示树上节点ai,bi之间有一条边。 Output 第一行一个整数，表示集合最少需要的时间。 Example1 Input31 22 3Output2 Example2 Input31 21 3Output1 Example3 Input41 22 32 4Output3 Remark 对于100%的测试数据：1 ≤ n ≤ 1000000数据量较大，注意使用更快的输入输出方式。 &emsp;&emsp;首先明确每一个节点上都存在一只鸟，假设存在n条通往根节点（1）的路径。因此可以得到有n颗子树挂载在根节点上，不难发现所有子树上如果有m只鸟那么想要全部到达根节点必定要花费m秒。&emsp;&emsp;由于每一个节点必定存在一只鸟，因此不难证明不存在子树上有某只鸟还没通过靠近根节点路径，但是其他鸟已经全部抵达的情况。还有就是题目明确指出是树形结构，所以也不存在一颗子树存在两条通往根节点的路径的情况，否则便是图形结构。&emsp;&emsp;因此题目转化为求最大子树的节点数。两种思路可广搜遍历子树求得节点数，更为便捷的方式是并查集求解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int maxn = 1e6+5;ll F[maxn],sum[maxn];ll max(ll a,ll b)&#123; return a &gt; b ? a : b;&#125;ll find(ll u)&#123; return u == F[u] ? u : F[u] = find(F[u]);&#125;void fun_union(ll u,ll v)&#123; ll x = find(u),y = find(v); if (x != y)&#123; F[x] = y; &#125;&#125;void solve()&#123; ll cnt; scanf ("%lld",&amp;cnt); for (ll i = 1;i &lt;= cnt; ++i)&#123; F[i] = i; &#125; for (ll i = 1;i &lt; cnt; ++i)&#123; ll a,b; scanf ("%lld%lld",&amp;a,&amp;b); if (a != 1 &amp;&amp; b != 1)//由于题目给出的是整颗数，所以要排除根节点以外求子树 fun_union(a,b); &#125; for (ll i = 1;i &lt;= cnt; ++i)&#123; ++sum[F[find(i)]];//求不同子树的节点数 &#125; printf ("%lld\n",*max_element(sum+1,sum+cnt+1));//该函数求区间内最大值，返回一个指针。&#125;int main ()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
