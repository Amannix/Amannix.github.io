<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PID算法小结]]></title>
    <url>%2F2018%2F08%2F15%2FPID%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在控制算法系统中，先设定一个目标值假设为S，再由传感器定时采样。假设读取的值为依次为X1，X2，X3……Xk。 P(比例)控制:&emsp;&emsp;假设对每次采样的结果Xk，使Pk = S - Xk。其产生三种结果 Pk &gt; 0 当前值未达标Pk == 0 当前值已达标Pk &lt; 0 当前值超标 &emsp;&emsp;则在P控制中，TOUT = Kp * Pk，其中Kp为常数，起到一个等比例放大或缩小的作用Pk实际意义便是与目标的差值，P控制的输出量由这个差值等比例放大决定。 I(积分)控制&emsp;&emsp;假设Sk = ∑Pn （n ∈[1,k]）。同样的，由于Pk的值有正有负。因此Sk的值也分为三种情况 Sk &gt; 0 在过去的时间内，系统总体上是不达标的Sk == 0 在过去的时间内，系统总体上是达标的Sk &lt; 0 在过去的时间内，系统总体上是超标的 &emsp;&emsp;此时TOUT = Kp * Sk 对应的是积分操作，由过去历史总体情况作出预测。缺点是较长时间之前的数据也会对现在的预测产生影响。 D(微分)控制&emsp;&emsp;由于之前已经取得了每个采集样本的Pk值，即采集值与目标值的偏移量，使Dk = Pk - P(k-1)则Dk描述了此偏移量的变化的快慢。同样分为三种结果 Dk &gt; 0Dk == 0Dk &lt; 0 &emsp;&emsp;此时的TOUT = Kp * Dk，显而易见这时的输出量由变化率决定。变化率越大，则输出值越大 PID的数学模型&emsp;&emsp;基于上式，最后输出值TOUT = Pout + Iout + Dout代入合并之后 Tout = (Kp Pk) + (Kp Sk) + (Kp * Dk) (关于Sk Dk的处理下次在写叭)]]></content>
      <categories>
        <category>嵌入式算法</category>
      </categories>
      <tags>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1679 Unique MST(判断最小生成树是否唯一)]]></title>
    <url>%2F2018%2F08%2F12%2FPOJ-1679%20Unique%20MST%2F</url>
    <content type="text"><![CDATA[POJ-1679 Unique MST Description Given a connected undirected graph, tell if its minimum spanning tree is unique. Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: V’ = V. T is connected and acyclic. Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’.Input The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. Each case represents a graph. It begins with a line containing two integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the following m lines contains a triple (xi, yi, wi), indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them.Output For each input, if the MST is unique, print the total cost of it, or otherwise print the string ‘Not Unique!’.Sample Input 23 31 2 12 3 23 1 34 41 2 22 3 23 4 24 1 2Sample Output 3Not Unique! 思路选择邻接矩阵存图，读取边的时候先判断是否存在两条相同的边，如果存在则MST不唯一。再做出最小生成树，将所有已经使用过的边，依次从邻接矩阵中删除，再求最小生成树如果两次答案一致，则MST不唯一。不要忘记删除过的边要再放回去。Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define Inf 0x3f3f3f3fusing namespace std;bool flag;struct node&#123; int s,e,v;&#125;edg[205];//记录最小生成树所包含的边的信息int ma[205][205],cnt;//cnt记录最小生成树的边的数量int prime(int n,bool bug);int cmp(node a,node b)&#123; return a.v &gt; b.v;&#125;void judge(int cnt,int n,int ans)&#123; sort(edg,edg+cnt,cmp); for (int i = 0;i &lt; cnt; ++i)&#123; /*将每条使用过的边都从邻接矩阵中删除，再求一次最小生成树， 如果与之前相同，则MST不唯一*/ ma[edg[i].s][edg[i].e] = Inf; ma[edg[i].e][edg[i].s] = Inf; if (prime(n,false) == ans)&#123; flag = true; return ; &#125; //不要忘了删掉的边要再添加回去 ma[edg[i].s][edg[i].e] = edg[i].v; ma[edg[i].e][edg[i].s] = edg[i].v; &#125; flag = false;&#125;int prime(int n,bool bug)&#123; int vis[205] = &#123;0&#125;,ans = 0; if (bug)&#123;//bug变量标记在judge函数中调用不需要对edg做修改 memset(edg,0,sizeof edg); cnt = 0; &#125; node temp[205]; for (int i = 2;i &lt;= n; i++)&#123; temp[i].v = ma[1][i]; temp[i].s = 1; temp[i].e = i; //printf ("%d\n",temp[i]); &#125; vis[1] = 1; for (int i = 1;i &lt; n; ++i)&#123; int index = -1,Min = Inf; for (int j = 1;j &lt;= n; ++j)&#123; if (Min &gt; temp[j].v &amp;&amp; !vis[j])&#123; Min = temp[j].v; index = j; &#125; &#125; if (bug) edg[cnt++] = temp[index]; vis[index] = 1; //printf ("%d\n",index); ans += temp[index].v; for (int j = 1;j &lt;= n; ++j)&#123; if (temp[j].v &gt; ma[index][j])&#123; temp[j].v = ma[index][j]; temp[j].s = index; temp[j].e = j; &#125; &#125; &#125; return ans;&#125;void solve()&#123; int t,m,n,a,b,c,ans; scanf ("%d",&amp;t); while (t--)&#123; memset(ma,Inf,sizeof ma); scanf ("%d%d",&amp;n,&amp;m); for (int i = 1;i &lt;= m; ++i)&#123; scanf ("%d%d%d",&amp;a,&amp;b,&amp;c); if (c == ma[a][b])&#123;//判断是否存在两条相同的边。 flag = true; &#125; ma[a][b] = min(ma[a][b],c);//每条边只取最小值 ma[b][a] = min(ma[b][a],c); &#125; ans = prime(n,true); judge(cnt,n,ans); if (flag)&#123; printf ("Not Unique!\n"); continue; &#125; else&#123; printf ("%d\n",ans); &#125; &#125;&#125;int main ()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网练习赛24-B凤凰]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%BB%83%E4%B9%A0%E8%B5%9B24-B%E5%87%A4%E5%87%B0%2F</url>
    <content type="text"><![CDATA[传送门：牛客网练习赛24-B凤凰 Describe 凤凰于飞，翙翙其羽，亦集爰止。《诗经·卷阿》传说，凤凰是百鸟之王。有一天，凤凰要召开百鸟大会，百鸟国是一个由n个节点组成的树，每个节点有一只鸟，开会的节点定在1号节点。每只鸟可以花费1s通过一条边，由于每根树枝(边)的载重有限，只允许一只鸟同时通过。作为会议的策划师，HtBest想知道百鸟国的所有鸟在1点集合最少需要多少秒。 Input 第一行有一个正整数n，表示百鸟国节点个数。接下来n-1行，第i行两个正整数ai,bi用空格隔开，表示树上节点ai,bi之间有一条边。 Output 第一行一个整数，表示集合最少需要的时间。 Example1 Input31 22 3Output2 Example2 Input31 21 3Output1 Example3 Input41 22 32 4Output3 Remark 对于100%的测试数据：1 ≤ n ≤ 1000000数据量较大，注意使用更快的输入输出方式。 &emsp;&emsp;首先明确每一个节点上都存在一只鸟，假设存在n条通往根节点（1）的路径。因此可以得到有n颗子树挂载在根节点上，不难发现所有子树上如果有m只鸟那么想要全部到达根节点必定要花费m秒。&emsp;&emsp;由于每一个节点必定存在一只鸟，因此不难证明不存在子树上有某只鸟还没通过靠近根节点路径，但是其他鸟已经全部抵达的情况。还有就是题目明确指出是树形结构，所以也不存在一颗子树存在两条通往根节点的路径的情况，否则便是图形结构。&emsp;&emsp;因此题目转化为求最大子树的节点数。两种思路可广搜遍历子树求得节点数，更为便捷的方式是并查集求解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int maxn = 1e6+5;ll F[maxn],sum[maxn];ll max(ll a,ll b)&#123; return a &gt; b ? a : b;&#125;ll find(ll u)&#123; return u == F[u] ? u : F[u] = find(F[u]);&#125;void fun_union(ll u,ll v)&#123; ll x = find(u),y = find(v); if (x != y)&#123; F[x] = y; &#125;&#125;void solve()&#123; ll cnt; scanf ("%lld",&amp;cnt); for (ll i = 1;i &lt;= cnt; ++i)&#123; F[i] = i; &#125; for (ll i = 1;i &lt; cnt; ++i)&#123; ll a,b; scanf ("%lld%lld",&amp;a,&amp;b); if (a != 1 &amp;&amp; b != 1)//由于题目给出的是整颗数，所以要排除根节点以外求子树 fun_union(a,b); &#125; for (ll i = 1;i &lt;= cnt; ++i)&#123; ++sum[F[find(i)]];//求不同子树的节点数 &#125; printf ("%lld\n",*max_element(sum+1,sum+cnt+1));//该函数求区间内最大值，返回一个指针。&#125;int main ()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
