<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[POJ-3349 Snowflake Snow Snowflakes(除留取余法，链地址法)]]></title>
    <url>%2F2018%2F10%2F11%2FPOJ-3349%2F</url>
    <content type="text"><![CDATA[传送门：POJ-3349 Snowflake Snow Snowflakes DescriptionYou may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical.InputThe first line of input will contain a single integer n, 0 &lt; n ≤ 100000, the number of snowflakes to follow. This will be followed by n lines, each describing a snowflake. Each snowflake will be described by a line containing six integers (each integer is at least 0 and less than 10000000), the lengths of the arms of the snow ake. The lengths of the arms will be given in order around the snowflake (either clockwise or counterclockwise), but they may begin with any of the six arms. For example, the same snowflake could be described as 1 2 3 4 5 6 or 4 3 2 1 6 5.OutputIf all of the snowflakes are distinct, your program should print the message:No two snowflakes are alike.If there is a pair of possibly identical snow akes, your program should print the message:Twin snowflakes found.Sample Input 21 2 3 4 5 64 3 2 1 6 5 Sample Output Twin snowflakes found. Thinkemmm，一题灰常棒的哈希题，给出N组数列，每组数列六个数字。对于两组相同数列的定义为：将数列拼接成环之后两个环可以完全契合，即两环顺序相同。 《算法精解：C语言描述》上提到的一种简单的将键值k映射到m槽位的方法：hash(k)=k mod m。而该书上写了一段话：“通常情况下，要避免m取2的幂，因为假设m=2^p，则h(k)是k的二进制数的低p位……，通常选择m会是一个素数，而且不那么靠近2的幂……”。这段话理由是：从概率的角度，出现相同的概率比较高，而通常我们希望 h(k) 的值依赖于 k 的所有位而不是最低 p 位，因为这样才会使得散列表看起来更均匀。当m不是素数时在散列分布时也会增加分布不均匀的机会，总的来说哈希函数的设计尽量使键值均匀、随机地分布在表中，其他方法可以参考《算法导论》。 我们可以利用除留取余法，将数列中所有的值都对m取余。得到结果再取余。或者直接全部相加再取余得到键值。但是这样会产生一个致命的问题就是可能产生相同键值的散列，这时便应该使用链地址法处理散列冲突。之后我们可以发现只有键值相同的数列才有可能相等，所以在线输入的时候便可以在处理冲突的时候顺便把所有键值相同的数列比较一遍。之所以不采用线性探测法是因为数据范围过大，所需哈希空间也大，设计不好的话很可能爆范围。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#define mod 14997struct Node&#123; int a[6];&#125;code[15000][100];//一维数组代表key值映射，二维存储相应的key值的冲突数列int code_index[15000];//记录对应key值的冲突数量bool vis[15000][100];//vis标记哈希表是否被占用，int hash(int buf[])//hash函数求整型数组的键值&#123; int num = 0; for (int i = 0;i &lt; 6; ++i)&#123; num += buf[i]; &#125; return num % mod;&#125;bool cmp (int m[],int n[])//比较函数&#123; bool flag; for (int s = 0;s &lt; 6; ++s)&#123;//正序环形比较 flag = true; for (int i = 0,j = s; i &lt; 6; ++i,j = (j+1)%6)&#123; //printf ("%d %d\n",i,j); if (m[i] != n[j])&#123; flag = false; break; &#125; &#125; if (flag == true)&#123; return true; &#125; &#125; for (int s = 0;s &lt; 6; ++s)&#123;//逆序环形比较 flag = true; for (int i = 0,j = s;i &lt; 6; ++i,j = (j+5)%6)&#123; //printf ("%d %d\n",i,j); if (m[i] != n[j])&#123; flag = false; break; &#125; &#125; if (flag == true)&#123; return true; &#125; &#125; return false;&#125;int main ()&#123; int n,ans = 0; Node temp; scanf ("%d",&amp;n); ++n; while (--n)&#123; for (int i = 0;i &lt; 6; ++i)&#123; scanf ("%d",&amp;temp.a[i]); &#125; if (ans == 1) continue; int num = hash(temp.a); if (vis[num][0] == true)&#123;//处理散列冲突 for (int i = 0;i &lt; code_index[num]; ++i)&#123;//只有key值相同的数列才有可能相同， //然后在对应的冲突集合中一一比较 if (cmp(code[num][i].a,temp.a) == true)&#123;//一旦有某次相同，则直接输出. printf ("Twin snowflakes found.\n"); //return 0; ans = 1; break; &#125; &#125; vis[num][code_index[num]] = true; code[num][code_index[num]++] = temp; &#125; else&#123;//非冲突情况 vis[num][code_index[num]] = true; code[num][code_index[num]++] = temp; &#125; &#125; if (ans == 0) printf ("No two snowflakes are alike.\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1016 Numbers That Count(字符串压缩)]]></title>
    <url>%2F2018%2F10%2F09%2FPOJ-1016%2F</url>
    <content type="text"><![CDATA[传送门：POJ-1016 Description “Kronecker’s Knumbers” is a little company that manufactures plastic digits for use in signs (theater marquees, gas station price displays, and so on). The owner and sole employee, Klyde Kronecker, keeps track of how many digits of each type he has used by maintaining an inventory book. For instance, if he has just made a sign containing the telephone number “5553141”, he’ll write down the number “5553141” in one column of his book, and in the next column he’ll list how many of each digit he used: two 1s, one 3, one 4, and three 5s. (Digits that don’t get used don’t appear in the inventory.) He writes the inventory in condensed form, like this: “21131435”. The other day, Klyde filled an order for the number 31123314 and was amazed to discover that the inventory of this number is the same as the number—it has three 1s, one 2, three 3s, and one 4! He calls this an example of a “self-inventorying number”, and now he wants to find out which numbers are self-inventorying, or lead to a self-inventorying number through iterated application of the inventorying operation described below. You have been hired to help him in his investigations. Given any non-negative integer n, its inventory is another integer consisting of a concatenation of integers c1 d1 c2 d2 … ck dk , where each ci and di is an unsigned integer, every ci is positive, the di satisfy 0&lt;=d1&lt;d2&lt;…&lt;dk&lt;=9, and, for each digit d that appears anywhere in n, d equals di for some i and d occurs exactly ci times in the decimal representation of n. For instance, to compute the inventory of 5553141 we set c1 = 2, d1 = 1, c2 = 1, d2 = 3, etc., giving 21131435. The number 1000000000000 has inventory 12011 (“twelve 0s, one 1”). An integer n is called self-inventorying if n equals its inventory. It is called self-inventorying after j steps (j&gt;=1) if j is the smallest number such that the value of the j-th iterative application of the inventory function is self-inventorying. For instance, 21221314 is self-inventorying after 2 steps, since the inventory of 21221314 is 31321314, the inventory of 31321314 is 31123314, and 31123314 is self-inventorying. Finally, n enters an inventory loop of length k (k&gt;=2) if k is the smallest number such that for some integer j (j&gt;=0), the value of the j-th iterative application of the inventory function is the same as the value of the (j + k)-th iterative application. For instance, 314213241519 enters an inventory loop of length 2, since the inventory of 314213241519 is 412223241519 and the inventory of 412223241519 is 314213241519, the original number (we have j = 0 in this case). Write a program that will read a sequence of non-negative integers and, for each input value, state whether it is self-inventorying, self-inventorying after j steps, enters an inventory loop of length k, or has none of these properties after 15 iterative applications of the inventory function. Input A sequence of non-negative integers, each having at most 80 digits, followed by the terminating value -1. There are no extra leading zeros. Output For each non-negative input value n, output the appropriate choice from among the following messages (where n is the input value, j is a positive integer, and k is a positive integer greater than 1):n is self-inventoryingn is self-inventorying after j stepsn enters an inventory loop of length kn can not be classified after 15 iterations Sample Input 223112331431421324151921221314111222234459-1 Sample Output 22 is self-inventorying31123314 is self-inventorying314213241519 enters an inventory loop of length 221221314 is self-inventorying after 2 steps111222234459 enters an inventory loop of length 2 思路题目大致是说有一个纯数字组成的字符串，现在这个字符串可以被压缩。压缩后的字符串规则为：c1d1c2d2…ckdk，这里d指的是一个数字，那么c指的就是d出现的次数。例如，2233224可以提取为包含了4个2，2个3，1个4，则可以压缩成422314。现在要求的问题是，有一种情况是某一个串压缩之后和原来相同，例如31123314压缩 一次 之后和原来相同，这样的字符串称为 self-inventorying。现给你一个字符串可以 循环压缩，问这个字符串是不是self-inventorying。第二种情况就是这个字符串经过第N次压缩以后，它的压缩串与N-1次压缩串相同时，那么输出 n is self-inventorying after j steps。第三种情况就是这个串第N次压缩之后与第K次压缩状态重复了，那么这时会产生一种循环，此时称 n enters an inventory loop of length k，注意这里的 K != N-1（如果这里K == N-1那么就应该是第二种情况），k指循环次数。特别地，经过15次压缩以后依旧不满足上面任何一种情况时输出 n can not be classified after 15 iterations。题目很长而且self-inventory定义也表述的比较隐晦，当且仅当压缩之后和压缩之前的字符串相同时才成立，并不是说压缩N次之后和最初原始字符串相同。然而做法特别简单，就是单纯的字符串根据规则去模拟压缩。然后map容器去离散化字符串记录即可。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;map&gt;#define ll long longusing namespace std;map&lt;string,int&gt; ma;bool get_ans(char n[],char book[],int k,char ans[])&#123; if (strcmp(n,book) == 0)&#123; if (k == 1)&#123; printf ("%s is self-inventorying\n",ans); &#125; else&#123; printf ("%s is self-inventorying after %d steps\n",ans,k - 1); &#125; return true; &#125; else &#123; if (ma[book])&#123; printf ("%s enters an inventory loop of length %d\n",ans,k - ma[book]); return true; &#125; else&#123; ma[book] = k; &#125; &#125; return false;&#125;void work (char n[])&#123; char m[20][90] = &#123;0&#125;,temp[90]; int vis = 0; ma.clear(); strcpy(m[0],n); //核心代码：循环15次压缩字符串,通过hash来记忆每个字符出现的次数从而重构新字符串 for (int k = 1;k &lt;= 15; ++k)&#123; int hash[10] = &#123;0&#125;; char book[100] = &#123;0&#125;; memset(temp,0,sizeof temp); strcpy(temp,m[k-1]); //printf ("s = %s\n",temp); int len = strlen(temp); for (int i = 0;i &lt; len; ++i)&#123;//各位数字离散化 ++hash[temp[i] - '0']; &#125; vis = 0; for (int i = 0;i &lt; 10; ++i)&#123; if (hash[i])&#123; if (hash[i] &gt; 9)&#123;//依照hash表，构造新字符串 book[vis++] = hash[i]/10 + '0'; book[vis++] = hash[i]%10 + '0'; book[vis++] = i + '0'; &#125; else&#123; book[vis++] = hash[i] + '0'; book[vis++] = i + '0'; &#125; &#125; &#125; book[vis] = '\0'; //printf ("e = %s\n\n",book); strcpy(m[k],book); //到这里，每个m[k]记录了出现过的字符串，book记录了当前出现的字符串。 if (get_ans(m[k-1],book,k,n))&#123; return ; &#125; &#125; printf ("%s can not be classified after 15 iterations\n",n);&#125;int main ()&#123; char n[90]; while (scanf ("%s",n) &amp;&amp; n[0] != '-')&#123; work(n); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3020 Antenna Placement(二分图的最小路径覆盖)]]></title>
    <url>%2F2018%2F09%2F27%2FPOJ-3020%2F</url>
    <content type="text"><![CDATA[传送门：POJ-3020 Antenna Placement Description The Global Aerial Research Centre has been allotted the task of building the fifth generation of mobile phone nets in Sweden. The most striking reason why they got the job, is their discovery of a new, highly noise resistant, antenna. It is called 4DAir, and comes in four types. Each type can only transmit and receive signals in a direction aligned with a (slightly skewed) latitudinal and longitudinal grid, because of the interacting electromagnetic field of the earth. The four types correspond to antennas operating in the directions north, west, south, and east, respectively. Below is an example picture of places of interest, depicted by twelve small rings, and nine 4DAir antennas depicted by ellipses covering them.Obviously, it is desirable to use as few antennas as possible, but still provide coverage for each place of interest. We model the problem as follows: Let A be a rectangular matrix describing the surface of Sweden, where an entry of A either is a point of interest, which must be covered by at least one antenna, or empty space. Antennas can only be positioned at an entry in A. When an antenna is placed at row r and column c, this entry is considered covered, but also one of the neighbouring entries (c+1,r),(c,r+1),(c-1,r), or (c,r-1), is covered depending on the type chosen for this particular antenna. What is the least number of antennas for which there exists a placement in A such that all points of interest are covered? Input On the first row of input is a single positive integer n, specifying the number of scenarios that follow. Each scenario begins with a row containing two positive integers h and w, with 1 &lt;= h &lt;= 40 and 0 &lt; w &lt;= 10. Thereafter is a matrix presented, describing the points of interest in Sweden in the form of h lines, each containing w characters from the set [‘*‘,’o’]. A ‘*‘-character symbolises a point of interest, whereas a ‘o’-character represents open space. Output For each scenario, output the minimum number of antennas necessary to cover all ‘*‘-entries in the scenario’s matrix, on a row of its own. Sample Input 27 9ooo**oooo**oo*ooo*o*oo**o**ooooooooo*******ooo*o*oo*oo*******oo10 1***o****** Sample Output 175 思路 题意比较明了，雷达的使用范围是当前城市或者其周围的一个城市（一个雷达最多包含两个城市）。那么给出城市地图，求最少多少个雷达可以覆盖所有的城市。此题可以将城市抽象为顶点，两个城市之间可以被雷达覆盖的话就是一条边，那么这里每条边就代表可以放置一个雷达。那么题目就转换成了怎么求最少的边可以覆盖所有的点。注意*代表了城市，o代表空地。 二分图模型的最小路径覆盖问题指的是一个边集，此边集可以连接所有的顶点，求此边集的最小值。 有如下结论：如果二分图为有向图，则 最小路径覆盖=顶点数-最大匹配数如果二分图为无向图，则 最小路径覆盖=定点数-最大匹配数/2 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;string.h&gt;char coor[41][11];//存图int ct[405][405],coor_flag[41][11],m,n,t;//建二分图int next[4][2] = &#123;0,1,0,-1,1,0,-1,0&#125;,used[405],vis[405],cut;bool found(int x)//求增广路径&#123; for(int i = 1; i &lt;= cut; i++) &#123; if(ct[x][i] &amp;&amp; !used[i]) &#123; used[i] = 1; if(vis[i] == 0 || found(vis[i])) &#123; vis[i] = x; return 1; &#125; &#125; &#125; return 0;&#125;void Create()//建图函数，对每一个城市编号然后用邻接矩阵存图&#123; for (int i = 0;i &lt; m; ++i)&#123; for (int j = 0;j &lt; n ;++j)&#123; if (coor[i][j] == '*')&#123; coor_flag[i][j] = ++cut;/*这里一定要单独用另一个函数记录顶点 ，不能用原来的coor记录，因为当路径的顶点超过127时爆范围产生 负数。char只有8位并且有一个用作符号位因此最多存储2^7数据。*/ &#125; else&#123; coor_flag[i][j] = 0; &#125; &#125; &#125; for (int i = 0;i &lt; m; ++i)&#123; for (int j = 0;j &lt; n ;++j)&#123; if (coor_flag[i][j])&#123; for (int k = 0;k &lt; 4; ++k)&#123; int x = next[k][0] + i,y = next[k][1] + j; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n) continue; if (coor_flag[x][y])&#123; ct[coor_flag[i][j]][coor_flag[x][y]] = 1; &#125; &#125; &#125; &#125; &#125;&#125;int main ()&#123; scanf ("%d",&amp;t); while (t--)&#123; memset (ct,0,sizeof ct); memset (vis,0,sizeof vis); scanf ("%d%d",&amp;m,&amp;n); for (int i = 0;i &lt; m; ++i)&#123; scanf ("%s",coor[i]); &#125; cut = 0;//记录顶点数 Create(); int ans = 0; for (int i = 1;i &lt;= cut; ++i)&#123;//KM算法求最大匹配数 memset(used,0,sizeof used); if (found(i))&#123; ++ans; &#125; &#125; printf ("%d\n",cut - ans/2);//无向图的最小路径覆盖 &#125; return 0;&#125; Hint]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2255 奔小康赚大钱(二分图最佳匹配)]]></title>
    <url>%2F2018%2F09%2F16%2FHDU-2255%2F</url>
    <content type="text"><![CDATA[传送门：HDU-2255 奔小康赚大钱 Problem Description 传说在遥远的地方有一个非常富裕的村落,有一天,村长决定进行制度改革：重新分配房子。这可是一件大事,关系到人民的住房问题啊。村里共有n间房间,刚好有n家老百姓,考虑到每家都要有房住（如果有老百姓没房子住的话，容易引起不安定因素），每家必须分配到一间房子且只能得到一间房子。另一方面,村长和另外的村领导希望得到最大的效益,这样村里的机构才会有钱.由于老百姓都比较富裕,他们都能对每一间房子在他们的经济范围内出一定的价格,比如有3间房子,一家老百姓可以对第一间出10万,对第2间出2万,对第3间出20万.(当然是在他们的经济范围内).现在这个问题就是村领导怎样分配房子才能使收入最大.(村民即使有钱购买一间房子但不一定能买到,要看村领导分配的). Input 输入数据包含多组测试用例，每组数据的第一行输入n,表示房子的数量(也是老百姓家的数量)，接下来有n行,每行n个数表示第i个村名对第j间房出的价格(n&lt;=300)。 Output 请对每组数据输出最大的收入值，每组的输出占一行。 Sample Input 2100 1015 23 Sample Output 123 思路很明显把村民和房子分成两个部分，不同人愿意接受的房子价格作为边。于是就形成了带权值的二分图模型，根据题意就是求解最佳匹配的模板题。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;using namespace std;const int Max = 400;const int INF = 0x3f3f3f3f;int match[Max],ex_x[Max],ex_y[Max],slack[Max],space[Max][Max],N;bool vis_x[Max],vis_y[Max];bool dfs(int x)&#123; vis_x[x] = true; for (int i = 0;i &lt; N; ++i)&#123; if (!vis_y[i])&#123; int gap = ex_x[x] + ex_y[i] - space[x][i]; if (gap == 0)&#123; vis_y[i] = true; if (match[i] == -1 || dfs(match[i]))&#123; match[i] = x; return true; &#125; &#125; else&#123; slack[i] = min(slack[i],gap); //由于gap始终和X集合中的x有关，因此slack必定记录了i到已经标记过的X集合中最小差值 &#125; &#125; &#125; return false;&#125;int KM()&#123; memset(match,-1,sizeof match); memset(ex_y,0,sizeof ex_y); for (int i = 0;i &lt; N; ++i)&#123; ex_x[i] = space[i][0]; for (int j = 1;j &lt; N; ++j)&#123; ex_x[i] = max(ex_x[i],space[i][j]); &#125; &#125; for (int i = 0;i &lt; N; ++i)&#123; memset(slack,INF,sizeof slack); while (true)&#123; memset(vis_x,false,sizeof vis_x); memset(vis_y,false,sizeof vis_y); if (dfs(i)) break; int d = INF; for (int j = 0;j &lt; N; ++j)&#123; if (vis_y[j] == false)&#123; d = min(slack[j],d); &#125; &#125; for (int j = 0;j &lt; N; ++j)&#123; if (vis_x[j] == true)&#123; ex_x[j] -= d; &#125; if (vis_y[j] == true)&#123; ex_y[j] += d; &#125; else&#123; slack[j] -= d; &#125; &#125; &#125; &#125; int ans = 0; for (int i = 0;i &lt; N; ++i)&#123; ans += space[match[i]][i]; &#125; return ans;&#125;int main ()&#123; while (~scanf ("%d",&amp;N))&#123; for (int i = 0;i &lt; N; ++i) for (int j = 0;j &lt; N; ++j) scanf ("%d",&amp;space[i][j]); printf ("%d\n",KM()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3041 Asteroids(二分图最小点覆盖)]]></title>
    <url>%2F2018%2F09%2F16%2FPOJ-3041%2F</url>
    <content type="text"><![CDATA[传送门：POJ-3041 Asteroids Description Bessie wants to navigate her spaceship through a dangerous asteroid field in the shape of an N x N grid (1 &lt;= N &lt;= 500). The grid contains K asteroids (1 &lt;= K &lt;= 10,000), which are conveniently located at the lattice points of the grid. Fortunately, Bessie has a powerful weapon that can vaporize all the asteroids in any given row or column of the grid with a single shot.This weapon is quite expensive, so she wishes to use it sparingly.Given the location of all the asteroids in the field, find the minimum number of shots Bessie needs to fire to eliminate all of the asteroids. Input Line 1: Two integers N and K, separated by a single space. Lines 2..K+1: Each line contains two space-separated integers R and C (1 &lt;= R, C &lt;= N) denoting the row and column coordinates of an asteroid, respectively. Output Line 1: The integer representing the minimum number of times Bessie must shoot. Sample Input 3 41 11 32 23 2 Sample Output 2 Hint INPUT DETAILS:The following diagram represents the data, where “X” is an asteroid and “.” is empty space:X.X.X..X. 思路 大致题意是说有一片区域用坐标表示，这个区域上有很多的障碍物，然后飞船可以发射激光消灭每一行或者每一列的所有障碍物，求最小发射次数。可以令坐标x，y分别作为顶点建立二分图模型，每个障碍作为连接顶点的边来看。这样便转化为了求图上最少的顶点数使得所有的边都被关联进去（有点像是最小生成树的概念……），也就是二分图最小点覆盖的问题。根据二分图模型某个定理：最大匹配数=最小点覆盖。于是乎就是非常简单的匈牙利模板。 二分图的最小点覆盖，实质是一个点集，这个集合内的所有顶点可以连接所有的边，然后求最小集合数的问题。 Code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;const int Max = 505;int m,n,map[Max][Max],match[Max];bool vis[Max];bool find(int u)&#123; for (int i = 1;i &lt;= n; ++i)&#123; if (vis[i] == false &amp;&amp; map[u][i] == 1)&#123; vis[i] = true; if (match[i] == -1 || find(match[i]))&#123; match[i] = u; return true; &#125; &#125; &#125; return false;&#125;int main ()&#123; scanf ("%d%d",&amp;n,&amp;m); memset(match,-1,sizeof match); memset(map,0,sizeof map); for (int i = 0;i &lt; m; ++i)&#123; int x,y; scanf ("%d%d",&amp;x,&amp;y); map[x][y] = 1; &#125; int ans = 0; for (int i = 1;i &lt;= n; ++i)&#123; memset(vis,0,sizeof vis); if (find(i)) ++ans; &#125; printf ("%d\n",ans); return 0;&#125; Hint]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1094 Sorting It All Out(拓扑排序)]]></title>
    <url>%2F2018%2F09%2F14%2FPOJ-1094%2F</url>
    <content type="text"><![CDATA[传送门：POJ-1094 Sorting It All Out Description An ascending sorted sequence of distinct values is one in which some form of a less-than operator is used to order the elements from smallest to largest. For example, the sorted sequence A, B, C, D implies that A &lt; B, B &lt; C and C &lt; D. in this problem, we will give you a set of relations of the form A &lt; B and ask you to determine whether a sorted order has been specified or not. Input Input consists of multiple problem instances. Each instance starts with a line containing two positive integers n and m. the first value indicated the number of objects to sort, where 2 &lt;= n &lt;= 26. The objects to be sorted will be the first n characters of the uppercase alphabet. The second value m indicates the number of relations of the form A &lt; B which will be given in this problem instance. Next will be m lines, each containing one such relation consisting of three characters: an uppercase letter, the character “&lt;” and a second uppercase letter. No letter will be outside the range of the first n letters of the alphabet. Values of n = m = 0 indicate end of input. Output For each problem instance, output consists of one line. This line should be one of the following three: Sorted sequence determined after xxx relations: yyy…y.Sorted sequence cannot be determined.Inconsistency found after xxx relations. where xxx is the number of relations processed at the time either a sorted sequence is determined or an inconsistency is found, whichever comes first, and yyy…y is the sorted, ascending sequence. Sample Input 4 6A&lt;BA&lt;CB&lt;CC&lt;DB&lt;DA&lt;B3 2A&lt;BB&lt;A26 1A&lt;Z0 0 Sample Output Sorted sequence determined after 4 relations: ABCD.Inconsistency found after 2 relations.Sorted sequence cannot be determined. 思路题目的意思有点恶心，它应该是每给出一个关系就做一次拓扑排序，有三种情况： 1、Sorted sequence determined after xxx relations: yyy…y.这表明在xxx次条件之后找到了正确的拓扑排序序列。2、Inconsistency found after xxx relations.这表明在xxx次条件之后发生了逻辑错误，即形成了环。3、Sorted sequence cannot be determined.除了以上两种情况以外都输出这个。 但是需要注意的是，第1种情况要求必须是固定的序列，拓扑排序可能发生有多种排序情况。因此每次找入度的时候必须是1。还有就是情况1中xxx不一定是输入的节点数量n，这个没看懂WA无数。还有就是不需要去重。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;string.h&gt;int map[40][40],pre[40],flag,ans[50];int check (int n)&#123; int cut = 0,temp[40],s = 1; for (int j = 0;j &lt; n; ++j)&#123; temp[j] = pre[j]; &#125; for (int t = 0;t &lt; n; ++t)&#123; int cnt = 0,index = -1; for (int i = 0;i &lt; n; ++i)&#123; if (temp[i] == 0)&#123; cnt++;//计算入度 index = i; &#125; &#125; if (cnt == 0)&#123;//有环 return 0; &#125; if (cnt &gt; 1)&#123;/*不确定顺序，但是发现顺序不确定不能直接return， 因为接下来还可能发现存在环的情况。*/ s = -1; &#125; ans[cut++] = index; temp[index] = -1; for (int j = 0;j &lt; n; ++j)&#123; if (map[index][j])&#123; --temp[j]; &#125; &#125; &#125; return s;&#125;int main ()&#123; int m,n; while (~scanf ("%lld%lld",&amp;n,&amp;m))&#123; flag = 0; if (m == 0 &amp;&amp; n == 0) break; char str[4]; memset(map,0,sizeof map); memset(pre,0,sizeof pre); for (int i = 0;i &lt; m; ++i)&#123; scanf ("%s",str); if (flag) continue;//确定结果就跳过 map[str[0] - 'A'][str[2] - 'A'] = 1; ++pre[str[2] - 'A'];//计算入度，注意边不需要去重 int s = check(n); if (s == 0)&#123;//有环 printf("Inconsistency found after %d relations.\n",i+1); flag = 1; &#125; if (s == 1)&#123;//发现了唯一的拓扑序列 printf("Sorted sequence determined after %d relations: ",i+1); for (int i = 0;i &lt; n; ++i)&#123; printf ("%c",ans[i]+'A'); &#125; printf (".\n"); flag = 1; &#125; &#125; if (flag == 0) printf("Sorted sequence cannot be determined.\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-2255 Tree Recovery(二叉树遍历)]]></title>
    <url>%2F2018%2F09%2F14%2FPOJ-2255%2F</url>
    <content type="text"><![CDATA[传送门：POJ-2255 Tree Recovery Description Little Valentine liked playing with binary trees very much. Her favorite game was constructing randomly looking binary trees with capital letters in the nodes.This is an example of one of her creations: D / \ / \ B E / \ \ / \ \ A C G / / F To record her trees for future generations, she wrote down two strings for each tree: a preorder traversal (root, left subtree, right subtree) and an inorder traversal (left subtree, root, right subtree). For the tree drawn above the preorder traversal is DBACEGF and the inorder traversal is ABCDEFG.She thought that such a pair of strings would give enough information to reconstruct the tree later (but she never tried it). Now, years later, looking again at the strings, she realized that reconstructing the trees was indeed possible, but only because she never had used the same letter twice in the same tree.However, doing the reconstruction by hand, soon turned out to be tedious.So now she asks you to write a program that does the job for her! Input The input will contain one or more test cases.Each test case consists of one line containing two strings preord and inord, representing the preorder traversal and inorder traversal of a binary tree. Both strings consist of unique capital letters. (Thus they are not longer than 26 characters.)Input is terminated by end of file. Output For each test case, recover Valentine’s binary tree and print one line containing the tree’s postorder traversal (left subtree, right subtree, root). Sample Input DBACEGF ABCDEFGBCAD CBAD Sample Output ACBFGEDCDAB 思路 给出树的前中序遍历求后序遍历而已。递归二分中序序列，对于每层递归的区间来说，找到当前区间在前序序列中最靠前的字符就是根节点，然后以该字符序号为中心往两边递归。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string.h&gt;char pre[500],inord[500],tree[500];void Create(int root,int l,int r)//递归建树&#123; int vis[500],mid = -1; memset(vis,-1,sizeof vis); for (int i = l;i &lt;= r; ++i)&#123;//标记出当前区间的字符 vis[inord[i] - 'A'] = i; &#125; for (int i = 0;i &lt; strlen(pre); ++i)&#123;//找出当前区间最早出现的字符 if (vis[pre[i] - 'A'] != -1)&#123; mid = vis[pre[i] - 'A']; break; &#125; &#125; if (mid == -1) return ; tree[root] = inord[mid]; if (mid &gt; l)&#123; Create(root*2,l,mid-1); &#125; if (mid &lt; r)&#123; Create(root*2+1,mid+1,r); &#125;&#125;void dfs(int root)&#123; if (!tree[root]) return ; dfs(root*2); dfs(root*2+1); printf ("%c",tree[root]);&#125;int main ()&#123; while (~scanf ("%s %s",&amp;pre,&amp;inord))&#123; memset(tree,0,sizeof tree); Create(1,0,strlen(pre) - 1); dfs(1); printf ("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-2965 The Pilots Brothers' refrigerator(DFS+状态压缩)]]></title>
    <url>%2F2018%2F09%2F06%2FPOJ-2965%20The%20Pilots%20Brothers'%20refrigerator%2F</url>
    <content type="text"><![CDATA[传送门：POJ-2965 The Pilots Brothers’ refrigerator Description The game “The Pilots Brothers: following the stripy elephant” has a quest where a player needs to open a refrigerator. There are 16 handles on the refrigerator door. Every handle can be in one of two states: open or closed. The refrigerator is open only when all handles are open. The handles are represented as a matrix 4х4. You can change the state of a handle in any location [i, j] (1 ≤ i, j ≤ 4). However, this also changes states of all handles in row i and all handles in column j. The task is to determine the minimum number of handle switching necessary to open the refrigerator. Input The input contains four lines. Each of the four lines contains four characters describing the initial state of appropriate handles. A symbol “+” means that the handle is in closed state, whereas the symbol “−” means “open”. At least one of the handles is initially closed. Output The first line of the input contains N – the minimum number of switching. The rest N lines describe switching sequence. Each of the lines contains a row number and a column number of the matrix separated by one or more spaces. If there are several solutions, you may give any one of them. Sample Input -+– -+– Sample Input 61 11 31 44 14 34 4 思路 和1753类似，这里将一个4X4的格子状态压缩为一个16位的bit去存储。同时对于每一次操作都事先编码成二进制的形式去与原式做按位异或运算来完成翻转操作。以当前状态作为根节点去做广度优先搜索以求出最小翻转步数。从1，1到4，4独立的翻转一次便入队，但是应该注意的是无法用map或者set去维护DSF队列，由于STL开销过大会导致TLE，直接使用数组维护即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;time.h&gt;using namespace std;clock_t t, end;char chees[7][7],str[7][7];struct node&#123; int step,to,goal,place;&#125;que[65538];long long flip[] = &#123;0xF888,0xF444,0xF222,0xF111,//记录翻转的掩码 0x8F88,0x4F44,0x2F22,0x1F11, 0x88F8,0x44F4,0x22F2,0x11F1, 0x888F,0x444F,0x222F,0x111F&#125;;string code[16] = &#123;"1 1","1 2","1 3","1 4",//记录最后需要输出的答案 "2 1","2 2","2 3","2 4", "3 1","3 2","3 3","3 4", "4 1","4 2","4 3","4 4"&#125;;int ma[70000];node start;stack&lt;int&gt; st;stack&lt;int&gt; ans;void init()//转码&#123; for (int i = 0;i &lt; 4; ++i)&#123; for (int j = 0;j &lt; 4; ++j)&#123; if (chees[i][j] == '+')&#123; start.goal |= (1 &lt;&lt; (i*4 + j)); &#125; &#125; &#125;&#125;void print_ans(int temp)&#123; printf ("%d\n",que[temp].step); do&#123; st.push(temp); temp = que[temp].to; &#125;while (temp); while (st.size())&#123; temp = st.top(); cout &lt;&lt; code[15 - que[temp].place] &lt;&lt; endl; //状态压缩的时候的顺序反了因此导致最后应该输出的答案也是反的 //ans.push(15 - que[temp].place); st.pop(); &#125;&#125;void dfs()&#123; int head = 0,end = 0; start.step = 0; que[0] = start; while (head &lt;= end)&#123; node temp = que[head]; for (int i = 0;i &lt; 16; ++i)&#123; node k; k.goal = temp.goal ^ flip[i]; k.step = temp.step + 1; k.to = head; k.place = i; if (ma[k.goal] != true)&#123; que[++end] = k; ma[k.goal] = true; &#125; if (k.goal == 0x0000)&#123;//如果有一次的状态是0那么即达到题目要求 print_ans(end); //cout &lt;&lt; endl; return ; &#125; &#125; ++head; &#125;&#125;int main ()&#123; for (int i = 0;i &lt; 4; ++i)&#123; scanf ("%s",chees[i]); &#125; //t = clock(); init(); dfs(); //end = clock(); //cout &lt;&lt; (double)(end - t) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125;/*使用map维护DFS队列开销太大对于样例程序来说运行时间为0.03s,而使用普通数组维护则时间为0.002s*/ 更多关于此题]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1753 Flip-Game(二进制枚举)]]></title>
    <url>%2F2018%2F09%2F06%2FPOJ-1753%20Flip-Game%2F</url>
    <content type="text"><![CDATA[传送门：POJ-1753 Flip-Game Description Flip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it’s black or white side up. Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules:Choose any one of the 16 pieces.Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any). Consider the following position as an example: bwbwwwwwbbwbbwwbHere “b” denotes pieces lying their black side up and “w” denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become: bwbwbwwwwwwbwwwbThe goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal. Input The input consists of 4 lines with 4 characters “w” or “b” each that denote game field position. Output Write to the output file a single integer number - the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If it’s impossible to achieve the goal, then write the word “Impossible” (without quotes). Sample Input bwwbbbwbbwwbbwww Sample Input 4 思路 将矩阵中的黑白棋子编码成二进制，16个格子枚举翻过去的话总共也才2^16种情况。实际上也可以只枚举第一行翻转的情况是2^4，主要的就是利用变量的二进制bit去做一个枚举。然后按照上一行的情况去翻转对应的下一行的格子即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;int next[4][2] = &#123;0,1,0,-1,1,0,-1,0&#125;;void flip(char chees[][7],int i,int j)&#123; chees[i][j] = !chees[i][j]; if (i+1 &lt;= 3) chees[i+1][j] = !chees[i+1][j]; if (i-1 &gt;= 0) chees[i-1][j] = !chees[i-1][j]; if (j+1 &lt;= 3) chees[i][j+1] = !chees[i][j+1]; if (j-1 &gt;= 0) chees[i][j-1] = !chees[i][j-1];&#125;bool check(char chees[][7],int t)//检查是否满足题意&#123; for (int i = 0;i &lt; 4; ++i)&#123; for (int j = 0;j &lt; 4; ++j)&#123; if (chees[i][j] != t)&#123; return false; &#125; &#125; &#125; return true;&#125;void init(char chees[][7],char str[][7])//转码&#123; for (int i = 0;i &lt; 4; ++i)&#123; for (int j = 0;j &lt; 4; ++j)&#123; if (chees[i][j] == 'b')&#123; str[i][j] = 0; &#125; else&#123; str[i][j] = 1; &#125; &#125; &#125;&#125;int main ()&#123; char chees[7][7],str[7][7]; for (int i = 0;i &lt; 4; ++i)&#123; scanf ("%s",chees[i]); &#125; init(chees,str); if (check(str,0) || check(str,1))&#123; printf ("0\n"); return 0; &#125; int ans = 99999; for (long long i = 1;i &lt;= pow(2,16); ++i)&#123; int t = -1,j = i,ans1 = 0; while (j)&#123;//通过二进制bit来决定什么位置做翻转操作 ++t; if (j % 2 == 1)&#123; ++ans1; flip(str,t/4,t%4); &#125; j /= 2; if (check(str,0) || check(str,1))&#123;//每次都要检查是否满足答案 if (ans1 != 0) ans = min (ans,ans1); &#125; &#125; init(chees,str);//实际上应该按照原来的方式再翻转一遍，复制数组是一个很不明智的做法，但是我懒-.- &#125; if (ans == 99999) printf ("Impossible\n"); else printf ("%d\n",ans); return 0;&#125; 更多关于此题]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 505 Plasticine zebra(环状字符串处理)]]></title>
    <url>%2F2018%2F09%2F02%2FPlasticine%20zebra%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #505 (rated, Div. 1 + Div. 2) Problem C Description Is there anything better than going to the zoo after a tiresome week at work? No wonder Grisha feels the same while spending the entire weekend accompanied by pretty striped zebras. Inspired by this adventure and an accidentally found plasticine pack (represented as a sequence of black and white stripes), Grisha now wants to select several consequent (contiguous) pieces of alternating colors to create a zebra. Let’s call the number of selected pieces the length of the zebra. Before assembling the zebra Grisha can make the following operation 00 or more times. He splits the sequence in some place into two parts, then reverses each of them and sticks them together again. For example, if Grisha has pieces in the order “bwbbw” (here ‘b’ denotes a black strip, and ‘w’ denotes a white strip), then he can split the sequence as bw|bbw (here the vertical bar represents the cut), reverse both parts and obtain “wbwbb”. Determine the maximum possible length of the zebra that Grisha can produce. Input The only line contains a string ss (1≤|s|≤10^5, where |s| denotes the length of the string ss) comprised of lowercase English letters ‘b’ and ‘w’ only, where ‘w’ denotes a white piece and ‘b’ denotes a black piece. Output Print a single integer — the maximum possible zebra length. Input Output bwwwbwwbw 5 bwwbwwb 3 题意 给出一个字符串，该串只有两种字母。然后可以在任意处切开形成两个字符串，然后反转之后再拼接到一起，可以做任意次该操作。求最长交错的字符串长度。如wwbwbbbw，最长交错字符串为wbwb。 思路 在该字符串中任意一点切开反转再连接。无论如何必定会使首尾相连。如果一开始就将首尾连接形成一个环的话。那么在这个环上任意一点切开反转之后再连接和原来一模一样，只是起点位发生变化。也可以说，无论原来的串经过多少次合法操作，它始终都是这个环的子串。例如abcdef首尾连接形成环，从cd处操作。最后形成cbafed，首尾连接后依旧符合abcdef的环。那么无论做多少次操作都和做一次是一样的。因此对于本题来说只需要对环上直接找出最长交错子串即可。对于选取起点的问题，可以在环上找任意起点，循环扫描两遍即可。不需要对每一个字符做作为起点进行扫描，那样的时间复杂度是O(n^2)。也可以复制字符串拼接起来扫描一遍，但这样的问题就是当一开始就是交错字符串的情况需要特殊判断。 code 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;char str[100100*2];int main ()&#123; bool flag = true; scanf ("%s",str); int len = strlen(str),ans = 1,max_ans = 0; for (int i = 1;i &lt; len; ++i)&#123;//特殊处理一开始就是交错字符串的情况 if (str[i] == str[i-1])&#123; flag = false; &#125; &#125; if (flag)&#123; cout &lt;&lt; len &lt;&lt; endl; return 0; &#125; for (int i = 0;i &lt; len; ++i)&#123;//复制字符串 str[i+len] = str[i]; &#125; for (int i = 1; i&lt; len*2; ++i)&#123; if (str[i] != str[i-1])&#123; ++ans; &#125; else&#123; ans = 1; &#125; max_ans = max(max_ans,ans); &#125; cout &lt;&lt; max_ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weakened Common Divisor]]></title>
    <url>%2F2018%2F09%2F01%2FWeakened%20Common%20Divisor%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #505 Weakened Common Divisor Description During the research on properties of the greatest common divisor (GCD) of a set of numbers, Ildar, a famous mathematician, introduced a brand new concept of the weakened common divisor (WCD) of a list of pairs of integers. For a given list of pairs of integers (a1,b1)(a1,b1), (a2,b2)(a2,b2), …, (an,bn)(an,bn) their WCD is arbitrary integer greater than 11, such that it divides at least one element in each pair. WCD may not exist for some lists. For example, if the list looks like [(12,15),(25,18),(10,24)], then their WCD can be equal to 22, 33, 55 or 66 (each of these numbers is strictly greater than 11 and divides at least one number in each pair). You’re currently pursuing your PhD degree under Ildar’s mentorship, and that’s why this problem was delegated to you. Your task is to calculate WCD efficiently. Input The first line contains a single integer nn (1≤n≤150000) — the number of pairs. Each of the next nn lines contains two integer values aiai, bibi (2≤ai,bi≤2⋅10^9). Output Print a single integer — the WCD of the set of pairs. If there are multiple possible answers, output any; if there is no answer, print −1−1. input 317 1815 2412 15 output 6 input 210 167 17 output -1 input 590 10845 10575 40165 17533 30 output 5 题意大意是说给出n组数，每组两个数字。从每组数中取出一个数，求n组数的质因数。不存在则输出-1。 思路假设给出一组数a b，a或b的质因数必然也是a*b的质因数。之后再枚举第一组数据的质因数即可。 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll gcd(ll a,ll b)&#123; return b == 0?a:gcd(b,a%b);&#125;ll get_ans(ll n)//为了防止最初的答案大于题目给出的数据&#123; for (int i = 2;i * i &lt;= n; ++i)&#123; if (n % i == 0) return i; &#125; return n;&#125;int main ()&#123; ll a,b,n,A,B; scanf("%lld%lld%lld",&amp;n,&amp;a,&amp;b); while (--n)&#123; scanf ("%lld%lld",&amp;A,&amp;B); a = gcd(A*B,a); b = gcd(A*B,b); &#125; if (a != 1)&#123; printf ("%lld\n",get_ans(a)); &#125; else if (b != 1)&#123; printf ("%lld\n",get_ans(b)); &#125; else&#123; printf ("-1\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces Round 49-Minimum Value Rectangle]]></title>
    <url>%2F2018%2F08%2F20%2FMinimum%20Value%20Rectangle%2F</url>
    <content type="text"><![CDATA[传送门：C. Minimum Value Rectangle Problem Description You have n sticks of the given lengths. Your task is to choose exactly four of them in such a way that they can form a rectangle. No sticks can be cut to pieces, each side of the rectangle must be formed by a single stick. No stick can be chosen multiple times. It is guaranteed that it is always possible to choose such sticks. Let S be the area of the rectangle and P be the perimeter of the rectangle. The chosen rectangle should have the value P^2/S minimal possible. The value is taken without any rounding. If there are multiple answers, print any of them. Each testcase contains several lists of sticks, for each of them you are required to solve the problem separately.Example Input347 2 2 782 8 1 4 8 2 1 555 5 5 5 5 Output2 7 7 22 2 1 15 5 5 5 大意就是说有T次查询，每次给出n条边，选出四条边组成一个矩形。然后P是其周长，S是面积现在求出P^2/S最小时，边长的组合。答案不唯一。每条边的边长不超过10^4。在所有的T次查询中，所有边的数量之和不会超过10^6。 思路:由于矩形的定义就是四个角都是直角。所以可以假设边长为a，b。代入P^2/S中得 4*(a/b + b/a + 2) 其中 a/b + b/a 可以令 t = a/b 转化成 (t + 1/t) .这个这里可以得出当a == b时式子最小等于2。于是可以得出原式 &gt;=16 。并且我们可以看出去最小时a，b之间的关系是a和b尽可能的相等。于是这道题只需要排序之后把大于2的边拿出来。答案一定是排序之后两条长度相邻的边。 然后从小到大两两进行比较，找出最优解。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;using namespace std;int edg[1000005];int temp[1000005];int main ()&#123; int t,n; scanf ("%d",&amp;t); ++t; while (--t)&#123; scanf ("%d",&amp;n); for (int i = 0;i &lt; n; ++i)&#123; scanf ("%d",&amp;edg[i]); &#125; sort (edg,edg+n); int cnt = -1; for (int i = 1;i &lt; n; ++i)&#123; if (edg[i] == edg[i-1])&#123;//如果有两条相等的边，就把它放入temp数组 temp[++cnt] = edg[i]; edg[i] = edg[i-1] = -1;/*这一步是必须的，否则会误判边的数量 如果edg有1 1 1.三个数，那么根据规律会有两个1被选入temp 接下来的处理中就会使用两条边为 1和1来组成矩形。可实际上并没有四条长度为1的边。*/ &#125; &#125; int s = -1; double Min = 999989.0; double t; for (int i = 1;i &lt;= cnt; ++i)&#123; //枚举两条相邻的边找出最优解 t = 4 * (double)(temp[i-1]+temp[i]) * (double)(temp[i-1]+temp[i]) / (double)(temp[i-1]*temp[i]); //printf ("%d %d %lf\n",temp[i],temp[i-1],t); if (Min &gt; t)&#123; Min = t; s = i; &#125; &#125; printf ("%d %d %d %d\n",temp[s],temp[s],temp[s-1],temp[s-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>基础数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-4081 Qin Shi Huang's National Road System(次小生成树)]]></title>
    <url>%2F2018%2F08%2F17%2Fhdu-4081%2F</url>
    <content type="text"><![CDATA[传送门：Qin Shi Huang’s National Road SystemProblem Description During the Warring States Period of ancient China(476 BC to 221 BC), there were seven kingdoms in China —- they were Qi, Chu, Yan, Han, Zhao, Wei and Qin. Ying Zheng was the king of the kingdom Qin. Through 9 years of wars, he finally conquered all six other kingdoms and became the first emperor of a unified China in 221 BC. That was Qin dynasty —- the first imperial dynasty of China(not to be confused with the Qing Dynasty, the last dynasty of China). So Ying Zheng named himself “Qin Shi Huang” because “Shi Huang” means “the first emperor” in Chinese.Qin Shi Huang undertook gigantic projects, including the first version of the Great Wall of China, the now famous city-sized mausoleum guarded by a life-sized Terracotta Army, and a massive national road system. There is a story about the road system:There were n cities in China and Qin Shi Huang wanted them all be connected by n-1 roads, in order that he could go to every city from the capital city Xianyang.Although Qin Shi Huang was a tyrant, he wanted the total length of all roads to be minimum,so that the road system may not cost too many people’s life. A daoshi (some kind of monk) named Xu Fu told Qin Shi Huang that he could build a road by magic and that magic road would cost no money and no labor. But Xu Fu could only build ONE magic road for Qin Shi Huang. So Qin Shi Huang had to decide where to build the magic road. Qin Shi Huang wanted the total length of all none magic roads to be as small as possible, but Xu Fu wanted the magic road to benefit as many people as possible —- So Qin Shi Huang decided that the value of A/B (the ratio of A to B) must be the maximum, which A is the total population of the two cites connected by the magic road, and B is the total length of none magic roads.Would you help Qin Shi Huang?A city can be considered as a point, and a road can be considered as a line segment connecting two points. Input The first line contains an integer t meaning that there are t test cases(t &lt;= 10).For each test case:The first line is an integer n meaning that there are n cities(2 &lt; n &lt;= 1000).Then n lines follow. Each line contains three integers X, Y and P ( 0 &lt;= X, Y &lt;= 1000, 0 &lt; P &lt; 100000). (X, Y) is the coordinate of a city and P is the population of that city.It is guaranteed that each city has a distinct location. Output For each test case, print a line indicating the above mentioned maximum ratio A/B. The result should be rounded to 2 digits after decimal point. Sample Input 241 1 201 2 30200 2 80200 1 10031 1 201 2 302 2 40 Sample Output 65.0070.00 &emsp;&emsp;题意：给出一堆城市，现在要在每个城市修建公路。要求在公路总长度尽可能的短，并且连接所有的城市。然后这个城市都有一定的人口，现在有一个道士可以使得某条道路不花费任何资源直接变出来。现在要求是，假设这条变出来的道路所连接城市的人口是A ，总的道路长度减去变出来那条路的长度为B。求A/B的最大值，保证A/B最大的同时其他道路总长要求尽可能的短 &emsp;&emsp;思路：先求最小生成树，然后在题目给的无向图里面枚举每一条边，如果这条边没在生成树里面的话就暂时把它加进去，但是加进去的话生成树就会形成一个环。这时就要找出这个环里面的最大的边把它删掉，求出次小生成树。然后把最小生成树的总权值减去之后删掉的边就是B，那条加入的边连接的两点人数之和就是A。重复枚举边做这个过程找出最大的A/B。&emsp;&emsp;这里关于prim算法有一个以前没注意到的细节，那就是prim算法每次确定下一条边的时候，这个确定的顺序一定是按照从根节点开始向下延伸的。&emsp;&emsp;所以关于建树，用一个数组记录每次使用的边的前驱即可。假设low数组中求得的最小值位置为index，那么low[index]代表的是一条边，并且这个index代表的节点一定是这条边上更加远离根节点的。所以在下一步对生成树进行优化的时候。对于可被优化的low[p];应令pre[p] = index;去记录前驱。&emsp;&emsp;感觉这题最难的地方是由于新加入的边必定会连接A-B两个点。那么便要DP找出最小生成树上A-B两点之间的最大边以便将其删除。其状态转移方程如下： vis[j][index] = vis[index][j] = max(vis[j][pre[index]],low[index]); &emsp;&emsp;在这个式子中，vis保存任意两点之间的最大边，pre是前驱。那么对于某一个节点j，当j是prim算法使用过的节点。那么，j到其他已经被确定的点之间的最大边必定是处理过的。又由于生成树的过程是从根节点开始延伸，所以只需要每次确定出index的时候遍历出v[j]，如果j被使用过，就比较index的前驱（这里pre[index]由于生成树的过程是从根节点开始延伸，所以与j之间的最长边必定被处理过）与index到pre[index]这条边就可以了。这里low[index]就是index-pre[index]这条边。这个DP还是比较难以理解的。 &emsp;&emsp;如上图所示，vis所谓的两点之间最长边就是指如果我把7-9这条边加进去，那么3-6-9-7便形成环，所以我就要求出vis[7][9]–7到9之间的在原本还不是环的时候（也就是最小生成树上的）的最大边也就是6-9（权值为4）。这时我要求7-9的最大边，假设我当前index为7且9被使用过。那么比较pre[7]（也就是3）到9的最大边和7到3的边就OK了。再次重申由于最小生成树建树是从根节点开始延伸，所以index的前驱和其他被使用过的节点之间一定被处理过。 &emsp;&emsp;有个坑点是在传统prim算法中，用index去优化low数组时，会加上一个条件是当前被优化的j节点没被使用过，但是这个条件不加上的话对于生成树的最后答案并无影响，可是却会对严重影响DP的过程，因为这个原因WA了好几发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;const int Inf=0x3f3f3f3f;using namespace std;double vis[1005][1005];int book[1005][1005];struct node&#123; int p;//两城市之间人口 double dis;//城市之间距离&#125;ma[1005][1005];struct Point&#123; int x,y; int v;//城市的人口&#125;point[1005];double Dis(Point a,Point b)&#123; return sqrt((double)(a.x-b.x)*(a.x-b.x)+(double)(a.y-b.y)*(a.y-b.y));&#125;double prim(int n)&#123; int v[1005] = &#123;0&#125;,pre[1005]; double dis[1005],ans = 0; v[1] = 1; for (int i = 1;i &lt;= n; ++i)&#123; dis[i] = ma[1][i].dis;//1为根节点 pre[i] = 1;//节点的前驱 &#125; for (int i = 1;i &lt; n; ++i)&#123; int index = 0; for (int j = 1;j &lt;= n; ++j)&#123; if ((index == 0 || dis[index] &gt; dis[j]) &amp;&amp; !v[j])&#123; index = j; &#125; &#125; v[index] = 1; ans += dis[index]; book[index][pre[index]] = book[pre[index]][index] = 1;//记录被使用过的边 for (int j = 1;j &lt;= n; ++j)&#123; if (v[j] &amp;&amp; j != index)&#123; //这里一个DP找出生成树上任意两点间的最大边 vis[j][index] = vis[index][j] = max(vis[j][pre[index]],dis[index]); &#125; if (!v[j] &amp;&amp; dis[j] &gt; ma[index][j].dis)&#123;//这里优化的时候!v[j]这个条件必须加上！！！！ dis[j] = ma[index][j].dis; pre[j] = index; &#125; &#125; &#125; return ans;&#125;void create(int n)&#123; for (int i = 1;i &lt;= n; ++i)&#123; for (int j = i+1;j &lt;= n; ++j)&#123; if (i == j)&#123; ma[i][j].dis = ma[j][i].dis = Inf*1.0; ma[i][j].p = ma[j][i].p = Inf*1.0; continue; &#125; ma[i][j].dis = ma[j][i].dis = Dis(point[i],point[j]); ma[i][j].p = ma[j][i].p = point[i].v + point[j].v; &#125; &#125;&#125;double DP(int n,double MST)&#123; double ans = 0; for (int i = 1;i &lt;= n; ++i)&#123; for (int j = i+1;j &lt;= n; ++j)&#123; if (i != j)&#123; if (book[i][j])&#123;//如果当前遍历的边就在最小生成树上 ans = max(ans,1.0*(ma[i][j].p)/(MST - ma[i][j].dis)); &#125; else&#123; ans = max(ans,1.0*(ma[i][j].p)/(MST - vis[i][j]));//如果不在 &#125; &#125; &#125; &#125; return ans;&#125;void solve()&#123; int t,n; double MST,ans = 0; scanf ("%d",&amp;t); while (t--)&#123; ans = 0;//又他娘的忘记初始化WA好几发-.-! scanf ("%d",&amp;n); memset(book,0,sizeof book); memset(vis,0,sizeof vis); memset(ma,0,sizeof ma); memset(point,0,sizeof point); for (int i = 1;i &lt;= n; ++i)&#123; scanf ("%d%d%d",&amp;point[i].x,&amp;point[i].y,&amp;point[i].v); &#125; create(n); MST = prim(n); ans = DP(n,MST); printf ("%.2f\n",ans); &#125;&#125;int main ()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1679 Unique MST(判断最小生成树是否唯一)]]></title>
    <url>%2F2018%2F08%2F16%2FPOJ-1679%20Unique%20MST%2F</url>
    <content type="text"><![CDATA[传送门：POJ-1679 Unique MST Description Given a connected undirected graph, tell if its minimum spanning tree is unique. Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: V’ = V. T is connected and acyclic. Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’. Input The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. Each case represents a graph. It begins with a line containing two integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the following m lines contains a triple (xi, yi, wi), indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them. Output For each input, if the MST is unique, print the total cost of it, or otherwise print the string ‘Not Unique!’. Sample Input 23 31 2 12 3 23 1 34 41 2 22 3 23 4 24 1 2Sample Output 3Not Unique! 思路 选择邻接矩阵存图，读取边的时候先判断是否存在两条相同的边，如果存在则MST不唯一。再做出最小生成树，将所有已经使用过的边，依次从邻接矩阵中删除，再求最小生成树。如果两次答案一致，则MST不唯一。不要忘记删除过的边要再放回去。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define Inf 0x3f3f3f3fusing namespace std;bool flag;struct node&#123; int s,e,v;&#125;edg[205];//记录最小生成树所包含的边的信息int ma[205][205],cnt;//cnt记录最小生成树的边的数量int prime(int n,bool bug);int cmp(node a,node b)&#123; return a.v &gt; b.v;&#125;void judge(int cnt,int n,int ans)&#123; sort(edg,edg+cnt,cmp); for (int i = 0;i &lt; cnt; ++i)&#123; /*将每条使用过的边都从邻接矩阵中删除，再求一次最小生成树， 如果与之前相同，则MST不唯一*/ ma[edg[i].s][edg[i].e] = Inf; ma[edg[i].e][edg[i].s] = Inf; if (prime(n,false) == ans)&#123; flag = true; return ; &#125; //不要忘了删掉的边要再添加回去 ma[edg[i].s][edg[i].e] = edg[i].v; ma[edg[i].e][edg[i].s] = edg[i].v; &#125; flag = false;&#125;int prime(int n,bool bug)&#123; int vis[205] = &#123;0&#125;,ans = 0; if (bug)&#123;//bug变量标记在judge函数中调用不需要对edg做修改 memset(edg,0,sizeof edg); cnt = 0; &#125; node temp[205]; for (int i = 2;i &lt;= n; i++)&#123; temp[i].v = ma[1][i]; temp[i].s = 1; temp[i].e = i; //printf ("%d\n",temp[i]); &#125; vis[1] = 1; for (int i = 1;i &lt; n; ++i)&#123; int index = -1,Min = Inf; for (int j = 1;j &lt;= n; ++j)&#123; if (Min &gt; temp[j].v &amp;&amp; !vis[j])&#123; Min = temp[j].v; index = j; &#125; &#125; if (bug) edg[cnt++] = temp[index]; vis[index] = 1; //printf ("%d\n",index); ans += temp[index].v; for (int j = 1;j &lt;= n; ++j)&#123; if (temp[j].v &gt; ma[index][j])&#123; temp[j].v = ma[index][j]; temp[j].s = index; temp[j].e = j; &#125; &#125; &#125; return ans;&#125;void solve()&#123; int t,m,n,a,b,c,ans; scanf ("%d",&amp;t); while (t--)&#123; memset(ma,Inf,sizeof ma); scanf ("%d%d",&amp;n,&amp;m); for (int i = 1;i &lt;= m; ++i)&#123; scanf ("%d%d%d",&amp;a,&amp;b,&amp;c); if (c == ma[a][b])&#123;//判断是否存在两条相同的边。 flag = true; &#125; ma[a][b] = min(ma[a][b],c);//每条边只取最小值 ma[b][a] = min(ma[b][a],c); &#125; ans = prime(n,true); judge(cnt,n,ans); if (flag)&#123; printf ("Not Unique!\n"); continue; &#125; else&#123; printf ("%d\n",ans); &#125; &#125;&#125;int main ()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PID算法小结]]></title>
    <url>%2F2018%2F08%2F15%2FPID%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在控制算法系统中，先设定一个目标值假设为S，再由传感器定时采样。假设读取的值为依次为X1，X2，X3……Xk。 P(比例)控制:&emsp;&emsp;假设对每次采样的结果Xk，使Pk = S - Xk。其产生三种结果 Pk &gt; 0 当前值未达标Pk == 0 当前值已达标Pk &lt; 0 当前值超标 &emsp;&emsp;则在P控制中，TOUT = Kp * Pk，其中Kp为常数，起到一个等比例放大或缩小的作用Pk实际意义便是与目标的差值，P控制的输出量由这个差值等比例放大决定。 I(积分)控制&emsp;&emsp;假设Sk = ∑Pn （n ∈[1,k]）。同样的，由于Pk的值有正有负。因此Sk的值也分为三种情况 Sk &gt; 0 在过去的时间内，系统总体上是不达标的Sk == 0 在过去的时间内，系统总体上是达标的Sk &lt; 0 在过去的时间内，系统总体上是超标的 &emsp;&emsp;此时TOUT = Kp * Sk 对应的是积分操作，由过去历史总体情况作出预测。缺点是较长时间之前的数据也会对现在的预测产生影响。 D(微分)控制&emsp;&emsp;由于之前已经取得了每个采集样本的Pk值，即采集值与目标值的偏移量，使Dk = Pk - P(k-1)则Dk描述了此偏移量的变化的快慢。同样分为三种结果 Dk &gt; 0Dk == 0Dk &lt; 0 &emsp;&emsp;此时的TOUT = Kp * Dk，显而易见这时的输出量由变化率决定。变化率越大，则输出值越大 PID的数学模型&emsp;&emsp;基于上式，最后输出值TOUT = Pout + Iout + Dout代入合并之后 Tout = (Kp Pk) + (Kp Sk) + (Kp * Dk) (关于Sk Dk的处理下次在写叭)]]></content>
      <categories>
        <category>嵌入式算法</category>
      </categories>
      <tags>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网练习赛24-B凤凰]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%BB%83%E4%B9%A0%E8%B5%9B24-B%E5%87%A4%E5%87%B0%2F</url>
    <content type="text"><![CDATA[传送门：牛客网练习赛24-B凤凰 Describe 凤凰于飞，翙翙其羽，亦集爰止。《诗经·卷阿》传说，凤凰是百鸟之王。有一天，凤凰要召开百鸟大会，百鸟国是一个由n个节点组成的树，每个节点有一只鸟，开会的节点定在1号节点。每只鸟可以花费1s通过一条边，由于每根树枝(边)的载重有限，只允许一只鸟同时通过。作为会议的策划师，HtBest想知道百鸟国的所有鸟在1点集合最少需要多少秒。 Input 第一行有一个正整数n，表示百鸟国节点个数。接下来n-1行，第i行两个正整数ai,bi用空格隔开，表示树上节点ai,bi之间有一条边。 Output 第一行一个整数，表示集合最少需要的时间。 Example1 Input31 22 3Output2 Example2 Input31 21 3Output1 Example3 Input41 22 32 4Output3 Remark 对于100%的测试数据：1 ≤ n ≤ 1000000数据量较大，注意使用更快的输入输出方式。 &emsp;&emsp;首先明确每一个节点上都存在一只鸟，假设存在n条通往根节点（1）的路径。因此可以得到有n颗子树挂载在根节点上，不难发现所有子树上如果有m只鸟那么想要全部到达根节点必定要花费m秒。&emsp;&emsp;由于每一个节点必定存在一只鸟，因此不难证明不存在子树上有某只鸟还没通过靠近根节点路径，但是其他鸟已经全部抵达的情况。还有就是题目明确指出是树形结构，所以也不存在一颗子树存在两条通往根节点的路径的情况，否则便是图形结构。&emsp;&emsp;因此题目转化为求最大子树的节点数。两种思路可广搜遍历子树求得节点数，更为便捷的方式是并查集求解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int maxn = 1e6+5;ll F[maxn],sum[maxn];ll max(ll a,ll b)&#123; return a &gt; b ? a : b;&#125;ll find(ll u)&#123; return u == F[u] ? u : F[u] = find(F[u]);&#125;void fun_union(ll u,ll v)&#123; ll x = find(u),y = find(v); if (x != y)&#123; F[x] = y; &#125;&#125;void solve()&#123; ll cnt; scanf ("%lld",&amp;cnt); for (ll i = 1;i &lt;= cnt; ++i)&#123; F[i] = i; &#125; for (ll i = 1;i &lt; cnt; ++i)&#123; ll a,b; scanf ("%lld%lld",&amp;a,&amp;b); if (a != 1 &amp;&amp; b != 1)//由于题目给出的是整颗数，所以要排除根节点以外求子树 fun_union(a,b); &#125; for (ll i = 1;i &lt;= cnt; ++i)&#123; ++sum[F[find(i)]];//求不同子树的节点数 &#125; printf ("%lld\n",*max_element(sum+1,sum+cnt+1));//该函数求区间内最大值，返回一个指针。&#125;int main ()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
