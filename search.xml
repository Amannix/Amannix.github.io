<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[练习赛24-B凤凰]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%BB%83%E4%B9%A0%E8%B5%9B24-B%E5%87%A4%E5%87%B0%2F</url>
    <content type="text"><![CDATA[牛客网练习赛24-B凤凰 Describe 凤凰于飞，翙翙其羽，亦集爰止。《诗经·卷阿》传说，凤凰是百鸟之王。有一天，凤凰要召开百鸟大会，百鸟国是一个由n个节点组成的树，每个节点有一只鸟，开会的节点定在1号节点。每只鸟可以花费1s通过一条边，由于每根树枝(边)的载重有限，只允许一只鸟同时通过。作为会议的策划师，HtBest想知道百鸟国的所有鸟在1点集合最少需要多少秒。 Input 第一行有一个正整数n，表示百鸟国节点个数。接下来n-1行，第i行两个正整数ai,bi用空格隔开，表示树上节点ai,bi之间有一条边。 Output 第一行一个整数，表示集合最少需要的时间。 Example1 Input31 22 3Output2 Example2 Input31 21 3Output1 Example3 Input41 22 32 4Output3 Remark 对于100%的测试数据：1 ≤ n ≤ 1000000数据量较大，注意使用更快的输入输出方式。 &emsp;&emsp;首先明确每一个节点上都存在一只鸟，假设存在n条通往根节点（1）的路径。因此可以得到有n颗子树挂载在根节点上，不难发现所有子树上如果有m只鸟那么想要全部到达根节点必定要花费m秒。&emsp;&emsp;由于每一个节点必定存在一只鸟，因此不难证明不存在子树上有某只鸟还没通过靠近根节点路径，但是其他鸟已经全部抵达的情况。还有就是题目明确指出是树形结构，所以也不存在一颗子树存在两条通往根节点的路径的情况，否则便是图形结构。&emsp;&emsp;因此题目转化为求最大子树的节点数。两种思路可广搜遍历子树求得节点数，更为便捷的方式是并查集求解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int maxn = 1e6+5;ll F[maxn],sum[maxn];ll max(ll a,ll b)&#123; return a &gt; b ? a : b;&#125;ll find(ll u)&#123; return u == F[u] ? u : F[u] = find(F[u]);&#125;void fun_union(ll u,ll v)&#123; ll x = find(u),y = find(v); if (x != y)&#123; F[x] = y; &#125;&#125;void solve()&#123; ll cnt; scanf ("%lld",&amp;cnt); for (ll i = 1;i &lt;= cnt; ++i)&#123; F[i] = i; &#125; for (ll i = 1;i &lt; cnt; ++i)&#123; ll a,b; scanf ("%lld%lld",&amp;a,&amp;b); if (a != 1 &amp;&amp; b != 1)//由于题目给出的是整颗数，所以要排除根节点以外求子树 fun_union(a,b); &#125; for (ll i = 1;i &lt;= cnt; ++i)&#123; ++sum[F[find(i)]];//求不同子树的节点数 &#125; printf ("%lld\n",*max_element(sum+1,sum+cnt+1));//该函数求区间内最大值，返回一个指针。&#125;int main ()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
